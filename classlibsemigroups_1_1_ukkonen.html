<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- BEGIN opengraph metadata -->
    <meta property="og:title" content="libsemigroups" />
    <meta property="og:image" content="libsemi_logo.jpeg" />
    <meta
      property="og:description"
      content="C++ library for semigroups and monoids."
    />
    <meta
      property="og:url"
      content="https://github.com/libsemigroups/libsemigroups"
    />
    <!-- END opengraph metadata -->
<title>libsemigroups: Ukkonen</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/libsemigroups/libsemigroups" class="github-corner" title="View source on GitHub" target="_blank" rel="noopener noreferrer">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<a href="index.html">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="libsemi_logo.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsemigroups
   &#160;<span id="projectnumber">v3.2.0</span>
   </div>
   <div id="projectbrief">C++ library for semigroups and monoids</div>
  </td>
 </tr>
 </tbody>
</table>
</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="_HEADING_"><span>Library&#160;Info</span></a></li>
      <li><a href="md_authors.html"><span>Authors</span></a></li>
      <li><a href="citelist.html"><span>Bibliography</span></a></li>
      <li><a href="md_changelog-v3.html"><span>Changelog&#160;-&#160;version&#160;3</span></a></li>
      <li><a href="md_changelog-v2.html"><span>Changelog&#160;-&#160;version&#160;2</span></a></li>
      <li><a href="md_changelog-v1.html"><span>Changelog&#160;-&#160;version&#160;1</span></a></li>
      <li><a href="md_deprecate.html"><span>Deprecation</span></a></li>
      <li><a href="md_install.html"><span>Installation</span></a></li>
      <li><a href="_HEADING_"><span>Data&#160;structures</span></a></li>
      <li><a href="group__adapters__group.html"><span>Adapters</span></a></li>
      <li><a href="group__constants__group.html"><span>Constants</span></a></li>
      <li><a href="group__elements__group.html"><span>Elements</span></a></li>
      <li><a href="group__exception__group.html"><span>Exceptions</span></a></li>
      <li><a href="group__orders__group.html"><span>Orders</span></a></li>
      <li><a href="group__presentations__group.html"><span>Presentations</span></a></li>
      <li><a href="group__ranges__group.html"><span>Ranges</span></a></li>
      <li><a href="group__ukkonen__group.html"><span>Suffix&#160;trees</span></a></li>
      <li><a href="group__make__group.html"><span>The&#160;`make`&#160;function</span></a></li>
      <li><a href="group__to__group.html"><span>The&#160;`to`&#160;function</span></a></li>
      <li><a href="group__aho__corasick__group.html"><span>Tries</span></a></li>
      <li><a href="group__types__group.html"><span>Enums&#160;+&#160;Types</span></a></li>
      <li><a href="group__dot__group.html"><span>Visualisation</span></a></li>
      <li><a href="group__word__graph__group.html"><span>Word&#160;graphs</span></a></li>
      <li><a href="group__words__group.html"><span>Words</span></a></li>
      <li><a href="_HEADING_"><span>Main&#160;Algorithms</span></a></li>
      <li><a href="group__action__group.html"><span>Actions</span></a></li>
      <li><a href="group__cong__common__helpers__group.html"><span>Common&#160;congruence&#160;helper&#160;function</span></a></li>
      <li><a href="group__congruence__group.html"><span>Congruence</span></a></li>
      <li><a href="group__core__classes__group.html"><span>Core&#160;classes</span></a></li>
      <li><a href="group__froidure__pin__group.html"><span>Froidure-Pin</span></a></li>
      <li><a href="group__kambites__group.html"><span>Kambites</span></a></li>
      <li><a href="group__knuth__bendix__group.html"><span>Knuth-Bendix</span></a></li>
      <li><a href="group__konieczny__group.html"><span>Konieczny</span></a></li>
      <li><a href="group__sims__group.html"><span>Low&#160;Index&#160;Congruences</span></a></li>
      <li><a href="group__freeband__group.html"><span>Radoszewski-Rytter</span></a></li>
      <li><a href="group__schreier__sims__group.html"><span>Schreier-Sims</span></a></li>
      <li><a href="group__stephen__group.html"><span>Stephen</span></a></li>
      <li><a href="group__todd__coxeter__group.html"><span>Todd-Coxeter</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classlibsemigroups_1_1_ukkonen.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlibsemigroups_1_1_ukkonen-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ukkonen<div class="ingroups"><a class="el" href="group__ukkonen__group.html">Ukkonen</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a>
<div class="textblock"><p>This class implements Ukkonen's algorithm for constructing a generalised suffix tree consisting of <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a>. The implementation in this class is based on:</p>
<p><a href="https://cp-algorithms.com/string/suffix-tree-ukkonen.html">https://cp-algorithms.com/string/suffix-tree-ukkonen.html</a></p>
<p>The suffix tree is updated when the member function <a class="el" href="#a29364e124fc8ca5b05d670d437fb1a9e">add_word</a> is invoked. Every non-duplicate word added to the tree has a unique letter appended to the end. If a duplicate word is added, then the tree is not modified, but the <a class="el" href="#ad7f5263d6025e25ea81c3452fe48447b">multiplicity</a> of the word is increased. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the nodes in the tree.  <a href="structlibsemigroups_1_1_ukkonen_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">State</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return type of <a class="el" href="#ad04e05d0af386fad7c6365c88092c95a">traverse</a>.  <a href="structlibsemigroups_1_1_ukkonen_1_1_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a105f3a05ac4c26c32e08cfd7b0eba0dc" id="r_a105f3a05ac4c26c32e08cfd7b0eba0dc"><td class="memItemLeft" align="right" valign="top"><a id="a105f3a05ac4c26c32e08cfd7b0eba0dc" name="a105f3a05ac4c26c32e08cfd7b0eba0dc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = typename word_type::const_iterator</td></tr>
<tr class="memdesc:a105f3a05ac4c26c32e08cfd7b0eba0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991" title="Type for a word over the generators of a semigroup.">word_type</a></code> iterators. <br /></td></tr>
<tr class="separator:a105f3a05ac4c26c32e08cfd7b0eba0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d69e986ccdd55cd7237189487b2f25b" id="r_a6d69e986ccdd55cd7237189487b2f25b"><td class="memItemLeft" align="right" valign="top"><a id="a6d69e986ccdd55cd7237189487b2f25b" name="a6d69e986ccdd55cd7237189487b2f25b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>index_type</b> = size_t</td></tr>
<tr class="memdesc:a6d69e986ccdd55cd7237189487b2f25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for an index between <a class="el" href="#a1ca1fc2c9fc3e169d5d0decfd1e54221">begin</a> and <a class="el" href="#a5b9b57293fae9b18b26349ac0b3fdcd3">end</a>. <br /></td></tr>
<tr class="separator:a6d69e986ccdd55cd7237189487b2f25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24b0047b0d8179c405b1c24fb8c0c9d" id="r_ab24b0047b0d8179c405b1c24fb8c0c9d"><td class="memItemLeft" align="right" valign="top"><a id="ab24b0047b0d8179c405b1c24fb8c0c9d" name="ab24b0047b0d8179c405b1c24fb8c0c9d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>unique_letter_type</b> = size_t</td></tr>
<tr class="memdesc:ab24b0047b0d8179c405b1c24fb8c0c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for any letter that is added by <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> (so that unique strings end in unique letters). <br /></td></tr>
<tr class="separator:ab24b0047b0d8179c405b1c24fb8c0c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b1a7b7a52ffa43e92a660d6acd8bda" id="r_a27b1a7b7a52ffa43e92a660d6acd8bda"><td class="memItemLeft" align="right" valign="top"><a id="a27b1a7b7a52ffa43e92a660d6acd8bda" name="a27b1a7b7a52ffa43e92a660d6acd8bda"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>word_index_type</b> = size_t</td></tr>
<tr class="memdesc:a27b1a7b7a52ffa43e92a660d6acd8bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for order that words were added. <br /></td></tr>
<tr class="separator:a27b1a7b7a52ffa43e92a660d6acd8bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acd269c106d56ce97b512686ecdf26141" id="r_acd269c106d56ce97b512686ecdf26141"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd269c106d56ce97b512686ecdf26141">Ukkonen</a> ()</td></tr>
<tr class="memdesc:acd269c106d56ce97b512686ecdf26141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:acd269c106d56ce97b512686ecdf26141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa2ba6550d3c6bbfc1e230096c50064" id="r_a0aa2ba6550d3c6bbfc1e230096c50064"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0aa2ba6550d3c6bbfc1e230096c50064">Ukkonen</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;&amp;)</td></tr>
<tr class="memdesc:a0aa2ba6550d3c6bbfc1e230096c50064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor.  <br /></td></tr>
<tr class="separator:a0aa2ba6550d3c6bbfc1e230096c50064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc38cfe8a39e42c79dc880a07f391b5b" id="r_acc38cfe8a39e42c79dc880a07f391b5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc38cfe8a39e42c79dc880a07f391b5b">Ukkonen</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;)</td></tr>
<tr class="memdesc:acc38cfe8a39e42c79dc880a07f391b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <br /></td></tr>
<tr class="separator:acc38cfe8a39e42c79dc880a07f391b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29364e124fc8ca5b05d670d437fb1a9e" id="r_a29364e124fc8ca5b05d670d437fb1a9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29364e124fc8ca5b05d670d437fb1a9e">add_word</a> (<a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a> first, <a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a> last)</td></tr>
<tr class="memdesc:a29364e124fc8ca5b05d670d437fb1a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check and add a word to the suffix tree.  <br /></td></tr>
<tr class="separator:a29364e124fc8ca5b05d670d437fb1a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b89d9ef7b86c8a2042f9d35877d26b" id="r_a54b89d9ef7b86c8a2042f9d35877d26b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54b89d9ef7b86c8a2042f9d35877d26b">add_word_no_checks</a> (<a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a> first, <a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a> last)</td></tr>
<tr class="memdesc:a54b89d9ef7b86c8a2042f9d35877d26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a word to the suffix tree.  <br /></td></tr>
<tr class="separator:a54b89d9ef7b86c8a2042f9d35877d26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca1fc2c9fc3e169d5d0decfd1e54221" id="r_a1ca1fc2c9fc3e169d5d0decfd1e54221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ca1fc2c9fc3e169d5d0decfd1e54221">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a1ca1fc2c9fc3e169d5d0decfd1e54221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first letter of the first word in the suffix tree.  <br /></td></tr>
<tr class="separator:a1ca1fc2c9fc3e169d5d0decfd1e54221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb76f7f3414f270020e6f467586bd93" id="r_abeb76f7f3414f270020e6f467586bd93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abeb76f7f3414f270020e6f467586bd93">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:abeb76f7f3414f270020e6f467586bd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first letter of the first word in the suffix tree.  <br /></td></tr>
<tr class="separator:abeb76f7f3414f270020e6f467586bd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9859a454bb6f50c654e280274d6a9d13" id="r_a9859a454bb6f50c654e280274d6a9d13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9859a454bb6f50c654e280274d6a9d13">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a9859a454bb6f50c654e280274d6a9d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing one past the last letter of the last word in the suffix tree.  <br /></td></tr>
<tr class="separator:a9859a454bb6f50c654e280274d6a9d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448b8d29b8ecf0798579b310859b864d" id="r_a448b8d29b8ecf0798579b310859b864d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a448b8d29b8ecf0798579b310859b864d">distance_from_root</a> (<a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_node.html">Node</a> const &amp;n) const</td></tr>
<tr class="memdesc:a448b8d29b8ecf0798579b310859b864d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance of a node from the root.  <br /></td></tr>
<tr class="separator:a448b8d29b8ecf0798579b310859b864d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9b57293fae9b18b26349ac0b3fdcd3" id="r_a5b9b57293fae9b18b26349ac0b3fdcd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b9b57293fae9b18b26349ac0b3fdcd3">end</a> () const noexcept</td></tr>
<tr class="memdesc:a5b9b57293fae9b18b26349ac0b3fdcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing one past the last letter of the last word in the suffix tree.  <br /></td></tr>
<tr class="separator:a5b9b57293fae9b18b26349ac0b3fdcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7256d1fc5f29d277662b15aa85440d1" id="r_aa7256d1fc5f29d277662b15aa85440d1"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:aa7256d1fc5f29d277662b15aa85440d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa7256d1fc5f29d277662b15aa85440d1">index</a> (Iterator first, Iterator last) const</td></tr>
<tr class="memdesc:aa7256d1fc5f29d277662b15aa85440d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of a word in the suffix tree.     <br /></td></tr>
<tr class="separator:aa7256d1fc5f29d277662b15aa85440d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6abdc8bbc1af840cb2266bf7995f85" id="r_a5b6abdc8bbc1af840cb2266bf7995f85"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a5b6abdc8bbc1af840cb2266bf7995f85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5b6abdc8bbc1af840cb2266bf7995f85">index_no_checks</a> (Iterator first, Iterator last) const</td></tr>
<tr class="memdesc:a5b6abdc8bbc1af840cb2266bf7995f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of a word in the suffix tree.  <br /></td></tr>
<tr class="separator:a5b6abdc8bbc1af840cb2266bf7995f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550351479d49f767618e1e8cdec8f5f9" id="r_a550351479d49f767618e1e8cdec8f5f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a550351479d49f767618e1e8cdec8f5f9">init</a> ()</td></tr>
<tr class="memdesc:a550351479d49f767618e1e8cdec8f5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an existing <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object.  <br /></td></tr>
<tr class="separator:a550351479d49f767618e1e8cdec8f5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c039a61194d4928ac82029ac557f7a7" id="r_a9c039a61194d4928ac82029ac557f7a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c039a61194d4928ac82029ac557f7a7">is_suffix</a> (<a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">State</a> const &amp;st) const</td></tr>
<tr class="memdesc:a9c039a61194d4928ac82029ac557f7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a state corresponds to a suffix.  <br /></td></tr>
<tr class="separator:a9c039a61194d4928ac82029ac557f7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af779992845d1abd42b991b94a1452cbf" id="r_af779992845d1abd42b991b94a1452cbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af779992845d1abd42b991b94a1452cbf">is_unique_letter</a> (<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">letter_type</a> l) const noexcept</td></tr>
<tr class="memdesc:af779992845d1abd42b991b94a1452cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a letter is a unique letter added to the end of a word in the suffix tree.  <br /></td></tr>
<tr class="separator:af779992845d1abd42b991b94a1452cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c948360b7cda900faf1177bb9cc9fe" id="r_a97c948360b7cda900faf1177bb9cc9fe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97c948360b7cda900faf1177bb9cc9fe">length_of_distinct_words</a> () const noexcept</td></tr>
<tr class="memdesc:a97c948360b7cda900faf1177bb9cc9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the lengths of the distinct words in the suffix tree.  <br /></td></tr>
<tr class="separator:a97c948360b7cda900faf1177bb9cc9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254381e6707c41b570a3faedb25ad588" id="r_a254381e6707c41b570a3faedb25ad588"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a254381e6707c41b570a3faedb25ad588">length_of_words</a> () const noexcept</td></tr>
<tr class="memdesc:a254381e6707c41b570a3faedb25ad588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the lengths of all of the words in the suffix tree.  <br /></td></tr>
<tr class="separator:a254381e6707c41b570a3faedb25ad588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dedccf68d1ba59b5609949478a1ac9a" id="r_a6dedccf68d1ba59b5609949478a1ac9a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dedccf68d1ba59b5609949478a1ac9a">max_word_length</a> () const noexcept</td></tr>
<tr class="memdesc:a6dedccf68d1ba59b5609949478a1ac9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum length of word in the suffix tree.  <br /></td></tr>
<tr class="separator:a6dedccf68d1ba59b5609949478a1ac9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f5263d6025e25ea81c3452fe48447b" id="r_ad7f5263d6025e25ea81c3452fe48447b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7f5263d6025e25ea81c3452fe48447b">multiplicity</a> (<a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a> i) const</td></tr>
<tr class="memdesc:ad7f5263d6025e25ea81c3452fe48447b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicity of a word by index.  <br /></td></tr>
<tr class="separator:ad7f5263d6025e25ea81c3452fe48447b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf1b8f1c54bcc0dbc55bc24e0c516d8" id="r_a7bf1b8f1c54bcc0dbc55bc24e0c516d8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bf1b8f1c54bcc0dbc55bc24e0c516d8">multiplicity_no_checks</a> (<a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a> i) const</td></tr>
<tr class="memdesc:a7bf1b8f1c54bcc0dbc55bc24e0c516d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicity of a word by index.  <br /></td></tr>
<tr class="separator:a7bf1b8f1c54bcc0dbc55bc24e0c516d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4257e7f3de6ba8ded16d30705b040d78" id="r_a4257e7f3de6ba8ded16d30705b040d78"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_node.html">Node</a> &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4257e7f3de6ba8ded16d30705b040d78">nodes</a> () const noexcept</td></tr>
<tr class="memdesc:a4257e7f3de6ba8ded16d30705b040d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nodes in the suffix tree.  <br /></td></tr>
<tr class="separator:a4257e7f3de6ba8ded16d30705b040d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe24daef29264ebe51a60285f1eeda7b" id="r_afe24daef29264ebe51a60285f1eeda7b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe24daef29264ebe51a60285f1eeda7b">number_of_distinct_words</a> () const noexcept</td></tr>
<tr class="memdesc:afe24daef29264ebe51a60285f1eeda7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of distinct non-empty words in the suffix tree.  <br /></td></tr>
<tr class="separator:afe24daef29264ebe51a60285f1eeda7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48ee14b92c3ce2be5ef19c92f1f47b1" id="r_aa48ee14b92c3ce2be5ef19c92f1f47b1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa48ee14b92c3ce2be5ef19c92f1f47b1">number_of_words</a> () const noexcept</td></tr>
<tr class="memdesc:aa48ee14b92c3ce2be5ef19c92f1f47b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-empty words in the suffix tree.  <br /></td></tr>
<tr class="separator:aa48ee14b92c3ce2be5ef19c92f1f47b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174a5830397b8929cad0bc2850c0f6f2" id="r_a174a5830397b8929cad0bc2850c0f6f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a174a5830397b8929cad0bc2850c0f6f2">operator=</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;&amp;)</td></tr>
<tr class="memdesc:a174a5830397b8929cad0bc2850c0f6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move assignment.  <br /></td></tr>
<tr class="separator:a174a5830397b8929cad0bc2850c0f6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873441f09ca09816b94024541324cc3c" id="r_a873441f09ca09816b94024541324cc3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a873441f09ca09816b94024541324cc3c">operator=</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;)</td></tr>
<tr class="memdesc:a873441f09ca09816b94024541324cc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment.  <br /></td></tr>
<tr class="separator:a873441f09ca09816b94024541324cc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4c81a754be35e62b7055474756f517" id="r_a1d4c81a754be35e62b7055474756f517"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a1d4c81a754be35e62b7055474756f517"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a> (Iterator first, Iterator last) const</td></tr>
<tr class="memdesc:a1d4c81a754be35e62b7055474756f517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw if the word <code>[first, last)</code> contains a letter equal to any of the unique letters added to the end of words in the suffix tree.  <br /></td></tr>
<tr class="separator:a1d4c81a754be35e62b7055474756f517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9701b1266db554fda32ca3a1211b3612" id="r_a9701b1266db554fda32ca3a1211b3612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9701b1266db554fda32ca3a1211b3612">throw_if_contains_unique_letter</a> (<a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w) const</td></tr>
<tr class="memdesc:a9701b1266db554fda32ca3a1211b3612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw if <code class="param">w</code> contains a letter equal to any of the unique letters added to the end of words in the suffix tree.  <br /></td></tr>
<tr class="separator:a9701b1266db554fda32ca3a1211b3612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3240eeea89e1a54293207dcc29c419" id="r_ada3240eeea89e1a54293207dcc29c419"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:ada3240eeea89e1a54293207dcc29c419"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">State</a>, Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada3240eeea89e1a54293207dcc29c419">traverse</a> (Iterator first, Iterator last) const</td></tr>
<tr class="memdesc:ada3240eeea89e1a54293207dcc29c419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.     <br /></td></tr>
<tr class="separator:ada3240eeea89e1a54293207dcc29c419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04e05d0af386fad7c6365c88092c95a" id="r_ad04e05d0af386fad7c6365c88092c95a"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:ad04e05d0af386fad7c6365c88092c95a"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad04e05d0af386fad7c6365c88092c95a">traverse</a> (<a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">State</a> &amp;st, Iterator first, Iterator last) const</td></tr>
<tr class="memdesc:ad04e05d0af386fad7c6365c88092c95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.     <br /></td></tr>
<tr class="separator:ad04e05d0af386fad7c6365c88092c95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3646f96b954d1496bdca1e7c2ea10d7d" id="r_a3646f96b954d1496bdca1e7c2ea10d7d"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a3646f96b954d1496bdca1e7c2ea10d7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">State</a>, Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3646f96b954d1496bdca1e7c2ea10d7d">traverse_no_checks</a> (Iterator first, Iterator last) const</td></tr>
<tr class="memdesc:a3646f96b954d1496bdca1e7c2ea10d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.  <br /></td></tr>
<tr class="separator:a3646f96b954d1496bdca1e7c2ea10d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07982678a78153dd1de0d15f0479321f" id="r_a07982678a78153dd1de0d15f0479321f"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a07982678a78153dd1de0d15f0479321f"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07982678a78153dd1de0d15f0479321f">traverse_no_checks</a> (<a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">State</a> &amp;st, Iterator first, Iterator last) const</td></tr>
<tr class="memdesc:a07982678a78153dd1de0d15f0479321f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.  <br /></td></tr>
<tr class="separator:a07982678a78153dd1de0d15f0479321f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5608f06860f093613b0728efe211c9e" id="r_ae5608f06860f093613b0728efe211c9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab24b0047b0d8179c405b1c24fb8c0c9d">unique_letter_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5608f06860f093613b0728efe211c9e">unique_letter</a> (<a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a> i) const noexcept</td></tr>
<tr class="memdesc:ae5608f06860f093613b0728efe211c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique letter added to the end of a word in the suffix tree.  <br /></td></tr>
<tr class="separator:ae5608f06860f093613b0728efe211c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b0572116c8ed62586096c209e26727" id="r_a16b0572116c8ed62586096c209e26727"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16b0572116c8ed62586096c209e26727">word_index</a> (<a class="el" href="#a6d69e986ccdd55cd7237189487b2f25b">index_type</a> i) const</td></tr>
<tr class="memdesc:a16b0572116c8ed62586096c209e26727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the word corresponding to a position.  <br /></td></tr>
<tr class="separator:a16b0572116c8ed62586096c209e26727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fd394abec135feefe9a493dd5a5d21" id="r_aa1fd394abec135feefe9a493dd5a5d21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1fd394abec135feefe9a493dd5a5d21">word_index</a> (<a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_node.html">Node</a> const &amp;n) const</td></tr>
<tr class="memdesc:aa1fd394abec135feefe9a493dd5a5d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the word corresponding to a node.  <br /></td></tr>
<tr class="separator:aa1fd394abec135feefe9a493dd5a5d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3e80c4a50e9c972161ea53cb671bc9" id="r_a7b3e80c4a50e9c972161ea53cb671bc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b3e80c4a50e9c972161ea53cb671bc9">word_index_no_checks</a> (<a class="el" href="#a6d69e986ccdd55cd7237189487b2f25b">index_type</a> i) const</td></tr>
<tr class="memdesc:a7b3e80c4a50e9c972161ea53cb671bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the word corresponding to a position.  <br /></td></tr>
<tr class="separator:a7b3e80c4a50e9c972161ea53cb671bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498e5d37c1bedc46d9b6380b250959b7" id="r_a498e5d37c1bedc46d9b6380b250959b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a498e5d37c1bedc46d9b6380b250959b7">word_index_no_checks</a> (<a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_node.html">Node</a> const &amp;n) const</td></tr>
<tr class="memdesc:a498e5d37c1bedc46d9b6380b250959b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the word corresponding to a node.  <br /></td></tr>
<tr class="separator:a498e5d37c1bedc46d9b6380b250959b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acd269c106d56ce97b512686ecdf26141" name="acd269c106d56ce97b512686ecdf26141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd269c106d56ce97b512686ecdf26141">&#9670;&#160;</a></span>Ukkonen() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an empty generalised suffix tree.</p>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="acc38cfe8a39e42c79dc880a07f391b5b" name="acc38cfe8a39e42c79dc880a07f391b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc38cfe8a39e42c79dc880a07f391b5b">&#9670;&#160;</a></span>Ukkonen() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default copy constructor. </p>

</div>
</div>
<a id="a0aa2ba6550d3c6bbfc1e230096c50064" name="a0aa2ba6550d3c6bbfc1e230096c50064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa2ba6550d3c6bbfc1e230096c50064">&#9670;&#160;</a></span>Ukkonen() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default move constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a29364e124fc8ca5b05d670d437fb1a9e" name="a29364e124fc8ca5b05d670d437fb1a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29364e124fc8ca5b05d670d437fb1a9e">&#9670;&#160;</a></span>add_word()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void add_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function does the same as <a class="el" href="#a54b89d9ef7b86c8a2042f9d35877d26b">add_word_no_checks(const_iterator,
const_iterator)</a> after first checking that none of the letters in the word corresponding to <code class="param">first</code> and <code class="param">last</code> is equal to any of the existing unique letters.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>throw_if_contains_unique_letter(first, last)</code> throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54b89d9ef7b86c8a2042f9d35877d26b" name="a54b89d9ef7b86c8a2042f9d35877d26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b89d9ef7b86c8a2042f9d35877d26b">&#9670;&#160;</a></span>add_word_no_checks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_word_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calling this function immediately invokes <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a>'s algorithm to add the given word to the suffix tree (if it is not already contained in the tree). If an identical word is already in the tree, then this function does nothing except increase the multiplicity of that word. If <code>first == last</code>, then this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word to add. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the distance between <code>first</code> and <code>last</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the suffix tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="a1ca1fc2c9fc3e169d5d0decfd1e54221" name="a1ca1fc2c9fc3e169d5d0decfd1e54221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca1fc2c9fc3e169d5d0decfd1e54221">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a> begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the first letter of the first word in the suffix tree.</p>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc" title="Alias for word_type iterators.">const_iterator</a></code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function is <code>noexcept</code> and is guaranteed never to throw.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="abeb76f7f3414f270020e6f467586bd93" name="abeb76f7f3414f270020e6f467586bd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb76f7f3414f270020e6f467586bd93">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a> cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the first letter of the first word in the suffix tree.</p>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc" title="Alias for word_type iterators.">const_iterator</a></code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function is <code>noexcept</code> and is guaranteed never to throw.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a9859a454bb6f50c654e280274d6a9d13" name="a9859a454bb6f50c654e280274d6a9d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9859a454bb6f50c654e280274d6a9d13">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a> cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing one past the last letter of the last word in the suffix tree.</p>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc" title="Alias for word_type iterators.">const_iterator</a></code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function is <code>noexcept</code> and is guaranteed never to throw.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a448b8d29b8ecf0798579b310859b864d" name="a448b8d29b8ecf0798579b310859b864d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448b8d29b8ecf0798579b310859b864d">&#9670;&#160;</a></span>distance_from_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t distance_from_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_node.html">Node</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the distance of a node from the root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>size_t</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>At worst linear in the distance of the node <code class="param">n</code> from the root. </dd></dl>

</div>
</div>
<a id="a5b9b57293fae9b18b26349ac0b3fdcd3" name="a5b9b57293fae9b18b26349ac0b3fdcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9b57293fae9b18b26349ac0b3fdcd3">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc">const_iterator</a> end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing one past the last letter of the last word in the suffix tree.</p>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="el" href="#a105f3a05ac4c26c32e08cfd7b0eba0dc" title="Alias for word_type iterators.">const_iterator</a></code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function is <code>noexcept</code> and is guaranteed never to throw.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="aa7256d1fc5f29d277662b15aa85440d1" name="aa7256d1fc5f29d277662b15aa85440d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7256d1fc5f29d277662b15aa85440d1">&#9670;&#160;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a> index </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a5b6abdc8bbc1af840cb2266bf7995f85">index_no_checks</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>throw_if_contains_unique_letter(first, last)</code> throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b6abdc8bbc1af840cb2266bf7995f85" name="a5b6abdc8bbc1af840cb2266bf7995f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6abdc8bbc1af840cb2266bf7995f85">&#9670;&#160;</a></span>index_no_checks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a> index_no_checks </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the word corresponding to <code class="param">first</code> and <code class="param">last</code> is one of the words that the suffix tree contains (the words added to the suffix tree via <code>add_word</code> or <code>add_word_no_checks</code>), then this function returns the index of that word. If the word corresponding to <code class="param">first</code> and <code class="param">last</code> is not one of the words that the suffix tree represents, then <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a> is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word to check. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda" title="Alias for order that words were added.">word_index_type</a></code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the distance from <code class="param">first</code> to <code class="param">last</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the <code>value_type</code> of <code class="param">Iterator</code> is a signed integer, then this is converted to an unsigned integer using <a class="elRef" href="http://en.cppreference.com/w/cpp/types/make_signed.html">std::make_signed</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="a550351479d49f767618e1e8cdec8f5f9" name="a550351479d49f767618e1e8cdec8f5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550351479d49f767618e1e8cdec8f5f9">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp; init </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function puts an <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object back into the same state as if it had been newly default constructed.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#acd269c106d56ce97b512686ecdf26141">Ukkonen()</a> </dd></dl>

</div>
</div>
<a id="a9c039a61194d4928ac82029ac557f7a7" name="a9c039a61194d4928ac82029ac557f7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c039a61194d4928ac82029ac557f7a7">&#9670;&#160;</a></span>is_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a> is_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">State</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>st</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a <code><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda" title="Alias for order that words were added.">word_index_type</a></code> if the state <code class="param">st</code> corresponds to a suffix of any word in the suffix tree. The value returned is the index of the word which the state is a suffix of.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>the state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda" title="Alias for order that words were added.">word_index_type</a></code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="af779992845d1abd42b991b94a1452cbf" name="af779992845d1abd42b991b94a1452cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af779992845d1abd42b991b94a1452cbf">&#9670;&#160;</a></span>is_unique_letter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_unique_letter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">letter_type</a></td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <code class="param">l</code> is one of the unique letters added to the end of a word in the suffix tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>the <a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1" title="Type for the index of a generator of a semigroup.">letter_type</a> to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function is <code>noexcept</code> and is guaranteed never to throw.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a97c948360b7cda900faf1177bb9cc9fe" name="a97c948360b7cda900faf1177bb9cc9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c948360b7cda900faf1177bb9cc9fe">&#9670;&#160;</a></span>length_of_distinct_words()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t length_of_distinct_words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the sum of the lengths of the distinct words in the suffix tree.</p>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>size_t</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function is <code>noexcept</code> and is guaranteed never to throw.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a254381e6707c41b570a3faedb25ad588" name="a254381e6707c41b570a3faedb25ad588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254381e6707c41b570a3faedb25ad588">&#9670;&#160;</a></span>length_of_words()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t length_of_words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the sum of the lengths of all of the words in the suffix tree. This is the total length of all the words added to the suffix tree including duplicates, if any.</p>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>size_t</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function is <code>noexcept</code> and is guaranteed never to throw.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>\(O(n)\) where \(n\) is the return value of <a class="el" href="#afe24daef29264ebe51a60285f1eeda7b">number_of_distinct_words</a>. </dd></dl>

</div>
</div>
<a id="a6dedccf68d1ba59b5609949478a1ac9a" name="a6dedccf68d1ba59b5609949478a1ac9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dedccf68d1ba59b5609949478a1ac9a">&#9670;&#160;</a></span>max_word_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t max_word_length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum length of word in the suffix tree.</p>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>size_t</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function is <code>noexcept</code> and is guaranteed never to throw.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="ad7f5263d6025e25ea81c3452fe48447b" name="ad7f5263d6025e25ea81c3452fe48447b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f5263d6025e25ea81c3452fe48447b">&#9670;&#160;</a></span>multiplicity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t multiplicity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the number of times that the word corresponding to the index <code class="param">i</code> was added to the suffix tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>size_t</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a7bf1b8f1c54bcc0dbc55bc24e0c516d8" name="a7bf1b8f1c54bcc0dbc55bc24e0c516d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf1b8f1c54bcc0dbc55bc24e0c516d8">&#9670;&#160;</a></span>multiplicity_no_checks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t multiplicity_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the number of times that the word corresponding to the index <code class="param">i</code> was added to the suffix tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>size_t</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a4257e7f3de6ba8ded16d30705b040d78" name="a4257e7f3de6ba8ded16d30705b040d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4257e7f3de6ba8ded16d30705b040d78">&#9670;&#160;</a></span>nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_node.html">Node</a> &gt; const  &amp; nodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the nodes in the suffix tree.</p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;Node&gt;</a> of <code><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_node.html" title="The type of the nodes in the tree.">Ukkonen::Node</a></code> objects.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function is <code>noexcept</code> and is guaranteed never to throw.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="afe24daef29264ebe51a60285f1eeda7b" name="afe24daef29264ebe51a60285f1eeda7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe24daef29264ebe51a60285f1eeda7b">&#9670;&#160;</a></span>number_of_distinct_words()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t number_of_distinct_words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of distinct non-empty words in the suffix tree. This is the number of distinct non-empty words added via <a class="el" href="#a29364e124fc8ca5b05d670d437fb1a9e">add_word</a> or <a class="el" href="#a54b89d9ef7b86c8a2042f9d35877d26b">add_word_no_checks</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>size_t</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function is <code>noexcept</code> and is guaranteed never to throw.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="aa48ee14b92c3ce2be5ef19c92f1f47b1" name="aa48ee14b92c3ce2be5ef19c92f1f47b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48ee14b92c3ce2be5ef19c92f1f47b1">&#9670;&#160;</a></span>number_of_words()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t number_of_words </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of non-empty words in the suffix tree. This is the number of all words added via <a class="el" href="#a29364e124fc8ca5b05d670d437fb1a9e">add_word</a> or <a class="el" href="#a54b89d9ef7b86c8a2042f9d35877d26b">add_word_no_checks</a> including duplicates, if any.</p>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>size_t</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function is <code>noexcept</code> and is guaranteed never to throw.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>\(O(n)\) where \(n\) is the return value of <a class="el" href="#afe24daef29264ebe51a60285f1eeda7b">number_of_distinct_words</a>. </dd></dl>

</div>
</div>
<a id="a174a5830397b8929cad0bc2850c0f6f2" name="a174a5830397b8929cad0bc2850c0f6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174a5830397b8929cad0bc2850c0f6f2">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default move assignment. </p>

</div>
</div>
<a id="a873441f09ca09816b94024541324cc3c" name="a873441f09ca09816b94024541324cc3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873441f09ca09816b94024541324cc3c">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default copy assignment. </p>

</div>
</div>
<a id="a1d4c81a754be35e62b7055474756f517" name="a1d4c81a754be35e62b7055474756f517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4c81a754be35e62b7055474756f517">&#9670;&#160;</a></span>throw_if_contains_unique_letter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throw_if_contains_unique_letter </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function throws an exception if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains a letter equal to any of the unique letters added to the end of words in the suffix tree.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>is_unique_letter(*it)</code> returns <code>true</code> for any <code>it</code> in <code>[first, last)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the distance from <code class="param">first</code> to <code class="param">last</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the <code>value_type</code> of <code class="param">Iterator</code> is a signed integer, then this is converted to an unsigned integer using <a class="elRef" href="http://en.cppreference.com/w/cpp/types/make_signed.html">std::make_signed</a>. </dd></dl>

</div>
</div>
<a id="a9701b1266db554fda32ca3a1211b3612" name="a9701b1266db554fda32ca3a1211b3612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9701b1266db554fda32ca3a1211b3612">&#9670;&#160;</a></span>throw_if_contains_unique_letter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void throw_if_contains_unique_letter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </p>

</div>
</div>
<a id="ada3240eeea89e1a54293207dcc29c419" name="ada3240eeea89e1a54293207dcc29c419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3240eeea89e1a54293207dcc29c419">&#9670;&#160;</a></span>traverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">State</a>, Iterator &gt; traverse </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a3646f96b954d1496bdca1e7c2ea10d7d">traverse_no_checks(Iterator, Iterator) const</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>throw_if_contains_unique_letter(first, last)</code> throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad04e05d0af386fad7c6365c88092c95a" name="ad04e05d0af386fad7c6365c88092c95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04e05d0af386fad7c6365c88092c95a">&#9670;&#160;</a></span>traverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>st</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a07982678a78153dd1de0d15f0479321f">traverse_no_checks(State&amp;, Iterator, Iterator) const</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>throw_if_contains_unique_letter(first, last)</code> throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3646f96b954d1496bdca1e7c2ea10d7d" name="a3646f96b954d1496bdca1e7c2ea10d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3646f96b954d1496bdca1e7c2ea10d7d">&#9670;&#160;</a></span>traverse_no_checks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">State</a>, Iterator &gt; traverse_no_checks </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function traverses the edges in the suffix tree, starting at the root node, that are labelled by the letters in the word corresponding to <code class="param">first</code> and <code class="param">last</code>. The suffix tree is traversed until the end of the word is reached, or a letter not corresponding to an edge is encountered. A pair consisting of the state reached, and one past the last letter consumed in the traversal is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html" title="The return type of traverse.">State</a>, Iterator&gt;</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the distance from <code class="param">first</code> to <code class="param">last</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the <code>value_type</code> of <code class="param">Iterator</code> is a signed integer, then this is converted to an unsigned integer using <a class="elRef" href="http://en.cppreference.com/w/cpp/types/make_signed.html">std::make_signed</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="a07982678a78153dd1de0d15f0479321f" name="a07982678a78153dd1de0d15f0479321f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07982678a78153dd1de0d15f0479321f">&#9670;&#160;</a></span>traverse_no_checks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator traverse_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>st</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function traverses the edges in the suffix tree, starting at the state <code class="param">st</code>, that are labelled by the letters in the word corresponding to <code class="param">first</code> and <code class="param">last</code>. The suffix tree is traversed until the end of the word is reached, or a letter not corresponding to an edge is encountered. The state <code class="param">st</code> is modified in-place to contain the last state in the tree reached in the traversal. The returned iterator points one past the last letter consumed in the traversal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the 2nd and 3rd arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>the initial state. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Iterator</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the distance from <code class="param">first</code> to <code class="param">last</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the <code>value_type</code> of <code class="param">Iterator</code> is a signed integer, then this is converted to an unsigned integer using <a class="elRef" href="http://en.cppreference.com/w/cpp/types/make_signed.html">std::make_signed</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="ae5608f06860f093613b0728efe211c9e" name="ae5608f06860f093613b0728efe211c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5608f06860f093613b0728efe211c9e">&#9670;&#160;</a></span>unique_letter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab24b0047b0d8179c405b1c24fb8c0c9d">unique_letter_type</a> unique_letter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the unique letter added to the end of the <code class="param">i-th</code> distinct word added to the suffix tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index of an added word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="el" href="#ab24b0047b0d8179c405b1c24fb8c0c9d" title="Alias for any letter that is added by Ukkonen (so that unique strings end in unique letters).">unique_letter_type</a></code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function is <code>noexcept</code> and is guaranteed never to throw.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a16b0572116c8ed62586096c209e26727" name="a16b0572116c8ed62586096c209e26727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b0572116c8ed62586096c209e26727">&#9670;&#160;</a></span>word_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a> word_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6d69e986ccdd55cd7237189487b2f25b">index_type</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the least non-negative integer <code>j</code> such that the <code><a class="el" href="#a1ca1fc2c9fc3e169d5d0decfd1e54221" title="Returns an iterator pointing to the first letter of the first word in the suffix tree.">Ukkonen::begin()</a> + i</code> points to a character in the <code>j</code>-th word added to the suffix tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda" title="Alias for order that words were added.">word_index_type</a></code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">i</code> is greater than <code><a class="el" href="#a97c948360b7cda900faf1177bb9cc9fe" title="Returns the sum of the lengths of the distinct words in the suffix tree.">length_of_distinct_words()</a> + <a class="el" href="#afe24daef29264ebe51a60285f1eeda7b" title="Returns the number of distinct non-empty words in the suffix tree.">number_of_distinct_words()</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="aa1fd394abec135feefe9a493dd5a5d21" name="aa1fd394abec135feefe9a493dd5a5d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fd394abec135feefe9a493dd5a5d21">&#9670;&#160;</a></span>word_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a> word_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_node.html">Node</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the least non-negative integer <code>i</code> such that the node <code class="param">n</code> corresponds to the <code>i</code>-th word added to the suffix tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda" title="Alias for order that words were added.">word_index_type</a></code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>n.parent == UNDEFINED</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a7b3e80c4a50e9c972161ea53cb671bc9" name="a7b3e80c4a50e9c972161ea53cb671bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3e80c4a50e9c972161ea53cb671bc9">&#9670;&#160;</a></span>word_index_no_checks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a> word_index_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6d69e986ccdd55cd7237189487b2f25b">index_type</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the least non-negative integer <code>j</code> such that the <code><a class="el" href="#a1ca1fc2c9fc3e169d5d0decfd1e54221" title="Returns an iterator pointing to the first letter of the first word in the suffix tree.">Ukkonen::begin()</a> + i</code> points to a character in the <code>j</code>-th word added to the suffix tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda" title="Alias for order that words were added.">word_index_type</a></code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if <code class="param">i</code> is greater than <a class="el" href="#a254381e6707c41b570a3faedb25ad588">length_of_words</a> + <a class="el" href="#afe24daef29264ebe51a60285f1eeda7b">number_of_distinct_words</a>, then bad things will happen. </dd></dl>

</div>
</div>
<a id="a498e5d37c1bedc46d9b6380b250959b7" name="a498e5d37c1bedc46d9b6380b250959b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498e5d37c1bedc46d9b6380b250959b7">&#9670;&#160;</a></span>word_index_no_checks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda">word_index_type</a> word_index_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_node.html">Node</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the least non-negative integer <code>i</code> such that the node <code class="param">n</code> corresponds to the <code>i</code>-th word added to the suffix tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="el" href="#a27b1a7b7a52ffa43e92a660d6acd8bda" title="Alias for order that words were added.">word_index_type</a></code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if <code>n.parent == UNDEFINED</code> then bad things will happen. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/jdm3/libsemigroups/include/libsemigroups/<a class="el" href="ukkonen_8hpp_source.html">ukkonen.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelibsemigroups.html">libsemigroups</a></li><li class="navelem"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
