<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- BEGIN opengraph metadata -->
    <meta property="og:title" content="libsemigroups" />
    <meta property="og:image" content="libsemi_logo.jpeg" />
    <meta
      property="og:description"
      content="C++ library for semigroups and monoids."
    />
    <meta
      property="og:url"
      content="https://github.com/libsemigroups/libsemigroups"
    />
    <!-- END opengraph metadata -->
<title>libsemigroups: IsObviouslyInfinite</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="libsemi_logo.jpeg"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/libsemigroups/libsemigroups" class="github-corner" title="View source on GitHub" target="_blank" rel="noopener noreferrer">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libsemi_logo.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsemigroups
   &#160;<span id="projectnumber">v3.0.0</span>
   </div>
   <div id="projectbrief">C++ library for semigroups and monoids</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="_HEADING_"><span>Installation&#160;and&#160;Changelog</span></a></li>
      <li><a href="md_install.html"><span>Install</span></a></li>
      <li><a href="md_changelog-v3.html"><span>changelog&#160;-&#160;version&#160;3</span></a></li>
      <li><a href="md_changelog-v2.html"><span>changelog&#160;-&#160;version&#160;2</span></a></li>
      <li><a href="md_changelog-v1.html"><span>changelog&#160;-&#160;version&#160;1</span></a></li>
      <li><a href="_HEADING_"><span>Data&#160;structures</span></a></li>
      <li><a href="group__adapters__group.html"><span>Adapters</span></a></li>
      <li><a href="group__elements__group.html"><span>Elements</span></a></li>
      <li><a href="group__misc__group.html"><span>Miscellaneous</span></a></li>
      <li><a href="group__orders__group.html"><span>Orders</span></a></li>
      <li><a href="group__presentations__group.html"><span>Presentations</span></a></li>
      <li><a href="group__ranges__group.html"><span>Ranges</span></a></li>
      <li><a href="group__ukkonen__group.html"><span>Suffix&#160;trees</span></a></li>
      <li><a href="group__aho__corasick__group.html"><span>Tries</span></a></li>
      <li><a href="group__make__group.html"><span>The&#160;`make`&#160;function</span></a></li>
      <li><a href="group__to__group.html"><span>The&#160;`to`&#160;function</span></a></li>
      <li><a href="group__dot__group.html"><span>Visualisation</span></a></li>
      <li><a href="group__word__graph__group.html"><span>Word&#160;graphs</span></a></li>
      <li><a href="group__words__group.html"><span>Words</span></a></li>
      <li><a href="_HEADING_"><span>Main&#160;Algorithms</span></a></li>
      <li><a href="group__action__group.html"><span>Actions</span></a></li>
      <li><a href="group__cong__common__helpers__group.html"><span>Common&#160;congruence&#160;helper&#160;function</span></a></li>
      <li><a href="group__congruence__group.html"><span>Congruence</span></a></li>
      <li><a href="group__froidure__pin__group.html"><span>Froidure-Pin</span></a></li>
      <li><a href="group__kambites__group.html"><span>Kambites</span></a></li>
      <li><a href="group__knuth__bendix__group.html"><span>Knuth-Bendix</span></a></li>
      <li><a href="group__konieczny__group.html"><span>Konieczny</span></a></li>
      <li><a href="group__sims__group.html"><span>Low&#160;Index&#160;Congruences</span></a></li>
      <li><a href="group__freeband__group.html"><span>Radoszewski-Rytter</span></a></li>
      <li><a href="group__schreier__sims__group.html"><span>Schreier-Sims</span></a></li>
      <li><a href="group__stephen__group.html"><span>Stephen</span></a></li>
      <li><a href="group__todd__coxeter__group.html"><span>Todd-Coxeter</span></a></li>
      <li><a href="_HEADING_"><span>Bibliography</span></a></li>
      <li><a href="citelist.html"><span>Bibliography</span></a></li>
      <li><a href="_HEADING_"><span>Further&#160;info</span></a></li>
      <li><a href="https://github.com/libsemigroups/libsemigroups"><span>GitHub</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classlibsemigroups_1_1_is_obviously_infinite.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlibsemigroups_1_1_is_obviously_infinite-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">IsObviouslyInfinite<div class="ingroups"><a class="el" href="group__misc__group.html">Miscellaneous</a> &raquo; <a class="el" href="group__obvinf__group.html">Obviously infinite</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a>
<div class="textblock"><p>This class implements a number of checks whether or not a finitely presented semigroup or monoid is infinite. These checks are all decidable, and always return an answer within an amount of time that is linear in the size of the input.</p>
<p>These checks are:</p>
<ol type="1">
<li>For every generator there is at least one side of one relation that consists solely of that generator. If this condition is not met, then there is a generator of infinite order.</li>
<li>The number of occurrences of every generator is not preserved by the relations. Otherwise, it is not possible to use the relations to reduce the number of occurrences of a generator in a word, and so there are infinitely many distinct words.</li>
<li>The number of generators on the left hand side of a relation is not the same as the number of generators on the right hand side for at least one generator. Otherwise the relations preserve the length of any word and so there are infinitely many distinct words.</li>
<li>There are at least as many relations as there are generators. Otherwise we can find a surjective homomorphism onto an infinite subsemigroup of the rationals under addition.</li>
<li>The checks 2., 3. and 4. are a special case of a more general matrix based condition. We construct a matrix whose columns correspond to generators and rows correspond to relations. The (i, j)-th entry is the number of occurrences of the j-th generator in the left hand side of the i-th relation minus the number of occurrences of it on the right hand side. If this matrix has a non-trivial kernel, then we can construct a surjective homomorphism onto an infinite subsemigroup of the rationals under addition. So we check that the matrix is full rank.</li>
<li>The presentation is not that of a free product. To do this we consider a graph whose vertices are generators and an edge connects two generators if they occur on either side of the same relation. If this graph is disconnected then the presentation is a free product and is therefore infinite. Note that we currently do not consider the case where the identity occurs in the presentation.</li>
</ol>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__obvinf__group.html#gad2114ce6b9a5c58fb69842a91704c034">is_obviously_infinite</a>. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0b87c81bc8d329502f37a7298a9f00cd" id="r_a0b87c81bc8d329502f37a7298a9f00cd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b87c81bc8d329502f37a7298a9f00cd">const_iterator_pair_string</a></td></tr>
<tr class="memdesc:a0b87c81bc8d329502f37a7298a9f00cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt;&gt;::const_iterator</code>.  <br /></td></tr>
<tr class="separator:a0b87c81bc8d329502f37a7298a9f00cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac527d9d4a5abcc7940a1bb5b33acfd06" id="r_ac527d9d4a5abcc7940a1bb5b33acfd06"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac527d9d4a5abcc7940a1bb5b33acfd06">const_iterator_string</a></td></tr>
<tr class="memdesc:ac527d9d4a5abcc7940a1bb5b33acfd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt;::const_iterator</code>.  <br /></td></tr>
<tr class="separator:ac527d9d4a5abcc7940a1bb5b33acfd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28bcebabfbfd210b2ace57938d9d7f5" id="r_ab28bcebabfbfd210b2ace57938d9d7f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab28bcebabfbfd210b2ace57938d9d7f5">const_iterator_word_type</a></td></tr>
<tr class="memdesc:ab28bcebabfbfd210b2ace57938d9d7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991" title="Type for a word over the generators of a semigroup.">word_type</a>&gt;::const_iterator</code>.  <br /></td></tr>
<tr class="separator:ab28bcebabfbfd210b2ace57938d9d7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a479599a2a8adfa742c728c9c06fcc616" id="r_a479599a2a8adfa742c728c9c06fcc616"><td class="memItemLeft" align="right" valign="top"><a id="a479599a2a8adfa742c728c9c06fcc616" name="a479599a2a8adfa742c728c9c06fcc616"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IsObviouslyInfinite</b> (<a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a479599a2a8adfa742c728c9c06fcc616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted. <br /></td></tr>
<tr class="separator:a479599a2a8adfa742c728c9c06fcc616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8504046d97c7692725b6d0f9194fdee" id="r_ad8504046d97c7692725b6d0f9194fdee"><td class="memItemLeft" align="right" valign="top"><a id="ad8504046d97c7692725b6d0f9194fdee" name="ad8504046d97c7692725b6d0f9194fdee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IsObviouslyInfinite</b> (<a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> const &amp;)=delete</td></tr>
<tr class="memdesc:ad8504046d97c7692725b6d0f9194fdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted. <br /></td></tr>
<tr class="separator:ad8504046d97c7692725b6d0f9194fdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7ff73a6313f1d7277d2c1b5ae349c3" id="r_a1c7ff73a6313f1d7277d2c1b5ae349c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c7ff73a6313f1d7277d2c1b5ae349c3">IsObviouslyInfinite</a> (size_t n)</td></tr>
<tr class="memdesc:a1c7ff73a6313f1d7277d2c1b5ae349c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from alphabet size.  <br /></td></tr>
<tr class="separator:a1c7ff73a6313f1d7277d2c1b5ae349c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488d545bc99c42e842a1e2dd40085c1f" id="r_a488d545bc99c42e842a1e2dd40085c1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a488d545bc99c42e842a1e2dd40085c1f">IsObviouslyInfinite</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;lphbt)</td></tr>
<tr class="memdesc:a488d545bc99c42e842a1e2dd40085c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from alphabet.  <br /></td></tr>
<tr class="separator:a488d545bc99c42e842a1e2dd40085c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2579022a94e0a7f612d3927930b36d66" id="r_a2579022a94e0a7f612d3927930b36d66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2579022a94e0a7f612d3927930b36d66">add_rules_no_checks</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;lphbt, <a class="el" href="#a0b87c81bc8d329502f37a7298a9f00cd">const_iterator_pair_string</a> first, <a class="el" href="#a0b87c81bc8d329502f37a7298a9f00cd">const_iterator_pair_string</a> last)</td></tr>
<tr class="memdesc:a2579022a94e0a7f612d3927930b36d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules from iterators to <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a> of <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>.  <br /></td></tr>
<tr class="separator:a2579022a94e0a7f612d3927930b36d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfff8ec357d3f177d166e2d514dc50e" id="r_a9bfff8ec357d3f177d166e2d514dc50e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bfff8ec357d3f177d166e2d514dc50e">add_rules_no_checks</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;lphbt, <a class="el" href="#ac527d9d4a5abcc7940a1bb5b33acfd06">const_iterator_string</a> first, <a class="el" href="#ac527d9d4a5abcc7940a1bb5b33acfd06">const_iterator_string</a> last)</td></tr>
<tr class="memdesc:a9bfff8ec357d3f177d166e2d514dc50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules from iterators to <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>.  <br /></td></tr>
<tr class="separator:a9bfff8ec357d3f177d166e2d514dc50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6b49d0de69887bb6ba170ca0ed4e47" id="r_a7b6b49d0de69887bb6ba170ca0ed4e47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b6b49d0de69887bb6ba170ca0ed4e47">add_rules_no_checks</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;lphbt, <a class="el" href="#ab28bcebabfbfd210b2ace57938d9d7f5">const_iterator_word_type</a> first, <a class="el" href="#ab28bcebabfbfd210b2ace57938d9d7f5">const_iterator_word_type</a> last)</td></tr>
<tr class="memdesc:a7b6b49d0de69887bb6ba170ca0ed4e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules from iterators to <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a>.  <br /></td></tr>
<tr class="separator:a7b6b49d0de69887bb6ba170ca0ed4e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116e1d4ec151b7b9e5fc19c47cb282bd" id="r_a116e1d4ec151b7b9e5fc19c47cb282bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a116e1d4ec151b7b9e5fc19c47cb282bd">add_rules_no_checks</a> (<a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;, <a class="el" href="#ab28bcebabfbfd210b2ace57938d9d7f5">const_iterator_word_type</a> first, <a class="el" href="#ab28bcebabfbfd210b2ace57938d9d7f5">const_iterator_word_type</a> last)</td></tr>
<tr class="memdesc:a116e1d4ec151b7b9e5fc19c47cb282bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules from iterators to <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a>.  <br /></td></tr>
<tr class="separator:a116e1d4ec151b7b9e5fc19c47cb282bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af524f88f8193b74eec21eb7445c3ea4e" id="r_af524f88f8193b74eec21eb7445c3ea4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af524f88f8193b74eec21eb7445c3ea4e">init</a> (size_t n)</td></tr>
<tr class="separator:af524f88f8193b74eec21eb7445c3ea4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cabea4bb8cfefa1788a48dfc441d8e" id="r_aa2cabea4bb8cfefa1788a48dfc441d8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2cabea4bb8cfefa1788a48dfc441d8e">init</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;lphbt)</td></tr>
<tr class="separator:aa2cabea4bb8cfefa1788a48dfc441d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af999a5e5f1ff05210a863c5563e4fb6b" id="r_af999a5e5f1ff05210a863c5563e4fb6b"><td class="memItemLeft" align="right" valign="top"><a id="af999a5e5f1ff05210a863c5563e4fb6b" name="af999a5e5f1ff05210a863c5563e4fb6b"></a>
<a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:af999a5e5f1ff05210a863c5563e4fb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted. <br /></td></tr>
<tr class="separator:af999a5e5f1ff05210a863c5563e4fb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c0b63f111bf442354e98ba938cbbd0" id="r_a58c0b63f111bf442354e98ba938cbbd0"><td class="memItemLeft" align="right" valign="top"><a id="a58c0b63f111bf442354e98ba938cbbd0" name="a58c0b63f111bf442354e98ba938cbbd0"></a>
<a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> const &amp;)=delete</td></tr>
<tr class="memdesc:a58c0b63f111bf442354e98ba938cbbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted. <br /></td></tr>
<tr class="separator:a58c0b63f111bf442354e98ba938cbbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f3f5eade04da7d46203c139e9d4ac5" id="r_af6f3f5eade04da7d46203c139e9d4ac5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6f3f5eade04da7d46203c139e9d4ac5">result</a> () const</td></tr>
<tr class="memdesc:af6f3f5eade04da7d46203c139e9d4ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the finitely presented semigroup or monoid is obviously infinite.  <br /></td></tr>
<tr class="separator:af6f3f5eade04da7d46203c139e9d4ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0b87c81bc8d329502f37a7298a9f00cd" name="a0b87c81bc8d329502f37a7298a9f00cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b87c81bc8d329502f37a7298a9f00cd">&#9670;&#160;</a></span>const_iterator_pair_string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0b87c81bc8d329502f37a7298a9f00cd">const_iterator_pair_string</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <span class="keyword">typename</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;</div>
<div class="line">        <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;std::string, std::string&gt;</a>&gt;::const_iterator</div>
<div class="ttc" id="apair_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a></div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></div></div>
</div><!-- fragment --><p>Alias for <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt;&gt;::const_iterator</code>. </p>

</div>
</div>
<a id="ac527d9d4a5abcc7940a1bb5b33acfd06" name="ac527d9d4a5abcc7940a1bb5b33acfd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac527d9d4a5abcc7940a1bb5b33acfd06">&#9670;&#160;</a></span>const_iterator_string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac527d9d4a5abcc7940a1bb5b33acfd06">const_iterator_string</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">        <span class="keyword">typename</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;std::string&gt;::const_iterator</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab28bcebabfbfd210b2ace57938d9d7f5" name="ab28bcebabfbfd210b2ace57938d9d7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28bcebabfbfd210b2ace57938d9d7f5">&#9670;&#160;</a></span>const_iterator_word_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab28bcebabfbfd210b2ace57938d9d7f5">const_iterator_word_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">        <span class="keyword">typename</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;word_type&gt;::const_iterator</a></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1c7ff73a6313f1d7277d2c1b5ae349c3" name="a1c7ff73a6313f1d7277d2c1b5ae349c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7ff73a6313f1d7277d2c1b5ae349c3">&#9670;&#160;</a></span>IsObviouslyInfinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an empty <a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html" title="Class for checking if a finitely presented semigroup or monoid is obviously infinite.">IsObviouslyInfinite</a> object representing a finitely presented semigroup or monoid with <code class="param">n</code> generators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of generators.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="a488d545bc99c42e842a1e2dd40085c1f" name="a488d545bc99c42e842a1e2dd40085c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488d545bc99c42e842a1e2dd40085c1f">&#9670;&#160;</a></span>IsObviouslyInfinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lphbt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an empty <a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html" title="Class for checking if a finitely presented semigroup or monoid is obviously infinite.">IsObviouslyInfinite</a> object representing a finitely presented semigroup or monoid with alphabet <code class="param">lphbt</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lphbt</td><td>the alphabet to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2579022a94e0a7f612d3927930b36d66" name="a2579022a94e0a7f612d3927930b36d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2579022a94e0a7f612d3927930b36d66">&#9670;&#160;</a></span>add_rules_no_checks() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp; add_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lphbt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0b87c81bc8d329502f37a7298a9f00cd">const_iterator_pair_string</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0b87c81bc8d329502f37a7298a9f00cd">const_iterator_pair_string</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds the rules described by the iterators <code class="param">first</code> and <code class="param">last</code>. The rules are translated to <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> objects using the position of each character in the 1st argument <code class="param">lphbt</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lphbt</td><td>the alphabet to use.</td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing at the left-hand-side of the first rule to add.</td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing one beyond the right-hand-side of the last rule to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not check its arguments. </dd></dl>

</div>
</div>
<a id="a9bfff8ec357d3f177d166e2d514dc50e" name="a9bfff8ec357d3f177d166e2d514dc50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfff8ec357d3f177d166e2d514dc50e">&#9670;&#160;</a></span>add_rules_no_checks() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp; add_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lphbt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac527d9d4a5abcc7940a1bb5b33acfd06">const_iterator_string</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac527d9d4a5abcc7940a1bb5b33acfd06">const_iterator_string</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds the rules described by the iterators <code class="param">first</code> and <code class="param">last</code>. The rules are translated to <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> objects using the position of each character in the 1st argument <code class="param">lphbt</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lphbt</td><td>the alphabet to use.</td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing at the left-hand-side of the first rule to add.</td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing one beyond the right-hand-side of the last rule to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not check its arguments. </dd></dl>

</div>
</div>
<a id="a7b6b49d0de69887bb6ba170ca0ed4e47" name="a7b6b49d0de69887bb6ba170ca0ed4e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6b49d0de69887bb6ba170ca0ed4e47">&#9670;&#160;</a></span>add_rules_no_checks() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp; add_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lphbt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab28bcebabfbfd210b2ace57938d9d7f5">const_iterator_word_type</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab28bcebabfbfd210b2ace57938d9d7f5">const_iterator_word_type</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds the rules described by the iterators <code class="param">first</code> and <code class="param">last</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lphbt</td><td>unused (for consistency of interface only). </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing at the left-hand-side of the first rule to add. </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing one beyond the right-hand-side of the last rule to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not check its arguments. </dd></dl>

</div>
</div>
<a id="a116e1d4ec151b7b9e5fc19c47cb282bd" name="a116e1d4ec151b7b9e5fc19c47cb282bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116e1d4ec151b7b9e5fc19c47cb282bd">&#9670;&#160;</a></span>add_rules_no_checks() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp; add_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab28bcebabfbfd210b2ace57938d9d7f5">const_iterator_word_type</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab28bcebabfbfd210b2ace57938d9d7f5">const_iterator_word_type</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds the rules described by the iterators <code class="param">first</code> and <code class="param">last</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing at the left-hand-side of the first rule to add.</td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing one beyond the right-hand-side of the last rule to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not check its arguments. </dd></dl>

</div>
</div>
<a id="af524f88f8193b74eec21eb7445c3ea4e" name="af524f88f8193b74eec21eb7445c3ea4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af524f88f8193b74eec21eb7445c3ea4e">&#9670;&#160;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp; init </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Re-initialize the object as if it had just been constructed.</p>
<p>Calling this function puts it into the same state that it would have been in if it had just been newly constructed with the same parameter <code class="param">n</code>.</p>
<p>This function exists to allow reuse of the memory allocated within the object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of generators.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="aa2cabea4bb8cfefa1788a48dfc441d8e" name="aa2cabea4bb8cfefa1788a48dfc441d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cabea4bb8cfefa1788a48dfc441d8e">&#9670;&#160;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a> &amp; init </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lphbt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Re-initialize the object as if it had just been constructed.</p>
<p>Calling this function puts it into the same state that it would have been in if it had just been newly constructed with the same parameter <code class="param">n</code>.</p>
<p>This function exists to allow reuse of the memory allocated within the object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lphbt</td><td>the alphabet to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="af6f3f5eade04da7d46203c139e9d4ac5" name="af6f3f5eade04da7d46203c139e9d4ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f3f5eade04da7d46203c139e9d4ac5">&#9670;&#160;</a></span>result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool result </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns <code>true</code> if the finitely presented semigroup or monoid defined using the alphabet used to construct an <a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html" title="Class for checking if a finitely presented semigroup or monoid is obviously infinite.">IsObviouslyInfinite</a> object, and with relations added to the <a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html" title="Class for checking if a finitely presented semigroup or monoid is obviously infinite.">IsObviouslyInfinite</a> object by <a class="el" href="#a116e1d4ec151b7b9e5fc19c47cb282bd">add_rules_no_checks</a>, is obviously infinite.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the finitely presented semigroup or monoid is obviously infinite. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/jdm/libsemigroups/include/libsemigroups/<a class="el" href="obvinf_8hpp_source.html">obvinf.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelibsemigroups.html">libsemigroups</a></li><li class="navelem"><a class="el" href="classlibsemigroups_1_1_is_obviously_infinite.html">IsObviouslyInfinite</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
