//
// libsemigroups - C++ library for semigroups and monoids
// Copyright (C) 2016-18 James D. Mitchell
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

// TODO
// 1. check use of:
//    * element_type [x]
//    * const_element_type [x]
//    * reference        [x]
//    * const_reference  [x]
//    * internal_element_type [x]
//    * internal_const_element_type [x]
//    * internal_reference [x]
//    * internal_const_reference [x]
// 2. Check if Semigroup<Element*> works [x]
// 3. Update the doc
// 4. Double check "noexcept" usage!
// 5. Make const member functions thread-safe
// 6. Replace typedef's with aliases. [x]
// 7. Rename to FroidurePin

#ifndef LIBSEMIGROUPS_INCLUDE_SEMIGROUP_H_
#define LIBSEMIGROUPS_INCLUDE_SEMIGROUP_H_

#include <algorithm>
#include <mutex>
#include <numeric>
#include <string>
#include <thread>
#include <unordered_map>
#include <utility>
#include <vector>

#include "internal/libsemigroups-debug.h"
#include "internal/libsemigroups-exception.h"
#include "internal/report.h"
#include "internal/runner.h"
#include "internal/stl.h"
#include "internal/timer.h"

#include "adapters.h"
#include "constants.h"
#include "semigroup-base.h"
#include "semigroup-traits.h"

#ifdef LIBSEMIGROUPS_DENSEHASHMAP
#include "extern/sparsehash-c11/sparsehash/dense_hash_map"
#endif

//! Namespace for everything in the libsemigroups library.
namespace libsemigroups {
  // Forward declaration
  class Element;

  //! Class for semigroups generated by instances of Element.
  //!
  //! Semigroups are defined by a generating set, and the main method here is
  //! Semigroup::enumerate, which implements the
  //! [Froidure-Pin Algorithm](https://www.irif.fr/~jep/PDF/Rio.pdf).
  //! When the enumeration of the semigroup is complete, the size, the left and
  //! right Cayley graphs are determined, and a confluent terminating
  //! presentation for the semigroup is known.
  template <
      typename TElementType  = Element const*,
      typename TElementHash  = hash<TElementType>,
      typename TElementEqual = equal_to<TElementType>,
      class TTraits
      = SemigroupTraitsHashEqual<TElementType, TElementHash, TElementEqual>>
  class Semigroup : private TTraits, public SemigroupBase {
    using element_type       = typename TTraits::element_type;
    using const_element_type = typename TTraits::const_element_type;
    using const_reference    = typename TTraits::const_reference;

    using internal_element_type = typename TTraits::internal_element_type;
    using internal_const_element_type =
        typename TTraits::internal_const_element_type;
    using internal_const_reference = typename TTraits::internal_const_reference;

    using internal_equal_to = typename TTraits::internal_equal_to;
    using internal_hash     = typename TTraits::internal_hash;

    using complexity      = ::libsemigroups::complexity<internal_element_type>;
    using internal_degree = ::libsemigroups::degree<internal_element_type>;
    using increase_degree_by
        = ::libsemigroups::increase_degree_by<internal_element_type>;
    using less    = ::libsemigroups::less<internal_element_type>;
    using one     = ::libsemigroups::one<internal_element_type>;
    using product = ::libsemigroups::product<internal_element_type>;
    using swap    = ::libsemigroups::swap<internal_element_type>;

    // TODO remove the comment out lines here
    // static_assert(std::is_trivial<internal_element_type>::value,
    //              "internal_element_type must be trivial");
    // static_assert(std::is_trivial<internal_const_element_type>::value,
    //              "internal_const_element_type must be trivial");
    static_assert(
        std::is_const<internal_const_element_type>::value
            || std::is_const<typename std::remove_pointer<
                   internal_const_element_type>::type>::value,
        "internal_const_element_type must be const or pointer to const");

    // The elements of a semigroup are stored in _elements, but because of the
    // way add_generators/closure work, it might not be the case that all the
    // words of a given length are contiguous in _elements. Hence we require a
    // means of finding the next element of a given length. In
    // _enumerate_order, the first K_1 values are element_index_type's
    // equal to the positions in _elements of the words of length 1,
    // the next K_2 values are the element_index_type's equal to the positions
    // in _elements of the words of length 2, and so on.
    //
    // This alias is used to distinguish variables that refer to positions in
    // _elements (element_index_type) from those that refer to positions in
    // _enumerate_order (enumerate_index_type).
    using enumerate_index_type = SemigroupBase::size_type;

   public:
    using size_type          = SemigroupBase::size_type;
    using element_index_type = SemigroupBase::element_index_type;

    //! Deleted.
    //!
    //! The Semigroup class does not support an assignment contructor to avoid
    //! accidental copying. An object in Semigroup may use many gigabytes of
    //! memory and might be extremely expensive to copy. A copy constructor is
    //! provided in case such a copy should it be required anyway.
    Semigroup& operator=(Semigroup const& semigroup) = delete;

    //! Construct from generators.
    //!
    //! This is the default constructor for a semigroup generated by \p gens.
    //! The generators \p gens must all be of the same derived subclass of the
    //! Element base class. Additionally, \p gens must satisfy the following:
    //!
    //! 1. there must be at least one generator
    //! 2. the generators must have equal degree Element::degree
    //  FIXME remove Element::degree from previous line
    //! if either of these points is not satisfied, then a
    //! LIBSEMIGROUPS_EXCEPTION will be thrown.
    //!
    //! There can be duplicate generators and although they do not count as
    //! distinct elements, they do count as distinct generators. In other words,
    //! the generators of the semigroup are precisely (a copy of) \p gens in the
    //! same order they occur in \p gens.
    //!
    //! The generators \p gens are copied by the constructor, and so it is the
    //! responsibility of the caller to delete \p gens.
    explicit Semigroup(std::vector<element_type> const* gens)
        : _batch_size(8192),
          _degree(UNDEFINED),
          _duplicate_gens(),
          _elements(),
          _enumerate_order(),
          _final(),
          _first(),
          _found_one(false),
          _gens(),
          _id(),
          _idempotents(),
          _idempotents_found(false),
          _is_idempotent(),
          _left(gens->size()),
          _length(),
          _lenindex(),
          _letter_to_pos(),
          _map(),
          _max_threads(std::thread::hardware_concurrency()),
          _nr(0),
          _nrgens(gens->size()),
          _nrrules(0),
          _pos(0),
          _pos_one(0),
          _prefix(),
          _reduced(gens->size()),
          _relation_gen(0),
          _relation_pos(UNDEFINED),
          _right(gens->size()),
          _sorted(),
          _suffix(),
          _tmp_product(),
          _wordlen(0) {  // (length of the current word) - 1
      if (_nrgens == 0) {
        throw LIBSEMIGROUPS_EXCEPTION("no generators given");
      }
#ifdef LIBSEMIGROUPS_STATS
      _nr_products = 0;
#endif
      _right.set_default_value(UNDEFINED);
      // FIXME inclusion of the next line makes test Semigroup of BMats 01
      // extremely slow (~50ms to ~10s!!!!)
      // reserve(_nrgens);
      _degree = internal_degree()(this->to_internal_const((*gens)[0]));

      for (size_t i = 0; i < _nrgens; ++i) {
        size_t degree = internal_degree()(this->to_internal_const((*gens)[i]));
        if (degree != _degree) {
          throw LIBSEMIGROUPS_EXCEPTION(
              "generator " + to_string(i) + " has degree " + to_string(degree)
              + " but should have degree " + to_string(_degree));
        }
      }
      for (const_reference x : *gens) {
        _gens.push_back(this->internal_copy(this->to_internal_const(x)));
      }

      _tmp_product = one()(_gens[0]);
      _id          = one()(_gens[0]);
      _lenindex.push_back(0);

#ifdef LIBSEMIGROUPS_DENSEHASHMAP
      _map.set_empty_key(this->empty_key(_id));
#endif

      // add the generators
      for (letter_type i = 0; i < _nrgens; i++) {
        auto it = _map.find(_gens[i]);
        if (it != _map.end()) {  // duplicate generator
          _letter_to_pos.push_back(it->second);
          _nrrules++;
          _duplicate_gens.emplace_back(i, _first[it->second]);
          // i.e. _gens[i] = _gens[_first[it->second]]
          // _first maps from element_index_type -> letter_type :)
        } else {
          is_one(_gens[i], _nr);
          _elements.push_back(_gens[i]);
          // Note that every non-duplicate generator is *really* stored in
          // _elements, and so must be deleted from _elements but not _gens.
          _first.push_back(i);
          _final.push_back(i);
          _enumerate_order.push_back(_nr);
          _letter_to_pos.push_back(_nr);
          _length.push_back(1);
          _map.emplace(_elements.back(), _nr);
          _prefix.push_back(UNDEFINED);
          // TODO _prefix.push_back(_nr) and get rid of _letter_to_pos, and
          // the extra clause in the enumerate method!
          _suffix.push_back(UNDEFINED);
          _nr++;
        }
      }
      expand(_nr);
      _lenindex.push_back(_enumerate_order.size());
    }

    //! Construct from generators.
    //!
    //! This constructor simply calls the above constructor with a pointer to \p
    //! gens.
    explicit Semigroup(std::vector<element_type> const& gens)
        : Semigroup(&gens) {}

    //! Construct from generators.
    //!
    //! This constructor simply constructs a vector from \p gens and calls the
    //! above constructor.
    explicit Semigroup(std::initializer_list<element_type> gens)
        : Semigroup(std::vector<element_type>(gens)) {}

    //! Copy constructor.
    //!
    //! Constructs a new Semigroup which is an exact copy of \p copy. No
    //! enumeration is triggered for either \p copy or of the newly constructed
    //! semigroup.
    Semigroup(Semigroup const& S)
        : _batch_size(S._batch_size),
          _degree(S._degree),
          _duplicate_gens(S._duplicate_gens),
          _elements(),
          _enumerate_order(S._enumerate_order),
          _final(S._final),
          _first(S._first),
          _found_one(S._found_one),
          _gens(),
          _id(this->internal_copy(S._id)),
          _idempotents(S._idempotents),
          _idempotents_found(S._idempotents_found),
          _is_idempotent(S._is_idempotent),
          _left(S._left),
          _length(S._length),
          _lenindex(S._lenindex),
          _letter_to_pos(S._letter_to_pos),
          _max_threads(S._max_threads),
          _nr(S._nr),
          _nrgens(S._nrgens),
          _nrrules(S._nrrules),
          _pos(S._pos),
          _pos_one(S._pos_one),
          _prefix(S._prefix),
          _reduced(S._reduced),
          _relation_gen(S._relation_gen),
          _relation_pos(S._relation_pos),
          _right(S._right),
          _sorted(),  // TODO S this if set
          _suffix(S._suffix),
          _wordlen(S._wordlen) {
#ifdef LIBSEMIGROUPS_STATS
      _nr_products = 0;
#endif
      _elements.reserve(_nr);

#ifdef LIBSEMIGROUPS_DENSEHASHMAP
      _map.set_empty_key(this->empty_key(_id));
      _map.resize(_nr);
#else
      _map.reserve(_nr);
#endif
      _tmp_product = this->internal_copy(S._id);

      element_index_type i = 0;
      for (internal_const_reference x : S._elements) {
        auto y = this->internal_copy(x);
        _elements.push_back(y);
        _map.emplace(y, i++);
      }
      copy_gens();
    }

   private:
    // Partial copy.
    // \p copy a semigroup
    // \p coll a collection of additional generators
    //
    // This is a constructor for a semigroup generated by the generators of the
    // Semigroup copy and the (possibly) additional generators coll.
    //
    // The relevant parts of the data structure of copy are copied and
    // \c this will be corrupt unless add_generators or closure is called
    // subsequently. This is why this method is private.
    //
    // The same effect can be obtained by copying copy using the copy
    // constructor and then calling add_generators or closure. However,
    // this constructor avoids copying those parts of the data structure of
    // copy that add_generators invalidates anyway. If copy has not been
    // enumerated at all, then these two routes for adding more generators are
    // equivalent.
    //
    // <add_generators> or <closure> should usually be called after this.
    Semigroup(Semigroup const& S, std::vector<element_type> const* coll)
        : _batch_size(S._batch_size),
          _degree(S._degree),  // copy for comparison in add_generators
          _duplicate_gens(S._duplicate_gens),
          _elements(),
          _found_one(S._found_one),  // copy in case degree doesn't change in
                                     // add_generators
          _gens(),
          _idempotents(S._idempotents),
          _idempotents_found(S._idempotents_found),
          _is_idempotent(S._is_idempotent),
          _left(S._left),
          _letter_to_pos(S._letter_to_pos),
          _max_threads(S._max_threads),
          _nr(S._nr),
          _nrgens(S._nrgens),
          _nrrules(0),
          _pos(S._pos),
          _pos_one(S._pos_one),  // copy in case degree doesn't change in
                                 // add_generators
          _reduced(S._reduced),
          _relation_gen(0),
          _relation_pos(UNDEFINED),
          _right(S._right),
          _sorted(),
          _wordlen(0) {
      LIBSEMIGROUPS_ASSERT(!coll->empty());
      LIBSEMIGROUPS_ASSERT(internal_degree()(coll->at(0)) >= S.degree());

#ifdef LIBSEMIGROUPS_DEBUG
      for (const_reference x : *coll) {
        LIBSEMIGROUPS_ASSERT(internal_degree()(x)
                             == internal_degree()((*coll)[0]));
      }
#endif
#ifdef LIBSEMIGROUPS_STATS
      _nr_products = 0;
#endif
      _elements.reserve(S._nr);

      // the following are required for assignment to specific positions in
      // add_generators
      _final.resize(S._nr, 0);
      _first.resize(S._nr, 0);
      _length.resize(S._nr, 0);
      _prefix.resize(S._nr, 0);
      _suffix.resize(S._nr, 0);

      size_t deg_plus = internal_degree()(coll->at(0)) - S.degree();

      if (deg_plus != 0) {
        _degree += deg_plus;
        _found_one = false;
        _pos_one   = 0;
      }

      _lenindex.push_back(0);
      _lenindex.push_back(S._lenindex[1]);
      _enumerate_order.reserve(S._nr);

      // add the distinct old generators to new _enumerate_order
      for (enumerate_index_type i = 0; i < S._lenindex[1]; i++) {
        _enumerate_order.push_back(S._enumerate_order[i]);
        _final[_enumerate_order[i]]  = S._final[S._enumerate_order[i]];
        _first[_enumerate_order[i]]  = S._first[S._enumerate_order[i]];
        _prefix[_enumerate_order[i]] = UNDEFINED;
        _suffix[_enumerate_order[i]] = UNDEFINED;
        _length[_enumerate_order[i]] = 1;
      }

      _id          = one()(this->to_internal(coll->at(0)));
      _tmp_product = this->internal_copy(_id);

#ifdef LIBSEMIGROUPS_DENSEHASHMAP
      _map.set_empty_key(this->empty_key(_id));
      _map.resize(S._nr);
#else
      _map.reserve(S._nr);
#endif

      element_index_type i = 0;
      for (internal_const_reference x : S._elements) {
        auto y = this->internal_copy(x);
        increase_degree_by()(y, deg_plus);
        _elements.push_back(y);
        _map.emplace(y, i);
        is_one(y, i++);
      }
      copy_gens();  // copy the old generators
      // Now this is ready to have add_generators or closure called on it
    }

    // Read-only - thread-safe
    void verify_element_index(element_index_type i) const {
      if (i >= _nr) {
        throw LIBSEMIGROUPS_EXCEPTION(
            "there are only " + to_string(_nr) + " elements"
            + (finished() ? "" : " enumerated so far") + ", but index "
            + to_string(i) + " was given");
      }
    }

    // thread-safe?
    void verify_letter_index(letter_type i) const {
      if (i >= nr_generators()) {
        throw LIBSEMIGROUPS_EXCEPTION("there are only  " + to_string(nr_generators())
                                      + " generators, not " + to_string(i));
      }
    }

   public:
    //! A default destructor.
    ~Semigroup() {
      this->internal_free(_tmp_product);
      this->internal_free(_id);

      // delete those generators not in _elements, i.e. the duplicate ones
      for (auto& x : _duplicate_gens) {
        this->internal_free(_gens[x.first]);
      }
      for (auto& x : _elements) {
        this->internal_free(x);
      }
    }

    //! Returns the position in the semigroup corresponding to the element
    //! represented by the word \p w.
    //!
    //! The parameter \p w must consist of non-negative integers less than
    //! Semigroup::nrgens, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    //! This method returns the position in \c this of the element obtained by
    //! evaluating \p w. This method does not perform any enumeration of the
    //! semigroup, and will return UNDEFINED if the position of the element of
    //! \c this corresponding to \p w cannot be determined.
    //!
    //! This is equivalent to finding the product \c x of the
    //! generators Semigroup::gens(\c w[i]) and then calling
    //! Semigroup::position_current with argument \c x.
    //!
    //! \sa Semigroup::word_to_element.
    element_index_type word_to_pos(word_type const& w) const override {
      // w is a word in the generators (i.e. a vector of letter_type's)
      if (w.size() == 0) {
        throw LIBSEMIGROUPS_EXCEPTION("the given word has length 0");
      }
      for (auto x : w) {
        verify_letter_index(x);
      }
      element_index_type out = _letter_to_pos[w[0]];
      for (auto it = w.cbegin() + 1; it < w.cend() && out != UNDEFINED; ++it) {
        out = _right.get(out, _letter_to_pos[*it]);
      }
      return out;
    }

    //! Returns a copy of the element of \c this represented by the word
    //! \p w.
    //!
    //! The parameter \p w must consist of non-negative integers less than
    //! Semigroup::nrgens, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    //! This method returns a copy of the element of \c this obtained by
    //! evaluating \p w. This is equivalent to finding the product \c x of the
    //! generators Semigroup::gens(\c w[i]).
    //!
    //! A copy is returned instead of a reference, because the element of \c
    //! this corresponding to \p w may not yet have been enumerated.
    //!
    //! \sa Semigroup::word_to_pos.
    // TODO should return rvalue reference
    element_type word_to_element(word_type const& w) const {
      element_index_type pos = word_to_pos(w);
      if (pos != UNDEFINED) {
        // Return a copy
        return this->external_copy(_elements[pos]);
      }
      // word_to_pos is always known for generators (i.e. when w.size() == 1),
      // and word_to_pos verifies that w is valid.
      LIBSEMIGROUPS_ASSERT(w.size() > 1);
      LIBSEMIGROUPS_ASSERT(w[0] < nr_generators() && w[1] < nr_generators());
      element_type prod = this->external_copy(_tmp_product);
      product()(this->to_internal(prod), _gens[w[0]], _gens[w[1]]);
      for (auto it = w.begin() + 2; it < w.end(); ++it) {
        LIBSEMIGROUPS_ASSERT(*it < nr_generators());
        swap()(_tmp_product, this->to_internal(prod));
        product()(this->to_internal(prod), _tmp_product, _gens[*it]);
      }
      return prod;
    }

    //! Returns the maximum length of a word in the generators so far computed.
    //!
    //! Every elements of the semigroup can be expressed as a product of the
    //! generators. The elements of the semigroup are enumerated in the
    //! short-lex order induced by the order of the generators (as passed to
    //! Semigroup::Semigroup).  This method returns the length of the longest
    //! word in the generators that has so far been enumerated.
    size_t current_max_word_length() const noexcept override {
      if (finished()) {
        return _lenindex.size() - 2;
      } else if (_nr > _lenindex.back()) {
        return _lenindex.size();
      } else {
        return _lenindex.size() - 1;
      }
    }

    //! Returns the degree of any (and all) Element's in the semigroup.
    size_t degree() const noexcept override {
      return _degree;
    }

    //! Returns the number of generators of the semigroup.
    size_t nr_generators() const noexcept override {
      return _gens.size();
    }

    //! Returns a const reference to the generator with index \p pos.
    //!
    //! If \p pos is not less than Semigroup::nr_generators(), a
    //! LIBSEMIGROUPS_EXCEPTION will be thrown. Note that Semigroup::gens(pos)
    //! is in general in general not in position \p pos in the semigroup, i.e.
    //! is not equal to Semigroup::at(pos).
    const_reference generator(letter_type pos) const {
      verify_letter_index(pos);
      return this->to_external_const(_gens[pos]);
    }

    //! Returns \c true if the semigroup is fully enumerated and \c false if
    //! not.
    //!
    //! The semigroup is fully enumerated when the product of every element
    //! by every generator is known.
    bool finished_impl() const override {
      return (_pos >= _nr);
    }

    // TODO: remove this
    bool is_done() const override {
      return finished_impl();
    }

    //! Returns \c true if elements other than the generators have been
    //! enumerated so far and \c false otherwise.
    bool is_begun() const noexcept override {
      LIBSEMIGROUPS_ASSERT(_lenindex.size() > 1);
      return (_pos >= _lenindex[1]);
    }

    //! Returns the position of the element \p x in the semigroup if it is
    //! already known to belong to the semigroup.
    //!
    //! This method finds the position of the element \p x in the semigroup if
    //! it is already known to belong to the semigroup, and
    //! libsemigroups::Semigroup::UNDEFINED if not. If the semigroup is
    //! not fully enumerated, then this method may return
    //! libsemigroups::Semigroup::UNDEFINED when \p x is in the semigroup,
    //! but this is not yet known.
    //!
    //! \sa Semigroup::position and Semigroup::sorted_position.
    element_index_type current_position(const_reference x) const {
      if (internal_degree()(this->to_internal_const(x)) != _degree) {
        return UNDEFINED;
      }

      auto it = _map.find(this->to_internal_const(x));
      return (it == _map.end() ? UNDEFINED : it->second);
    }

    //! Returns the number of elements in the semigroup that have been
    //! enumerated so far.
    //!
    //! This is only the actual size of the semigroup if the semigroup is fully
    //! enumerated.
    size_t current_size() const noexcept override {
      return _elements.size();
    }

    //! Returns the number of relations in the presentation for the semigroup
    //! that have been found so far.
    //!
    //! This is only the actual number of relations in a presentation defining
    //! the semigroup if the semigroup is fully enumerated.
    size_t current_nrrules() const noexcept override {
      return _nrrules;
    }

    //! Returns the position of the prefix of the element \c x in position
    //! \p pos (of the semigroup) of length one less than the length of \c x.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    element_index_type prefix(element_index_type pos) const override {
      verify_element_index(pos);
      return _prefix[pos];
    }

    //! Returns the position of the suffix of the element \c x in position
    //! \p pos (of the semigroup) of length one less than the length of \c x.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    element_index_type suffix(element_index_type pos) const override {
      verify_element_index(pos);
      return _suffix[pos];
    }

    //! Returns the first letter of the element in position \p pos.
    //!
    //! This method returns the first letter of the element in position \p pos
    //! of the semigroup, which is the index of the generator corresponding to
    //! the first letter of the element.
    //!
    //! Note that Semigroup::gens[Semigroup::first_letter(\c pos)] is only
    //! equal to Semigroup::at(Semigroup::first_letter(\c pos)) if there are no
    //! duplicate generators.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    letter_type first_letter(element_index_type pos) const override {
      verify_element_index(pos);
      return _first[pos];
    }

    //! Returns the last letter of the element in position \p pos.
    //!
    //! This method returns the final letter of the element in position \p pos
    //! of the semigroup, which is the index of the generator corresponding to
    //! the final letter of the element.
    //!
    //! Note that Semigroup::gens[Semigroup::final_letter(\c pos)] is only
    //! equal to Semigroup::at(Semigroup::final_letter(\c pos)) if there are no
    //! duplicate generators.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    letter_type final_letter(element_index_type pos) const override {
      verify_element_index(pos);
      return _final[pos];
    }

    //! Returns the current value of the batch size. This is the minimum
    //! number of elements enumerated in any call to Semigroup::enumerate.
    size_t batch_size() const noexcept override {
      return _batch_size;
    }

    //! Returns the length of the element in position \c pos of the semigroup.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    //! This method causes no enumeration of the semigroup.
    size_t length_const(element_index_type pos) const override {
      verify_element_index(pos);
      return _length[pos];
    }

    //! Returns the length of the element in position \c pos of the semigroup.
    //!
    //! The parameter \p pos must be a valid position of an element of the
    //! semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    size_t length_non_const(element_index_type pos) override {
      if (pos >= _nr) {
        enumerate();
      }
      return length_const(pos);
    }

    //! Returns the position in \c this of the product of \c this->at(i) and
    //! \c this->at(j) by following a path in the Cayley graph.
    //!
    //! The values \p i and \p j must be less than Semigroup::current_size, or
    //! a LIBSEMIGROUPS_EXCEPTION will be thrown.
    //! This method returns the position Semigroup::element_index_type in the
    //! semigroup of the product of \c this->at(i) and \c this->at(j) elements
    //! by following the path in the right Cayley graph from \p i labelled by
    //! the word \c this->minimal_factorisation(j) or, if
    //! this->minimal_factorisation(i) is shorter, by following the path in the
    //! left Cayley graph from \p j labelled by this->minimal_factorisation(i).
    element_index_type
    product_by_reduction(element_index_type i,
                         element_index_type j) const override {
      verify_element_index(i);
      verify_element_index(j);

      if (length_const(i) <= length_const(j)) {
        while (i != UNDEFINED) {
          j = _left.get(j, _final[i]);
          i = _prefix[i];
        }
        return j;
      } else {
        while (j != UNDEFINED) {
          i = _right.get(i, _first[j]);
          j = _suffix[j];
        }
        return i;
      }
    }

    //! Returns the position in \c this of the product of \c this->at(i) and
    //! \c this->at(j).
    //!
    //! The values \p i and \p j must be less than Semigroup::current_size, or
    //! a LIBSEMIGROUPS_EXCEPTION will be thrown.
    //! This method either:
    //!
    //! * follows the path in the right or left Cayley graph from \p i to \p j,
    //!   whichever is shorter using Semigroup::product_by_reduction; or
    //!
    //! * multiplies the elements in postions \p i and \p j together;
    //!
    //! whichever is better. The method used is determined by comparing
    //! Element::complexity and the Semigroup::length_const of \p i and \p j.
    //!
    //! For example, if the Element::complexity of the multiplication is linear
    //! and \c this is a semigroup of transformations of degree 20, and the
    //! shortest paths in the left and right Cayley graphs from \p i to \p j
    //! are of length 100 and 1131, then it better to just product the
    //! transformations together.
    element_index_type fast_product(element_index_type i,
                                    element_index_type j) const override {
      verify_element_index(i);
      verify_element_index(j);
      if (length_const(i) < 2 * complexity()(_tmp_product)
          || length_const(j) < 2 * complexity()(_tmp_product)) {
        return product_by_reduction(i, j);
      } else {
        product()(_tmp_product, _elements[i], _elements[j]);
        return _map.find(_tmp_product)->second;
      }
    }

    //! Returns the position in \c this of the generator with index \p i
    //!
    //! If \p i is not a valid generator index, a LIBSEMIGROUPS_EXCEPTION will
    //! be thrown. In many cases \p letter_to_pos(i) will equal \p i, examples
    //! of when this will not be the case are:
    //!
    //! * there are duplicate generators;
    //!
    //! * Semigroup::add_generators was called after the semigroup was already
    //! partially enumerated.
    element_index_type letter_to_pos(letter_type i) const override {
      verify_letter_index(i);
      return _letter_to_pos[i];
    }

    //! Returns the total number of idempotents in the semigroup.
    //!
    //! This method involves fully enumerating the semigroup, if it is not
    //! already fully enumerated.  The value of the positions, and number, of
    //! idempotents is stored after they are first computed.
    size_t nridempotents() override {
      init_idempotents();
      return _idempotents.size();
    }

    //! Returns \c true if the element in position \p pos is an idempotent
    //! and \c false if it is not.
    //!
    //! The parameter \p pos must be a valid position of an element of the
    //! semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    //! This method involves fully enumerating the semigroup, if it is not
    //! already fully enumerated.
    bool is_idempotent(element_index_type pos) override {
      verify_element_index(pos);
      init_idempotents();
      return _is_idempotent[pos];
    }

    //! Returns the total number of relations in the presentation defining the
    //! semigroup.
    //!
    //! \sa Semigroup::next_relation.
    size_t nrrules() override {
      enumerate();
      return _nrrules;
    }

    //! Set a new value for the batch size.
    //!
    //! The *batch size* is the number of new elements to be found by any call
    //! to Semigroup::enumerate. A call to enumerate returns between 0 and
    //! approximately the batch size.
    //!
    //! The default value of the batch size is 8192.
    //!
    //! This is used by, for example, Semigroup::position so that it is
    //! possible to find the position of an element without fully enumerating
    //! the semigroup.
    void set_batch_size(size_t batch_size) noexcept override {
      _batch_size = batch_size;
    }

    //! Requests that the capacity (i.e. number of elements) of the semigroup
    //! be at least enough to contain n elements.
    //!
    //! The parameter \p n is also used to initialise certain data members, if
    //! you know a good upper bound for the size of your semigroup, then it is
    //! a good idea to call this method with that upper bound as an argument,
    //! this can significantly improve the performance of the
    //! Semigroup::enumerate method, and consequently every other method too.
    void reserve(size_t n) override {
      // Since the Semigroup we are enumerating is bounded in size by the
      // maximum value of an element_index_t, we cast the argument here to this
      // integer type.
      element_index_type nn = static_cast<element_index_type>(n);
      _elements.reserve(nn);
      _final.reserve(nn);
      _first.reserve(nn);
      _enumerate_order.reserve(nn);
      _left.reserve(nn);
      _length.reserve(nn);

#ifdef LIBSEMIGROUPS_DENSEHASHMAP
      _map.resize(nn);
#else
      _map.reserve(nn);
#endif

      _prefix.reserve(nn);
      _reduced.reserve(nn);
      _right.reserve(nn);
      _suffix.reserve(nn);
    }

    //! Returns the size of the semigroup.
    size_t size() override {
      enumerate();
      return _elements.size();
    }

    //! Returns \c true if \p x is an element of \c this and \c false if it is
    //! not.
    //!
    //! This method can be used to check if the element \p x is an element of
    //! the semigroup. The semigroup is enumerated in batches until \p x is
    //! found or the semigroup is fully enumerated but \p x was not found (see
    //! Semigroup::set_batch_size).
    bool test_membership(const_reference x) {
      return (position(x) != UNDEFINED);
    }

    //! Returns the position of \p x in \c this, or Semigroup::UNDEFINED if \p
    //! x is not an element of \c this.
    //!
    //! This method can be used to find the Semigroup::element_index_type
    //! position of the element \p x if it belongs to the semigroup. The
    //! semigroup is enumerated in batches until \p x is found or the semigroup
    //! is fully enumerated but \p x was not found (see
    //! Semigroup::set_batch_size).
    element_index_type position(const_reference x) {
      if (internal_degree()(this->to_internal_const(x)) != _degree) {
        return UNDEFINED;
      }

      while (true) {
        auto it = _map.find(this->to_internal_const(x));
        if (it != _map.end()) {
          return it->second;
        }
        if (finished()) {
          return UNDEFINED;
        }
        enumerate(_nr + 1);
        // _nr + 1 means we enumerate _batch_size more elements
      }
    }

    //! Returns the position of \p x in the sorted array of elements of the
    //! semigroup, or Semigroup::UNDEFINED if \p x is not an element of \c
    //! this.
    element_index_type sorted_position(const_reference x) {
      return position_to_sorted_position(position(x));
    }

    //! Returns the position of \c this->at(pos) in the sorted array of
    //! elements of the semigroup, or Semigroup::UNDEFINED if \p pos is greater
    //! than the size of the semigroup.
    element_index_type
    position_to_sorted_position(element_index_type pos) override {
      enumerate(LIMIT_MAX);
      if (pos >= _nr) {
        return UNDEFINED;
      }
      init_sorted();
      return _sorted[pos].second;
    }

    //! Returns  the element of the semigroup in position \p pos, or a
    //! \c nullptr if there is no such element.
    //!
    //! This method attempts to enumerate the semigroup until at least
    //! \c pos + 1 elements have been found. If \p pos is greater than
    //! Semigroup::size, then this method returns \c nullptr.
    const_reference at(element_index_type pos) {
      enumerate(pos + 1);
      return this->to_external_const(_elements.at(pos));
    }

    //! Returns the element of the semigroup in position \p pos.
    //!
    //! This method performs no checks on its argument, and performs no
    //! enumeration of the semigroup.
    const_reference operator[](element_index_type pos) const {
      LIBSEMIGROUPS_ASSERT(pos < _elements.size());
      return this->to_external_const(_elements[pos]);
    }

    //! Returns the element of the semigroup in position \p pos of the sorted
    //! array of elements, or \c nullptr in \p pos is not valid (i.e. too big).
    //!
    //! This method fully enumerates the semigroup.
    const_reference sorted_at(element_index_type pos) {
      init_sorted();
      return this->to_external_const(_sorted.at(pos).first);
    }

    //! Returns the index of the product of the element in position \p i with
    //! the generator with index \p j.
    //!
    //! This method fully enumerates the semigroup.
    element_index_type right(element_index_type i, letter_type j) override {
      enumerate();
      return _right.get(i, j);
    }

    //! Returns a copy of the right Cayley graph of the semigroup.
    //!
    //! This method fully enumerates the semigroup.
    cayley_graph_type* right_cayley_graph_copy() override {
      enumerate();
      return new cayley_graph_type(_right);
    }

    //! Returns the index of the product of the generator with index \p j and
    //! the element in position \p i.
    //!
    //! This method fully enumerates the semigroup.
    element_index_type left(element_index_type i, letter_type j) override {
      enumerate();
      return _left.get(i, j);
    }

    //! Returns a copy of the left Cayley graph of the semigroup.
    //!
    //! This method fully enumerates the semigroup.
    cayley_graph_type* left_cayley_graph_copy() override {
      enumerate();
      return new cayley_graph_type(_left);
    }

    //! Changes \p word in-place to contain a minimal word with respect to the
    //! short-lex ordering in the generators equal to the \p pos element of
    //! the semigroup.
    //!
    //! If \p pos is less than the size of this semigroup, then this method
    //! changes its first parameter \p word in-place by first clearing it and
    //! then to contain a minimal factorization of the element in position \p
    //! pos of the semigroup with respect to the generators of the semigroup.
    //! This method enumerates the semigroup until at least the \p pos element
    //! is known. If \p pos is greater than the size of the semigroup, then
    //! a LIBSEMIGROUPS_EXCEPTION is thrown.
    void minimal_factorisation(word_type&         word,
                               element_index_type pos) override {
      if (pos >= _nr && !finished()) {
        enumerate(pos + 1);
      }
      verify_element_index(pos);
      word.clear();
      while (pos != UNDEFINED) {
        word.push_back(_first[pos]);
        pos = _suffix[pos];
      }
    }

    //! Returns a minimal libsemigroups::word_type which evaluates to the
    //! Element in position \p pos of \c this.
    //!
    //! This is the same as the two-argument method for
    //! Semigroup::minimal_factorisation, but it returns a pointer to the
    //! factorisation instead of modifying an argument in-place.
    //! If \p pos is greater than the size of the semigroup, then a
    //! LIBSEMIGROUPS_EXCEPTION is thrown.
    word_type minimal_factorisation(element_index_type pos) override {
      word_type word;
      minimal_factorisation(word, pos);
      return word;
    }

    //! Returns a minimal libsemigroups::word_type which evaluates to \p x.
    //!
    //! This is the same as the method taking a Semigroup::element_index_type,
    //! but it factorises an Element instead of using the position of an
    //! element. If \p pos is greater than the size of the semigroup, then a
    //! LIBSEMIGROUPS_EXCEPTION is thrown.
    word_type minimal_factorisation(const_reference x) {
      element_index_type pos = this->position(x);
      if (pos == UNDEFINED) {
        throw LIBSEMIGROUPS_EXCEPTION(
            "the argument is not an element of the semigroup");
      }
      return minimal_factorisation(pos);
    }

    //! Changes \p word in-place to contain a word in the generators equal to
    //! the \p pos element of the semigroup.
    //!
    //! The key difference between this method and
    //! Semigroup::minimal_factorisation(word_type& word, element_index_type
    //! pos), is that the resulting factorisation may not be minimal. If \p pos
    //! is greater than the size of the semigroup, then a
    //! LIBSEMIGROUPS_EXCEPTION is thrown.
    void factorisation(word_type& word, element_index_type pos) override {
      minimal_factorisation(word, pos);
    }

    //! Returns a libsemigroups::word_type which evaluates to the Element in
    //! position \p pos of \c this.
    //!
    //! The key difference between this method and
    //! Semigroup::minimal_factorisation(element_index_type pos), is that the
    //! resulting factorisation may not be minimal.
    //! If \p pos is greater than the size of the semigroup, then a
    //! LIBSEMIGROUPS_EXCEPTION is thrown.
    word_type factorisation(element_index_type pos) override {
      return minimal_factorisation(pos);
    }

    //! Returns a libsemigroups::word_type which evaluates to \p x.
    //!
    //! The key difference between this method and
    //! Semigroup::minimal_factorisation(const_reference x), is that the
    //! resulting factorisation may not be minimal.
    //! If \p pos is greater than the size of the semigroup, then a
    //! LIBSEMIGROUPS_EXCEPTION is thrown.
    word_type factorisation(const_reference x) {
      return minimal_factorisation(x);
    }

    //! This method resets Semigroup::next_relation so that when it is next
    //! called the resulting relation is the first one.
    //!
    //! After a call to this function, the next call to
    //! Semigroup::next_relation will return the first relation of the
    //! presentation defining the semigroup.
    void reset_next_relation() noexcept override {
      _relation_pos = UNDEFINED;
      _relation_gen = 0;
    }

    //! This method changes \p relation in-place to contain the next relation
    //! of the presentation defining \c this.
    //!
    //! This method changes \p relation in-place so that one of the following
    //! holds:
    //!
    //! * \p relation is a vector consisting of a libsemigroups::letter_type and
    //! a libsemigroups::letter_type such that Semigroup::gens(\c relation[\c
    //! 0]) == Semigroup::gens(\c relation[\c 1]), i.e. if the semigroup was
    //! defined with duplicate generators;
    //!
    //! * \p relation is a vector consisting of a
    //! libsemigroups::element_index_type, libsemigroups::letter_type, and
    //! libsemigroups::element_index_type such that
    //! \code{.cpp}
    //!   this[relation[0]] * Semigroup::gens(relation[1]) == this[relation[2]]
    //! \endcode
    //!
    //! * \p relation is empty if there are no more relations.
    //!
    //! Semigroup::next_relation is guaranteed to output all relations of
    //! length 2 before any relations of length 3. If called repeatedly after
    //! Semigroup::reset_next_relation, and until relation is empty, the values
    //! placed in \p relation correspond to a length-reducing confluent
    //! rewriting system that defines the semigroup.
    //!
    //! This method can be used in conjunction with Semigroup::factorisation to
    //! obtain a presentation defining the semigroup.
    //!
    //! \sa Semigroup::reset_next_relation.
    void next_relation(word_type& relation) override {
      if (!finished()) {
        enumerate();
      }

      relation.clear();

      if (_relation_pos == _nr) {  // no more relations
        return;
      }

      if (_relation_pos != UNDEFINED) {
        while (_relation_pos < _nr) {
          while (_relation_gen < _nrgens) {
            if (!_reduced.get(_enumerate_order[_relation_pos], _relation_gen)
                && (_relation_pos < _lenindex[1]
                    || _reduced.get(_suffix[_enumerate_order[_relation_pos]],
                                    _relation_gen))) {
              relation.push_back(_enumerate_order[_relation_pos]);
              relation.push_back(_relation_gen);
              relation.push_back(
                  _right.get(_enumerate_order[_relation_pos], _relation_gen));
              break;
            }
            _relation_gen++;
          }
          if (_relation_gen == _nrgens) {  // then relation is empty
            _relation_gen = 0;
            _relation_pos++;
          } else {
            break;
          }
        }
        _relation_gen++;
      } else {
        // duplicate generators
        if (_relation_gen < _duplicate_gens.size()) {
          relation.push_back(_duplicate_gens[_relation_gen].first);
          relation.push_back(_duplicate_gens[_relation_gen].second);
          _relation_gen++;
        } else {
          _relation_gen = 0;
          _relation_pos++;
          next_relation(relation);
        }
      }
    }

    //! Enumerate the semigroup until \p limit elements are found or \p killed
    //! is \c true.
    //!
    //! This is the main method of the Semigroup class, where the
    //! Froidure-Pin Algorithm is implemented.
    //!
    //! If the semigroup is already fully enumerated, or the number of elements
    //! previously enumerated exceeds \p limit, then calling this method does
    //! nothing. Otherwise, enumerate attempts to find at least the maximum of
    //! \p limit and Semigroup::batch_size elements of the semigroup. If \p
    //! killed is set to \c true (usually by another process), then the
    //! enumeration is terminated as soon as possible.  It is possible to
    //! resume enumeration at some later point after any call to this method,
    //! even if it has been killed.
    //!
    //! If the semigroup is fully enumerated, then it knows its left and right
    //! Cayley graphs, and a minimal factorisation of every element (in terms of
    //! its generating set).  All of the elements are stored in memory until the
    //! object is destroyed.
    //!
    //! The parameter \p limit defaults to Semigroup::LIMIT_MAX.
    void enumerate(size_t limit64 = LIMIT_MAX) override {
      run(limit64);
    }

    void run() override {
      run(LIMIT_MAX);
    }

    void run(size_t limit64) {
      std::lock_guard<std::mutex> lg(_mtx);
      if (_pos >= _nr || limit64 <= _nr || stopped()) {
        return;
      }
      // Ensure that limit isn't too big
      size_type limit = static_cast<size_type>(limit64);

      if (LIMIT_MAX - _batch_size > _nr) {
        limit = std::max(limit, _nr + _batch_size);
      } else {  // _batch_size is very big for some reason
        limit = _batch_size;
      }

      REPORT("limit = ", limit);
      Timer  timer;
      size_t tid = REPORTER.thread_id(std::this_thread::get_id());

      // product the generators by every generator
      if (_pos < _lenindex[1]) {
        size_type nr_shorter_elements = _nr;
        while (_pos < _lenindex[1]) {
          element_index_type i = _enumerate_order[_pos];
          for (letter_type j = 0; j != _nrgens; ++j) {
            product()(_tmp_product, _elements[i], _gens[j], tid);
#ifdef LIBSEMIGROUPS_STATS
            _nr_products++;
#endif
            auto it = _map.find(_tmp_product);

            if (it != _map.end()) {
              _right.set(i, j, it->second);
              _nrrules++;
            } else {
              is_one(_tmp_product, _nr);
              _elements.push_back(this->internal_copy(_tmp_product));
              _first.push_back(_first[i]);
              _final.push_back(j);
              _enumerate_order.push_back(_nr);
              _length.push_back(2);
              _map.emplace(_elements.back(), _nr);
              _prefix.push_back(i);
              _reduced.set(i, j, true);
              _right.set(i, j, _nr);
              _suffix.push_back(_letter_to_pos[j]);
              _nr++;
            }
          }
          _pos++;
        }
        for (enumerate_index_type i = 0; i != _pos; ++i) {
          letter_type b = _final[_enumerate_order[i]];
          for (letter_type j = 0; j != _nrgens; ++j) {
            _left.set(_enumerate_order[i], j, _right.get(_letter_to_pos[j], b));
          }
        }
        _wordlen++;
        expand(_nr - nr_shorter_elements);
        _lenindex.push_back(_enumerate_order.size());
      }

      // product the words of length > 1 by every generator
      bool stop = (_nr >= limit || stopped());

      while (_pos != _nr && !stop) {
        size_type nr_shorter_elements = _nr;
        while (_pos != _lenindex[_wordlen + 1] && !stop) {
          element_index_type i = _enumerate_order[_pos];
          letter_type        b = _first[i];
          element_index_type s = _suffix[i];
          for (letter_type j = 0; j != _nrgens; ++j) {
            if (!_reduced.get(s, j)) {
              element_index_type r = _right.get(s, j);
              if (_found_one && r == _pos_one) {
                _right.set(i, j, _letter_to_pos[b]);
              } else if (_prefix[r] != UNDEFINED) {  // r is not a generator
                _right.set(
                    i, j, _right.get(_left.get(_prefix[r], b), _final[r]));
              } else {
                _right.set(i, j, _right.get(_letter_to_pos[b], _final[r]));
              }
            } else {
              product()(_tmp_product, _elements[i], _gens[j], tid);
#ifdef LIBSEMIGROUPS_STATS
              _nr_products++;
#endif
              auto it = _map.find(_tmp_product);

              if (it != _map.end()) {
                _right.set(i, j, it->second);
                _nrrules++;
              } else {
                is_one(_tmp_product, _nr);
                _elements.push_back(this->internal_copy(_tmp_product));
                _first.push_back(b);
                _final.push_back(j);
                _length.push_back(_wordlen + 2);
                _map.emplace(_elements.back(), _nr);
                _prefix.push_back(i);
                _reduced.set(i, j, true);
                _right.set(i, j, _nr);
                _suffix.push_back(_right.get(s, j));
                _enumerate_order.push_back(_nr);
                _nr++;
                stop = (_nr >= limit || stopped());
              }
            }
          }  // finished applying gens to <_elements.at(_pos)>
          _pos++;
        }  // finished words of length <wordlen> + 1
        expand(_nr - nr_shorter_elements);

        if (_pos > _nr || _pos == _lenindex[_wordlen + 1]) {
          for (enumerate_index_type i = _lenindex[_wordlen]; i != _pos; ++i) {
            element_index_type p = _prefix[_enumerate_order[i]];
            letter_type        b = _final[_enumerate_order[i]];
            for (letter_type j = 0; j != _nrgens; ++j) {
              _left.set(_enumerate_order[i], j, _right.get(_left.get(p, j), b));
            }
          }
          _wordlen++;
          _lenindex.push_back(_enumerate_order.size());
        }
        REPORT("found ",
               _nr,
               " elements, ",
               _nrrules,
               " rules, max word length ",
               current_max_word_length());
      }
      REPORT("elapsed time = ", timer);
      report_why_we_stopped();
#ifdef LIBSEMIGROUPS_STATS
      REPORT("number of products = ", _nr_products);
#endif
    }

    //! Add copies of the generators \p coll to the generators of \c this.
    //!
    //! This method can be used to add new generators to the existing semigroup
    //! in such a way that any previously enumerated data is preserved and not
    //! recomputed, or copied. This can be faster than recomputing the semigroup
    //! generated by the old generators and the new generators in the parameter
    //! \p coll.
    //!
    //! This method changes the semigroup in-place, thereby invalidating
    //! possibly previously known data about the semigroup, such as the left or
    //! right Cayley graphs, number of idempotents, and so on.
    //!
    //! Every generator in \p coll is added regardless of whether or not it is
    //! already a generator or element of the semigroup (it may belong to the
    //! semigroup but just not be known to belong). If \p coll is empty, then
    //! the semigroup is left unchanged. The order the generators is added is
    //! also the order they occur in the parameter \p coll.
    //!
    //! The semigroup is returned in a state where all of the previously
    //! enumerated elements which had been multiplied by all of the old
    //! generators, have now been multiplied by all of the old and new
    //! generators. This means that after this method is called the semigroup
    //! might contain many more elements than before (whether it is fully
    //! enumerating or not).  It can also be the case that the new generators
    //! are the only new elements, unlike, say, in the case of non-trivial
    //! groups.
    //!
    //! The elements of the argument \p coll are copied into the semigroup, and
    //! should be deleted by the caller.
    //! If an element in \p coll has a degree different to \c this->degree(), a
    //! LIBSEMIGROUPS_EXCEPTION will be thrown.

    void add_generator(element_type const& x) {
      add_generators({x});
    }

    template <class TCollection> void add_generators(TCollection const& coll) {
      static_assert(!std::is_pointer<TCollection>::value,
                    "TCollection should not be a pointer");
      if (coll.size() == 0) {
        return;
      }
      for (auto it = coll.begin(); it < coll.end(); ++it) {
        element_index_type degree
            = internal_degree()(this->to_internal_const(*it));
        if (degree != _degree) {
          throw LIBSEMIGROUPS_EXCEPTION(
              "new generator " + to_string(it - coll.begin()) + " has degree "
              + to_string(degree) + " but should have degree "
              + to_string(_degree));
        }
      }
      Timer  timer;
      size_t tid = REPORTER.thread_id(std::this_thread::get_id());

      // get some parameters from the old semigroup
      letter_type old_nrgens  = _nrgens;
      size_type   old_nr      = _nr;
      size_type   nr_old_left = _pos;

      // erase the old index
      _enumerate_order.erase(_enumerate_order.begin() + _lenindex[1],
                             _enumerate_order.end());

      // old_new[i] indicates if we have seen _elements.at(i) yet in new.
      std::vector<bool> old_new;
      old_new.clear();
      old_new.resize(old_nr, false);
      for (letter_type i = 0; i < _letter_to_pos.size(); i++) {
        old_new[_letter_to_pos[i]] = true;
      }

      // add the new generators to new _gens, _elements, and _enumerate_order
      for (const_reference x : coll) {
        auto it = _map.find(this->to_internal_const(x));
        if (it == _map.end()) {  // new generator
          _gens.push_back(this->internal_copy(this->to_internal_const(x)));
          _elements.push_back(_gens.back());
          _map.emplace(_gens.back(), _nr);

          _first.push_back(_gens.size() - 1);
          _final.push_back(_gens.size() - 1);

          _letter_to_pos.push_back(_nr);
          _enumerate_order.push_back(_nr);

          is_one(this->to_internal_const(x), _nr);
          _prefix.push_back(UNDEFINED);
          _suffix.push_back(UNDEFINED);
          _length.push_back(1);
          _nr++;
        } else if (_letter_to_pos[_first[it->second]] == it->second) {
          _gens.push_back(this->internal_copy(this->to_internal_const(x)));
          // x is one of the existing generators
          _duplicate_gens.push_back(
              std::make_pair(_gens.size() - 1, _first[it->second]));
          // _gens[_gens.size() - 1] = _gens[_first[it->second])]
          // since _first maps element_index_type -> letter_type
          _letter_to_pos.push_back(it->second);
        } else {
          // x is an old element that will now be a generator
          _gens.push_back(_elements[it->second]);
          _letter_to_pos.push_back(it->second);
          _enumerate_order.push_back(it->second);

          _first[it->second]  = _gens.size() - 1;
          _final[it->second]  = _gens.size() - 1;
          _prefix[it->second] = UNDEFINED;
          _suffix[it->second] = UNDEFINED;
          _length[it->second] = UNDEFINED;

          old_new[it->second] = true;
        }
      }

      // reset the data structure
      _idempotents_found = false;
      _nrrules           = _duplicate_gens.size();
      _pos               = 0;
      _wordlen           = 0;
      _nrgens            = _gens.size();
      _lenindex.clear();
      _lenindex.push_back(0);
      _lenindex.push_back(_nrgens - _duplicate_gens.size());

      // Add columns for new generators
      // FIXME isn't this a bit wasteful, we could recycle the old _reduced, to
      // avoid reallocation
      _reduced
          = RecVec<bool>(_nrgens, _reduced.nr_rows() + _nrgens - old_nrgens);
      _left.add_cols(_nrgens - _left.nr_cols());
      _right.add_cols(_nrgens - _right.nr_cols());

      // Add rows in for newly added generators
      _left.add_rows(_nrgens - old_nrgens);
      _right.add_rows(_nrgens - old_nrgens);

      size_type nr_shorter_elements;

      // Repeat until we have multiplied all of the elements of <old> up to the
      // old value of _pos by all of the (new and old) generators

      while (nr_old_left > 0) {
        nr_shorter_elements = _nr;
        while (_pos < _lenindex[_wordlen + 1] && nr_old_left > 0) {
          element_index_type i
              = _enumerate_order[_pos];  // position in _elements
          letter_type        b = _first[i];
          element_index_type s = _suffix[i];
          if (_right.get(i, 0) != UNDEFINED) {
            nr_old_left--;
            // _elements[i] is in old semigroup, and its descendants are
            // known
            for (letter_type j = 0; j < old_nrgens; j++) {
              element_index_type k = _right.get(i, j);
              if (!old_new[k]) {  // it's new!
                is_one(_elements[k], k);
                _first[k]  = _first[i];
                _final[k]  = j;
                _length[k] = _wordlen + 2;
                _prefix[k] = i;
                _reduced.set(i, j, true);
                if (_wordlen == 0) {
                  _suffix[k] = _letter_to_pos[j];
                } else {
                  _suffix[k] = _right.get(s, j);
                }
                _enumerate_order.push_back(k);
                old_new[k] = true;
              } else if (s == UNDEFINED || _reduced.get(s, j)) {
                // this clause could be removed if _nrrules wasn't necessary
                _nrrules++;
              }
            }
            for (letter_type j = old_nrgens; j < _nrgens; j++) {
              closure_update(i, j, b, s, old_nr, tid, old_new);
            }
          } else {
            // _elements[i] is either not in old, or it is in old but its
            // descendants are not known
            for (letter_type j = 0; j < _nrgens; j++) {
              closure_update(i, j, b, s, old_nr, tid, old_new);
            }
          }
          _pos++;
        }  // finished words of length <wordlen> + 1

        expand(_nr - nr_shorter_elements);
        if (_pos > _nr || _pos == _lenindex[_wordlen + 1]) {
          if (_wordlen == 0) {
            for (enumerate_index_type i = 0; i < _pos; i++) {
              size_t b = _final[_enumerate_order[i]];
              for (letter_type j = 0; j < _nrgens; j++) {
                // TODO(JDM) reuse old info here!
                _left.set(
                    _enumerate_order[i], j, _right.get(_letter_to_pos[j], b));
              }
            }
          } else {
            for (enumerate_index_type i = _lenindex[_wordlen]; i < _pos; i++) {
              element_index_type p = _prefix[_enumerate_order[i]];
              letter_type        b = _final[_enumerate_order[i]];
              for (letter_type j = 0; j < _nrgens; j++) {
                // TODO(JDM) reuse old info here!
                _left.set(
                    _enumerate_order[i], j, _right.get(_left.get(p, j), b));
              }
            }
          }
          _lenindex.push_back(_enumerate_order.size());
          _wordlen++;
        }
        REPORT("found ",
               _nr,
               " elements, ",
               _nrrules,
               " rules, max word length ",
               current_max_word_length());
      }
      if (is_begun()) {
        REPORT("elapsed time = ", timer);
      }
      report_why_we_stopped();
    }

    //! Add copies of the generators \p coll to the generators of \c this.
    //!
    //! See Semigroup::add_generators for more details.
    void add_generators(std::initializer_list<const_element_type> coll) {
      add_generators<std::initializer_list<const_element_type>>(coll);
    }

    //! Returns a new semigroup generated by \c this and \p coll.
    //!
    //! This method is equivalent to copying \c this using
    //! Semigroup::Semigroup(const Semigroup& copy) and then calling
    //! Semigroup::add_generators on the copy, but this method avoids copying
    //! the parts of \c this that are immediately invalidated by
    //! Semigroup::add_generators.
    //!
    //! The elements the argument \p coll are copied into the semigroup, and
    //! should be deleted by the caller.
    //! If an element in \p coll has a degree different to \c this->degree(), a
    //! LIBSEMIGROUPS_EXCEPTION will be thrown.
    template <class TCollection>
    Semigroup* copy_add_generators(TCollection const& coll) const {
      static_assert(!std::is_pointer<TCollection>::value,
                    "TCollection should not be a pointer");
      if (coll.size() == 0) {
        return new Semigroup(*this);
      } else {
        // Partially copy
        Semigroup* out = new Semigroup(*this, &coll);
        out->add_generators(coll);
        return out;
      }
    }

    //! Add copies of the non-redundant generators in \p coll to the generators
    //! of \c this.
    //!
    //! This method can be used to add new generators to an existing semigroup
    //! in such a way that any previously enumerated data is preserved and not
    //! recomputed, or copied. This can be faster than recomputing the semigroup
    //! generated by the old generators and the new in \p coll.
    //!
    //! This method differs from Semigroup::add_generators in that it tries to
    //! add the new generators one by one, and only adds those generators that
    //! are not products of existing generators (including any new generators
    //! from \p coll that were added before). The generators are added in the
    //! order they occur in \p coll.
    //!
    //! This method changes the semigroup in-place, thereby
    //! invalidating possibly previously known data about the semigroup, such as
    //! the left or right Cayley graphs, or number of idempotents, for example.
    //!
    //! The elements the parameter \p coll are copied into the semigroup, and
    //! should be deleted by the caller.
    //! If an element in \p coll has a degree different to \c this->degree(), a
    //! LIBSEMIGROUPS_EXCEPTION will be thrown.
    template <class TCollection> void closure(TCollection const& coll) {
      static_assert(!std::is_pointer<TCollection>::value,
                    "TCollection should not be a pointer");
      if (coll.size() == 0) {
        return;
      } else {
        for (const_reference x : coll) {
          if (!test_membership(x)) {
            add_generators({x});
          }
        }
      }
    }

    //! Add copies of the non-redundant generators in \p coll to the
    //! generators of \c this.
    //!
    //! See Semigroup::closure for more details.
    void closure(std::initializer_list<const_element_type> coll) {
      closure<std::initializer_list<const_element_type>>(coll);
    }

    //! Returns a new semigroup generated by \c this and copies of the
    //! non-redundant elements of \p coll.
    //!
    //! This method is equivalent to copying \c this and then calling
    //! Semigroup::closure on the copy with \p coll, but this method avoids
    //! copying the parts of \c this that are immediately invalidated by
    //! Semigroup::closure.
    //!
    //! The elements the argument \p coll are copied into the semigroup, and
    //! should be deleted by the caller.
    //! If an element in \p coll has a degree different to \c this->degree(), a
    //! LIBSEMIGROUPS_EXCEPTION will be thrown.
    template <class TCollection>
    Semigroup* copy_closure(TCollection const& coll) {
      static_assert(!std::is_pointer<TCollection>::value,
                    "TCollection should not be a pointer");
      if (coll.size() == 0) {
        return new Semigroup(*this);
      } else {
        // The next line is required so that when we call the closure method on
        // out, the partial copy contains enough information to all membership
        // testing without a call to enumerate (which will fail because the
        // partial copy does not contain enough data to run enumerate).
        this->enumerate(LIMIT_MAX);
        // Partially copy
        Semigroup* out = new Semigroup(*this, &coll);
        out->closure(coll);
        return out;
      }
    }

    //! Set the maximum number of threads that any method of an instance of
    //! Semigroup can use.
    //!
    //! This method sets the maximum number of threads to be used by any method
    //! of a Semigroup object. The number of threads is limited to the maximum
    //! of 1 and the minimum of \p nr_threads and the number of threads
    //! supported by the hardware.
    void set_max_threads(size_t nr_threads) noexcept override {
      // TODO check noexcept is ok
      unsigned int n
          = static_cast<unsigned int>(nr_threads == 0 ? 1 : nr_threads);
      _max_threads = std::min(n, std::thread::hardware_concurrency());
    }

   private:
    // The class iterator_base provides a base class for random access
    // iterators that wrap an iterator to a vector of TWrappedItemType. The
    // template parameter TMethodsType must provide two methods:
    // 1. indirection - returning a Semigroup::const_reference to a
    //    Semigroup::element_type for use by the operator* method of
    //    iterator_base;
    // 2. addressof - returning a pointer to const Semigroup::element_type for
    //    use by the operator& method of iterator_base.
    template <typename TWrappedItemType, class TMethodsType>
    class iterator_base {
     public:
      using size_type = typename std::vector<element_type>::size_type;
      using difference_type =
          typename std::vector<element_type>::difference_type;
      using value_type = element_type;
      using reference  = const_reference;
      using pointer    = typename std::vector<element_type>::const_pointer;
      using iterator_category = std::random_access_iterator_tag;

      explicit iterator_base(
          typename std::vector<TWrappedItemType>::const_iterator it_vec)
          : _it_vec(it_vec) {}

      iterator_base(iterator_base const& that) : iterator_base(that._it_vec) {}

      iterator_base& operator=(iterator_base const& that) {
        _it_vec = that._it_vec;
        return *this;
      }

      virtual ~iterator_base() {}

      bool operator==(iterator_base const& that) const {
        return _it_vec == that._it_vec;
      }

      bool operator!=(iterator_base const& that) const {
        return _it_vec != that._it_vec;
      }

      bool operator<(iterator_base const& that) const {
        return _it_vec < that._it_vec;
      }

      bool operator>(iterator_base const& that) const {
        return _it_vec > that._it_vec;
      }

      bool operator<=(iterator_base const& that) const {
        return operator<(that) || operator==(that);
      }

      bool operator>=(iterator_base const& that) const {
        return operator>(that) || operator==(that);
      }

      // postfix
      iterator_base operator++(int) {
        iterator_base  tmp(*this);
        iterator_base::operator++();
        return tmp;
      }

      iterator_base operator--(int) {
        iterator_base  tmp(*this);
        iterator_base::operator--();
        return tmp;
      }

      iterator_base operator+(size_type val) const {
        iterator_base out(*this);
        return out += val;
      }

      friend iterator_base operator+(size_type val, iterator_base const& it) {
        return it + val;
      }

      iterator_base operator-(size_type val) const {
        iterator_base out(*this);
        return out -= val;
      }

      const_reference operator[](size_type pos) const {
        return *(*this + pos);
      }

      iterator_base& operator++() {  // prefix
        ++_it_vec;
        return *this;
      }

      iterator_base& operator--() {
        --_it_vec;
        return *this;
      }

      iterator_base& operator+=(size_type val) {
        _it_vec += val;
        return *this;
      }

      iterator_base& operator-=(size_type val) {
        _it_vec -= val;
        return *this;
      }

      difference_type operator-(iterator_base that) const {
        return _it_vec - that._it_vec;
      }

      const_reference operator*() const {
        return TMethodsType().indirection(_it_vec);
      }

      pointer operator->() const {
        return TMethodsType().addressof(_it_vec);
      }

     protected:
      typename std::vector<TWrappedItemType>::const_iterator _it_vec;
    };  // iterator_base definition ends

    struct iterator_methods : private TTraits {
      using wrapped_iterator =
          typename std::vector<internal_element_type>::const_iterator;

      const_reference indirection(wrapped_iterator it) const {
        return this->to_external_const(*it);
      }

      typename std::vector<element_type>::const_pointer
      addressof(wrapped_iterator it) const {
        return &(this->to_external_const(*it));
      }
    };

    struct iterator_methods_pair_first : private TTraits {
      using wrapped_iterator = typename std::vector<
          std::pair<internal_element_type, element_index_type>>::const_iterator;

      const_reference indirection(wrapped_iterator it) const {
        return this->to_external_const((*it).first);
      }

      typename std::vector<element_type>::const_pointer
      addressof(wrapped_iterator it) const {
        return &(this->to_external_const((*it).first));
      }
    };

    // A type for const iterators through (element, index) pairs of \c this.
    using const_iterator_pair_first
        = iterator_base<std::pair<internal_element_type, element_index_type>,
                        iterator_methods_pair_first>;

    // A type for const reverse iterators through (element, index) pairs of \c
    // this.
    using const_reverse_iterator_pair_first
        = std::reverse_iterator<const_iterator_pair_first>;

   public:
    //! A type for const iterators through the elements of \c this, in the
    //! order they were enumerated (i.e. in short-lex order of the minimum word
    //! in the generators of \c this equal to any given element).
    //!
    //! \sa const_reverse_iterator.
    using const_iterator
        = iterator_base<internal_element_type, iterator_methods>;

    //! A type for const reverse iterators through the elements of \c this, in
    //! the reverse order of enumeration.
    //!
    //! \sa const_iterator.
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    //! A type for const iterators through the elements of \c this, sorted
    //! according to TTraits::less.
    //!
    //! \sa const_reverse_iterator_sorted.
    using const_iterator_sorted = const_iterator_pair_first;

    //! A type for const reverse iterators through the elements of \c this,
    //! sorted according to TTraits::less.
    //!
    //! \sa const_iterator_sorted.
    using const_reverse_iterator_sorted = const_reverse_iterator_pair_first;

    //! A type for const iterators through the idempotents of \c this, in
    //! short-lex order.
    //!
    //! \sa const_iterator.
    using const_iterator_idempotents = const_iterator_pair_first;

    //! A type for reverse const iterators through the idempotents of \c this,
    //! in short-lex order.
    //!
    //! \sa const_iterator_idempotents.
    using const_reverse_iterator_idempotents
        = const_reverse_iterator_pair_first;

    //! Returns a const iterator pointing to the first element of the
    //! semigroup.
    //!
    //! This method does not perform any enumeration of the semigroup, the
    //! iterator returned may be invalidated by any call to a non-const method
    //! of the Semigroup class.
    const_iterator cbegin() const {
      return const_iterator(_elements.cbegin());
    }

    //! Returns a const iterator pointing to the first element of the
    //! semigroup.
    //!
    //! This method does not perform any enumeration of the semigroup, the
    //! iterator returned may be invalidated by any call to a non-const method
    //! of the Semigroup class.
    const_iterator begin() const {
      return cbegin();
    }

    //! Returns a const iterator pointing to one past the last currently known
    //! element of the semigroup.
    //!
    //! This method does not perform any enumeration of the semigroup, the
    //! iterator returned may be invalidated by any call to a non-const method
    //! of the Semigroup class.
    const_iterator cend() const {
      return const_iterator(_elements.cend());
    }

    //! Returns a const iterator pointing to one past the last currently known
    //! element of the semigroup.
    //!
    //! This method does not perform any enumeration of the semigroup, the
    //! iterator returned may be invalidated by any call to a non-const method
    //! of the Semigroup class.
    const_iterator end() const {
      return cend();
    }

    //! Returns a const reverse iterator pointing to the last currently known
    //! element of the semigroup.
    //!
    //! This method does not perform any enumeration of the semigroup, the
    //! iterator returned may be invalidated by any call to a non-const method
    //! of the Semigroup class.
    const_reverse_iterator crbegin() const {
      return const_reverse_iterator(cend());
    }

    //! Returns a const reverse iterator pointing to one before the first
    //! element of the semigroup.
    //!
    //! This method does not perform any enumeration of the semigroup, the
    //! iterator returned may be invalidated by any call to a non-const method
    //! of the Semigroup class.
    const_reverse_iterator crend() const {
      return const_reverse_iterator(cbegin());
    }

    //! Returns a const iterator pointing to the first element of the semigroup
    //! when the elements are sorted by Element::operator<.
    //!
    //! This method fully enumerates the semigroup, the returned iterator
    //! returned may be invalidated by any call to a non-const method of the
    //! Semigroup class.
    const_iterator_sorted cbegin_sorted() {
      init_sorted();
      return const_iterator_pair_first(_sorted.cbegin());
    }

    //! Returns a const iterator pointing to one past the last element of the
    //! semigroup when the elements are sorted by Element::operator<.
    //!
    //! This method fully enumerates the semigroup, the returned iterator
    //! returned may be invalidated by any call to a non-const method of the
    //! Semigroup class.
    const_iterator_sorted cend_sorted() {
      init_sorted();
      return const_iterator_pair_first(_sorted.cend());
    }

    //! Returns a const iterator pointing to the last element of the semigroup
    //! when the elements are sorted by Element::operator<.
    //!
    //! This method fully enumerates the semigroup, the returned iterator
    //! returned may be invalidated by any call to a non-const method of the
    //! Semigroup class.
    const_reverse_iterator_sorted crbegin_sorted() {
      init_sorted();
      return const_reverse_iterator_pair_first(cend_sorted());
    }

    //! Returns a const iterator pointing to one before the first element of
    //! the semigroup when the elements are sorted by Element::operator<.
    //!
    //! This method fully enumerates the semigroup, the returned iterator
    //! returned may be invalidated by any call to a non-const method of the
    //! Semigroup class.
    const_reverse_iterator_sorted crend_sorted() {
      init_sorted();
      return const_reverse_iterator_pair_first(cbegin_sorted());
    }

    //! Returns a const iterator pointing at the first idempotent in the
    //! semigroup.
    //!
    //! If the returned iterator is incremented, then it points to the second
    //! idempotent in the semigroup (if it exists), and every subsequent
    //! increment points to the next idempotent.
    //!
    //! This method involves fully enumerating the semigroup, if it is not
    //! already fully enumerated.
    const_iterator_idempotents cbegin_idempotents() {
      init_idempotents();
      return const_iterator_pair_first(_idempotents.cbegin());
    }

    //! Returns a const iterator referring to past the end of the last
    //! idempotent in the semigroup.
    //!
    //! This method involves fully enumerating the semigroup, if it is not
    //! already fully enumerated.
    const_iterator_idempotents cend_idempotents() {
      init_idempotents();
      return const_iterator_pair_first(_idempotents.cend());
    }

   private:
    // Expand the data structures in the semigroup with space for nr elements
    void inline expand(size_type nr) {
      _left.add_rows(nr);
      _reduced.add_rows(nr);
      _right.add_rows(nr);
    }

    // Check if an element is the identity, x should be in the position pos
    // of _elements.
    // FIXME noexcept should depend on whether or not internal_equal_to throws.
    void inline is_one(internal_const_element_type x,
                       element_index_type          pos) noexcept {
      if (!_found_one && internal_equal_to()(x, _id)) {
        _pos_one   = pos;
        _found_one = true;
      }
    }

    // _nrgens, _duplicates_gens, _letter_to_pos, and _elements must all be
    // initialised for this to work, and _gens must point to an empty vector.
    void copy_gens() {
      LIBSEMIGROUPS_ASSERT(_gens.empty());
      _gens.resize(_nrgens);
      std::vector<bool> seen(_nrgens, false);
      // really copy duplicate gens from _elements
      for (std::pair<letter_type, letter_type> const& x : _duplicate_gens) {
        // The degree of everything in _elements has already been increased (if
        // it needs to be at all), and so we do not need to increase the degree
        // in the copy below.
        _gens[x.first]
            = this->internal_copy(_elements[_letter_to_pos[x.second]]);
        seen[x.first] = true;
      }
      // the non-duplicate gens are already in _elements, so don't really copy
      for (letter_type i = 0; i < _nrgens; i++) {
        if (!seen[i]) {
          _gens[i] = _elements[_letter_to_pos[i]];
        }
      }
    }

    void inline closure_update(element_index_type i,
                               letter_type        j,
                               letter_type        b,
                               element_index_type s,
                               size_type          old_nr,
                               size_t const&      tid,
                               std::vector<bool>& old_new) {
      if (_wordlen != 0 && !_reduced.get(s, j)) {
        element_index_type r = _right.get(s, j);
        if (_found_one && r == _pos_one) {
          _right.set(i, j, _letter_to_pos[b]);
        } else if (_prefix[r] != UNDEFINED) {
          _right.set(i, j, _right.get(_left.get(_prefix[r], b), _final[r]));
        } else {
          _right.set(i, j, _right.get(_letter_to_pos[b], _final[r]));
        }
      } else {
        product()(_tmp_product, _elements[i], _gens[j], tid);
        auto it = _map.find(_tmp_product);
        if (it == _map.end()) {  // it's new!
          is_one(_tmp_product, _nr);
          _elements.push_back(this->internal_copy(_tmp_product));
          _first.push_back(b);
          _final.push_back(j);
          _length.push_back(_wordlen + 2);
          _map.emplace(_elements.back(), _nr);
          _prefix.push_back(i);
          _reduced.set(i, j, true);
          _right.set(i, j, _nr);
          if (_wordlen == 0) {
            _suffix.push_back(_letter_to_pos[j]);
          } else {
            _suffix.push_back(_right.get(s, j));
          }
          _enumerate_order.push_back(_nr);
          _nr++;
        } else if (it->second < old_nr && !old_new[it->second]) {
          // we didn't process it yet!
          is_one(_tmp_product, it->second);
          _first[it->second]  = b;
          _final[it->second]  = j;
          _length[it->second] = _wordlen + 2;
          _prefix[it->second] = i;
          _reduced.set(i, j, true);
          _right.set(i, j, it->second);
          if (_wordlen == 0) {
            _suffix[it->second] = _letter_to_pos[j];
          } else {
            _suffix[it->second] = _right.get(s, j);
          }
          _enumerate_order.push_back(it->second);
          old_new[it->second] = true;
        } else {  // it->second >= old->_nr || old_new[it->second]
          // it's old
          _right.set(i, j, it->second);
          _nrrules++;
        }
      }
    }

    // Initialise the data member _sorted. We store a list of pairs consisting
    // of an internal_element_type and element_index_type which is sorted on the
    // first entry using the operator< of the Element class. The second
    // component is then inverted (as a permutation) so that we can then find
    // the position of an element in the sorted list of elements.
    void init_sorted() {
      if (_sorted.size() == size()) {
        return;
      }
      size_t n = size();
      _sorted.reserve(n);
      for (element_index_type i = 0; i < n; i++) {
        _sorted.emplace_back(_elements[i], i);
      }
      std::sort(
          _sorted.begin(),
          _sorted.end(),
          [](std::pair<internal_element_type, element_index_type> const& x,
             std::pair<internal_element_type, element_index_type> const& y)
              -> bool { return less()(x.first, y.first); });

      // Invert the permutation in _sorted[*].second
      std::vector<element_index_type> tmp_inverter;
      tmp_inverter.resize(n);
      for (element_index_type i = 0; i < n; i++) {
        tmp_inverter[_sorted[i].second] = i;
      }
      for (element_index_type i = 0; i < n; i++) {
        _sorted[i].second = tmp_inverter[i];
      }
    }

    using internal_idempotent_pair
        = std::pair<internal_element_type, element_index_type>;

    // Find the idempotents and store their pointers and positions in a
    // std::pair of type internal_idempotent_pair.
    void init_idempotents() {
      if (_idempotents_found) {
        return;
      }
      _idempotents_found = true;
      enumerate();
      _is_idempotent.resize(_nr, false);

      Timer timer;

      // Find the threshold beyond which it is quicker to simply product
      // elements rather than follow a path in the Cayley graph. This is the
      // enumerate_index_type i for which length(i) >= 2 * complexity.
      size_t comp             = std::max(complexity()(_tmp_product), size_t(1));
      size_t threshold_length = std::min(_lenindex.size() - 2, comp - 1);
      enumerate_index_type threshold_index = _lenindex[threshold_length];

      size_t total_load = 0;
      for (size_t i = 1; i <= threshold_length; ++i) {
        total_load += i * (_lenindex[i] - _lenindex[i - 1]);
      }

#ifdef LIBSEMIGROUPS_STATS
      REPORT("complexity of multiplication = ", comp);
      REPORT("multiple words longer than ", threshold_length + 1);
      REPORT("number of paths traced in Cayley graph = ", threshold_index);
      REPORT("mean path length = ", total_load / threshold_index);
      REPORT("number of products = ", _nr - threshold_index);
#endif

      total_load
          += comp
             * (_nr
                - (threshold_length == 0 ? 0
                                         : _lenindex[threshold_length - 1]));

      size_t concurrency_threshold = 823543;

      if (_max_threads == 1 || size() < concurrency_threshold) {
        // Use only 1 thread
        idempotents(0, _nr, threshold_index, _idempotents);
      } else {
        // Use > 1 threads
        size_t                            mean_load = total_load / _max_threads;
        size_t                            len       = 1;
        std::vector<enumerate_index_type> first(_max_threads, 0);
        std::vector<enumerate_index_type> last(_max_threads, _nr);
        std::vector<std::vector<internal_idempotent_pair>> tmp(
            _max_threads, std::vector<internal_idempotent_pair>());
        std::vector<std::thread> threads;
        REPORTER.reset_thread_ids();

        for (size_t i = 0; i < _max_threads - 1; i++) {
          size_t thread_load = 0;
          last[i]            = first[i];
          while (thread_load < mean_load && last[i] < threshold_index) {
            if (last[i] >= _lenindex[len]) {
              ++len;
            }
            thread_load += len;
            ++last[i];
          }
          while (thread_load < mean_load) {
            thread_load += comp;
            ++last[i];
          }
          total_load -= thread_load;
          REPORT("thread ", i + 1, " has load ", thread_load);
          first[i + 1] = last[i];

          threads.emplace_back(&Semigroup::idempotents,
                               this,
                               first[i],
                               last[i],
                               threshold_index,
                               std::ref(tmp[i]));
        }
        // TODO use less threads if the av_load is too low

        REPORT("thread ", _max_threads, " has load ", total_load);
        threads.emplace_back(&Semigroup::idempotents,
                             this,
                             first[_max_threads - 1],
                             last[_max_threads - 1],
                             threshold_index,
                             std::ref(tmp[_max_threads - 1]));

        size_t nridempotents = 0;
        for (size_t i = 0; i < _max_threads; i++) {
          threads[i].join();
          nridempotents += tmp[i].size();
        }
        _idempotents.reserve(nridempotents);
        for (size_t i = 0; i < _max_threads; i++) {
          std::copy(
              tmp[i].begin(), tmp[i].end(), std::back_inserter(_idempotents));
        }
      }
      REPORT("elapsed time = ", timer);
    }

    // Find the idempotents in the range [first, last) and store
    // the corresponding std::pair of type internal_idempotent_pair in the 4th
    // parameter. The parameter threshold is the point, calculated in
    // init_idempotents, at which it is better to simply product elements
    // rather than trace in the left/right Cayley graph.
    void idempotents(enumerate_index_type const             first,
                     enumerate_index_type const             last,
                     enumerate_index_type const             threshold,
                     std::vector<internal_idempotent_pair>& idempotents) {
      REPORT("first = ", first, ", last = ", last, ", diff = ", last - first);
      Timer timer;

      enumerate_index_type pos = first;

      for (; pos < std::min(threshold, last); pos++) {
        element_index_type k = _enumerate_order[pos];
        if (!_is_idempotent[k]) {
          // The following is product_by_reduction, don't have to consider
          // lengths because they are equal!!
          element_index_type i = k, j = k;
          while (j != UNDEFINED) {
            i = _right.get(i, _first[j]);
            // TODO improve this if R/L-classes are known to stop performing the
            // product if we fall out of the R/L-class of the initial element.
            j = _suffix[j];
          }
          if (i == k) {
            idempotents.emplace_back(_elements[k], k);
            _is_idempotent[k] = true;
          }
        }
      }

      if (pos >= last) {
        REPORT("elapsed time = ", timer);
        return;
      }

      // Cannot use _tmp_product itself since there are multiple threads here!
      internal_element_type tmp_product = this->internal_copy(_tmp_product);
      size_t tid = REPORTER.thread_id(std::this_thread::get_id());

      for (; pos < last; pos++) {
        element_index_type k = _enumerate_order[pos];
        if (!_is_idempotent[k]) {
          product()(tmp_product, _elements[k], _elements[k], tid);
          if (internal_equal_to()(tmp_product, _elements[k])) {
            idempotents.emplace_back(_elements[k], k);
            _is_idempotent[k] = true;
          }
        }
      }
      this->internal_free(tmp_product);
      REPORT("elapsed time = ", timer);
    }

    size_t                                           _batch_size;
    size_t                                           _degree;
    std::vector<std::pair<letter_type, letter_type>> _duplicate_gens;
    std::vector<internal_element_type>               _elements;
    std::vector<element_index_type>                  _enumerate_order;
    std::vector<letter_type>                         _final;
    std::vector<letter_type>                         _first;
    bool                                             _found_one;
    std::vector<internal_element_type>               _gens;
    internal_element_type                            _id;
    std::vector<internal_idempotent_pair>            _idempotents;
    bool                                             _idempotents_found;
    std::vector<bool>                                _is_idempotent;
    cayley_graph_type                                _left;
    std::vector<size_type>                           _length;
    std::vector<enumerate_index_type>                _lenindex;
    std::vector<element_index_type>                  _letter_to_pos;
#ifdef LIBSEMIGROUPS_DENSEHASHMAP
    google::dense_hash_map<internal_const_element_type,
                           element_index_type,
                           internal_hash,
                           internal_equal_to>
        _map;
#else
    std::unordered_map<internal_const_element_type,
                       element_index_type,
                       internal_hash,
                       internal_equal_to>
        _map;
#endif
    size_t                          _max_threads;
    mutable std::mutex              _mtx;
    size_type                       _nr;
    letter_type                     _nrgens;
    size_t                          _nrrules;
    enumerate_index_type            _pos;
    element_index_type              _pos_one;
    std::vector<element_index_type> _prefix;
    RecVec<bool>                    _reduced;
    letter_type                     _relation_gen;
    enumerate_index_type            _relation_pos;
    cayley_graph_type               _right;
    std::vector<std::pair<internal_element_type, element_index_type>> _sorted;
    std::vector<element_index_type>                                   _suffix;
    mutable internal_element_type _tmp_product;
    size_t                        _wordlen;

#ifdef LIBSEMIGROUPS_STATS
    size_t _nr_products;
#endif
  };
}  // namespace libsemigroups

#endif  // LIBSEMIGROUPS_INCLUDE_SEMIGROUP_H_
