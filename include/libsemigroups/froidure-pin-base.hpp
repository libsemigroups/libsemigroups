//
// libsemigroups - C++ library for semigroups and monoids
// Copyright (C) 2019-2024 James D. Mitchell
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

#ifndef LIBSEMIGROUPS_FROIDURE_PIN_BASE_HPP_
#define LIBSEMIGROUPS_FROIDURE_PIN_BASE_HPP_

#include <array>             // for array
#include <cstddef>           // for size_t
#include <cstdint>           // for uint32_t
#include <initializer_list>  // for initializer_list
#include <iterator>          // for forward_iterator_tag
#include <utility>           // for swap
#include <vector>            // for vector, allocator

#include "constants.hpp"   // for UNDEFINED
#include "ranges.hpp"      // for iterator_range
#include "runner.hpp"      // for Runner
#include "types.hpp"       // for word_type, generator_index_type, tril
#include "word-graph.hpp"  // for WordGraph

#include "detail/containers.hpp"  // for DynamicArray2

namespace libsemigroups {
  //! \defgroup froidure_pin_group Froidure-Pin
  //!
  //! This page contains documentation related to the implementation of the
  //! Froidure-Pin algorithm \cite Froidure1997aa in ``libsemigroups``.
  //!
  //! The purpose of the Froidure-Pin algorithm is to determine the elements
  //! and structure of a semigroup or monoid generated by a set of generators
  //! whose multiplication and comparison for equality is decidable (such as
  //! matrices, transformations, and so on.)

  //! \ingroup froidure_pin_group
  //!
  //! \brief Base class for FroidurePin containing non-element specific data
  //! and member functions.
  //!
  //! Defined in ``froidure-pin-base.hpp``.
  //!
  //! FroidurePinBase is an abstract base class for the class template
  //! FroidurePin.
  //!
  //! FroidurePinBase allows a polymorphic interface to instances of
  //! FroidurePin and its member functions reflect those member functions of
  //! FroidurePin that do not depend on the template parameter ``Element``
  //! (the type of the elements of the semigroup represented).
  //!
  //! \sa FroidurePin and FroidurePinTraits.
  class FroidurePinBase : public Runner {
    template <typename Element, typename Traits>
    friend class FroidurePin;

   public:
    //! Alias for the type of the size of the enumerated semigroup.
    // It should be possible to change this type and everything will just work,
    // provided the size of the semigroup is less than the maximum value of
    // this type of integer.
    using size_type = uint32_t;

    //! \brief Alias for the index of a generator.
    //!
    //! Alias for \ref size_type used to indicate that a value should be the
    //! index of a generator.
    using generator_index_type = size_type;

    //! \brief Alias for the index of an element.
    //!
    //! The size of the semigroup being enumerated must be at most \c
    //! std::numeric_limits<element_index_type>::max()
    using element_index_type = size_type;

    //! \brief Alias for the types of the left and right Cayley graphs.
    using cayley_graph_type = WordGraph<element_index_type>;

   private:
    // See comments in FroidurePin
    using enumerate_index_type = size_type;

    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - data members - private
    ////////////////////////////////////////////////////////////////////////

    // This now only contains a single data member, which might make it a bit
    // redundant.
    struct Settings {
      Settings() noexcept : _batch_size(8'192) {}
      Settings(Settings const&) noexcept            = default;
      Settings(Settings&&) noexcept                 = default;
      Settings& operator=(Settings const&) noexcept = default;
      Settings& operator=(Settings&&) noexcept      = default;
      ~Settings()                                   = default;

      size_t _batch_size;
    } _settings;

    size_t _degree;
    std::vector<std::pair<generator_index_type, generator_index_type>>
                                      _duplicate_gens;
    std::vector<element_index_type>   _enumerate_order;
    std::vector<generator_index_type> _final;
    std::vector<generator_index_type> _first;
    bool                              _found_one;
    bool                              _idempotents_found;
    std::vector<int>                  _is_idempotent;
    cayley_graph_type                 _left;
    std::vector<size_type>            _length;
    std::vector<enumerate_index_type> _lenindex;
    std::vector<element_index_type>   _letter_to_pos;
    size_type                         _nr;
    size_t                            _nr_products;
    size_t                            _nr_rules;
    enumerate_index_type              _pos;
    element_index_type                _pos_one;
    std::vector<element_index_type>   _prefix;
    detail::DynamicArray2<bool>       _reduced;
    cayley_graph_type                 _right;
    std::vector<element_index_type>   _suffix;
    size_t                            _wordlen;

   public:
    ////////////////////////////////////////////////////////////////////////
    // FroidurePinBase - constructors - public
    ////////////////////////////////////////////////////////////////////////

    //! \brief Default constructor.
    //!
    //! Default constructor.
    FroidurePinBase();

    //! \brief Reinitialize a FroidurePinBase object.
    //!
    //! This function re-initializes a FroidurePinBase object so that it is in
    //! the same state as if it had just been default constructed.
    //!
    //! \returns A reference to `*this`.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    FroidurePinBase& init();

    //! \brief Copy constructor.
    //!
    //! Copy constructor.
    FroidurePinBase(FroidurePinBase const& S);

    //! \brief Default move constructor.
    //!
    //! Default move constructor.
    FroidurePinBase(FroidurePinBase&& other) = default;

    //! \brief Copy assignment operator.
    //!
    //! Copy assignment operator.
    FroidurePinBase& operator=(FroidurePinBase const&);

    //! \brief Move assignment operator.
    //!
    //! Move assignment operator.
    FroidurePinBase& operator=(FroidurePinBase&&) = default;

    virtual ~FroidurePinBase();

    ////////////////////////////////////////////////////////////////////////
    // FroidurePinBase - settings - public
    ////////////////////////////////////////////////////////////////////////

    //! \brief Set a new value for the batch size.
    //!
    //! The *batch size* is the number of new elements to be found by any call
    //! to \ref run. This is used by, for example, FroidurePin::position so
    //! that it is possible to find the position of an element after only
    //! partially enumerating the semigroup.
    //!
    //! The default value of the batch size is `8192`.
    //!
    //! \param batch_size the new value for the batch size.
    //!
    //! \returns A reference to `*this`.
    //!
    //! \exceptions
    //! \noexcept
    //!
    //! \complexity
    //! Constant.
    //!
    //! \sa \ref batch_size.
    FroidurePinBase& batch_size(size_t batch_size) noexcept {
      _settings._batch_size = batch_size;
      return *this;
    }

    //! \brief Returns the current value of the batch size.
    //!
    //! This function returns the minimum number of elements enumerated in any
    //! call to \ref run.
    //!
    //! \returns The current value of the batch size.
    //!
    //! \exceptions
    //! \noexcept
    //!
    //! \complexity
    //! Constant.
    //!
    //! \sa \ref batch_size(size_t).
    [[nodiscard]] size_t batch_size() const noexcept {
      return _settings._batch_size;
    }

#ifndef PARSED_BY_DOXYGEN
    ////////////////////////////////////////////////////////////////////////
    // FroidurePinBase - pure virtual member functions - public
    ////////////////////////////////////////////////////////////////////////

    [[nodiscard]] virtual size_t number_of_generators() const = 0;
    [[nodiscard]] virtual tril   is_finite() const            = 0;

#endif  // PARSED_BY_DOXYGEN not defined

    ////////////////////////////////////////////////////////////////////////
    // FroidurePinBase - member functions - public
    ////////////////////////////////////////////////////////////////////////

    //! \brief Returns the position corresponding to a word.
    //!
    //! Returns the position in the semigroup corresponding to the element
    //! represented by the word \p w.
    //!
    //! This function returns the position corresponding to the element
    //! obtained by evaluating the word in the generators \p w. No enumeration
    //! is performed, and \ref UNDEFINED is returned if the position of the
    //! element corresponding to \p w cannot be determined.
    //!
    //! This is equivalent to finding the product \c x of the
    //! generators FroidurePin::generator(\c w[i]) and then calling
    //! FroidurePin::current_position with argument \c x.
    //!
    //! \param w a word in the generators.
    //!
    //! \returns
    //! A value of type `element_index_type` or \ref UNDEFINED.
    //!
    //! \throws LibsemigroupsException if \p w contains an value exceeding
    //! FroidurePin::number_of_generators.
    //!
    //! \complexity
    //! \f$O(n)\f$ where \f$n\f$ is the length of the word \p w.
    //!
    //! \sa FroidurePin::word_to_element.
    // This is not a helper because the function
    // FroidurePin::current_position(const_reference) requires access to the
    // private members.
    [[nodiscard]] element_index_type current_position(word_type const& w) const;

    //! \brief Returns the position corresponding to a word.
    //!
    //! Returns the position in the semigroup corresponding to the element
    //! represented by the word \p w.
    //!
    //! This function returns the position in the FroidurePinBase object of the
    //! element corresponding to the word in the generators \p w. No enumeration
    //! is performed, and \ref UNDEFINED is returned if the position of the
    //! element corresponding to \p w cannot be determined.
    //!
    //! \param w a word in the generators.
    //!
    //! \returns
    //! The index of the element corresponding to the word \p w, or \ref
    //! UNDEFINED if there is no such element.
    //!
    //! \warning This function does not check its argument is valid. In
    //! particular, if any of the letters in \p w is out of range, then bad
    //! things will happen.
    //!
    //! \complexity \f$O(n)\f$ where \f$n\f$ is the length of the word \p w.
    //!
    //! \sa FroidurePin::word_to_element.
    [[nodiscard]] element_index_type
    current_position_no_checks(word_type const& w) const;

    //! \copydoc current_position(word_type const&) const
    // This is not a helper because the function
    // FroidurePin::current_position(const_reference) requires access to the
    // private members.
    [[nodiscard]] element_index_type
    current_position(std::initializer_list<size_t> const& w) const {
      word_type ww = w;
      return current_position(ww);
    }

    //! \copydoc current_position_no_checks(word_type const&) const
    [[nodiscard]] element_index_type
    current_position_no_checks(std::initializer_list<size_t> const& w) const {
      word_type ww = w;
      return current_position_no_checks(ww);
    }

    //! \brief Returns the position corresponding to a generator.
    //!
    //! Returns the position in the semigroup corresponding to the generator
    //! with index \p i.
    //!
    //! This function returns the position in the FroidurePinBase object of the
    //! element corresponding to the generator with index \p i.
    //!
    //! \param i the index of the generator.
    //!
    //! \returns
    //! The position of the generator with index \p i.
    //!
    //! \warning This function does not check its argument is valid. In
    //! particular, if there is no generator with index \p i, then bad
    //! things will happen.
    //!
    //! \complexity Constant.
    //!
    //! \sa FroidurePin::word_to_element.
    [[nodiscard]] element_index_type
    current_position_no_checks(generator_index_type i) const {
      LIBSEMIGROUPS_ASSERT(i < _letter_to_pos.size());
      return _letter_to_pos[i];
    }

    //! \brief Returns the position in of the generator with specified index.
    //!
    //! In many cases \p current_position(i) will equal \p i, examples
    //! of when this will not be the case are:
    //!
    //! * there are duplicate generators;
    //!
    //! * FroidurePin::add_generators was called after the semigroup was already
    //! partially enumerated.
    //!
    //! \param i the index of the generators.
    //!
    //! \returns A value of type \ref element_index_type.
    //!
    //! \throws LibsemigroupsException if \p i is greater than or equal to
    //! FroidurePin::number_of_generators.
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] element_index_type
    current_position(generator_index_type i) const {
      throw_if_generator_index_out_of_range(i);
      return current_position_no_checks(i);
    }

    // TODO(later) analogues of the current_position mem fns for position

    //! \brief Returns the maximum length of a word in the generators so far
    //! computed.
    //!
    //! Every element of the semigroup can be expressed as the short-lex least
    //! product of the generators that equals that element.  This function
    //! returns the length of the longest short-lex least word in the
    //! generators that has so far been enumerated.
    //!
    //! \returns
    //! A value of type \c size_t.
    //!
    //! \exceptions
    //! \noexcept
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] size_t current_max_word_length() const noexcept {
      return _length[_enumerate_order.back()];
    }

    //! \brief Returns the degree of any and all elements.
    //!
    //! \returns
    //! A value of type \c size_t.
    //!
    //! \exceptions
    //! \noexcept
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] size_t degree() const noexcept {
      return _degree;
    }

    //! \brief Returns the number of elements so far enumerated.
    //!
    //! This is only the actual size of the semigroup if the semigroup is fully
    //! enumerated.
    //!
    //! \returns
    //! A value of type \c size_t.
    //!
    //! \exceptions
    //! \noexcept
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] size_t current_size() const noexcept {
      return _nr;
    }

    //! \brief Returns the number of relations that have been found so far.
    //!
    //! This is only guaranteed to be the actual number of relations in a
    //! presentation defining the semigroup if the semigroup is fully
    //! enumerated.
    //!
    //! \returns
    //! A value of type \c size_t.
    //!
    //! \exceptions
    //! \noexcept
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] size_t current_number_of_rules() const noexcept {
      return _nr_rules;
    }

    //! \brief Returns the position of the longest proper prefix.
    //!
    //! Returns the position of the prefix of the element \c x in position
    //! \p pos (of the semigroup) of length one less than the length of \c x.
    //!
    //! \param pos the position.
    //!
    //! \returns A value of type \c element_index_type.
    //!
    //! \warning No checks are made that the argument \p pos is valid. In
    //! particular, if \p pos is greater than or equal to \ref current_size,
    //! then bad things will happen.
    //!
    //! \complexity
    //! Constant.
    element_index_type prefix_no_checks(element_index_type pos) const {
      LIBSEMIGROUPS_ASSERT(pos < _prefix.size());
      return _prefix[pos];
    }

    //! \brief Returns the position of the longest proper prefix.
    //!
    //! Returns the position of the prefix of the element \c x in position
    //! \p pos (of the semigroup) of length one less than the length of \c x.
    //!
    //! \param pos the position.
    //!
    //! \returns A value of type \c element_index_type.
    //!
    //! \throws LibsemigroupsException if \p pos is greater than or equal to
    //! \ref current_size.
    //!
    //! \complexity
    //! Constant.
    element_index_type prefix(element_index_type pos) const {
      throw_if_element_index_out_of_range(pos);
      return prefix_no_checks(pos);
    }

    //! \brief Returns the position of the longest proper suffix.
    //!
    //! Returns the position of the suffix of the element \c x in position
    //! \p pos (of the semigroup) of length one less than the length of \c x.
    //!
    //! \param pos the position.
    //!
    //! \returns A value of type \c element_index_type.
    //!
    //! \warning No checks are made that the argument \p pos is valid. In
    //! particular, if \p pos is greater than or equal to \ref current_size,
    //! then bad things will happen.
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] element_index_type
    suffix_no_checks(element_index_type pos) const {
      LIBSEMIGROUPS_ASSERT(pos < _suffix.size());
      return _suffix[pos];
    }

    //! \brief Returns the position of the longest proper suffix.
    //!
    //! Returns the position of the suffix of the element \c x in position
    //! \p pos (of the semigroup) of length one less than the length of \c x.
    //!
    //! \param pos the position.
    //!
    //! \returns A value of type \c element_index_type.
    //!
    //! \throws LibsemigroupsException if \p pos is greater than or equal to
    //! \ref current_size.
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] element_index_type suffix(element_index_type pos) const {
      throw_if_element_index_out_of_range(pos);
      return suffix_no_checks(pos);
    }

    //! \brief Returns the first letter of the element with specified index.
    //!
    //! This function returns the first letter of the element in position
    //! \p pos of the semigroup, which is the index of the generator
    //! corresponding to the first letter of the element.
    //!
    //! This function does not trigger an enumeration.
    //!
    //! \note
    //! Note that `FroidurePin::generator(first_letter(pos))` is
    //! only equal to `FroidurePin::at(first_letter(pos))` if
    //! there are no duplicate generators.
    //!
    //! \param pos the position.
    //!
    //! \returns A value of type \c generator_index_type.
    //!
    //! \warning No checks are made that the argument \p pos is valid. In
    //! particular, if \p pos is greater than or equal to \ref current_size,
    //! then bad things will happen.
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] generator_index_type
    first_letter_no_checks(element_index_type pos) const {
      LIBSEMIGROUPS_ASSERT(pos < _first.size());
      return _first[pos];
    }

    //! \brief Returns the first letter of the element with specified index.
    //!
    //! This function returns the first letter of the element in position
    //! \p pos of the semigroup, which is the index of the generator
    //! corresponding to the first letter of the element.
    //!
    //! \note
    //! Note that `FroidurePin::generator(first_letter(pos))` is
    //! only equal to `FroidurePin::at(first_letter(pos))` if
    //! there are no duplicate generators.
    //!
    //! \param pos the position.
    //!
    //! \returns A value of type \c generator_index_type.
    //!
    //! \throws LibsemigroupsException if \p pos is greater than or equal to
    //! \ref current_size.
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] generator_index_type
    first_letter(element_index_type pos) const {
      throw_if_element_index_out_of_range(pos);
      return first_letter_no_checks(pos);
    }

    //! \brief Returns the first letter of the element with specified index.
    //!
    //! This function returns the first letter of the element in position
    //! \p pos of the semigroup, which is the index of the generator
    //! corresponding to the first letter of the element.
    //!
    //! This function does not trigger an enumeration.
    //!
    //! \note
    //! Note that `FroidurePin::generator(first_letter(pos))` is
    //! only equal to `FroidurePin::at(first_letter(pos))` if
    //! there are no duplicate generators.
    //!
    //! \param pos the position.
    //!
    //! \returns A value of type \c generator_index_type.
    //!
    //! \warning No checks are made that the argument \p pos is valid. In
    //! particular, if \p pos is greater than or equal to \ref current_size,
    //! then bad things will happen.
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] generator_index_type
    final_letter_no_checks(element_index_type pos) const {
      LIBSEMIGROUPS_ASSERT(pos < _final.size());
      return _final[pos];
    }

    //! \brief Returns the last letter of the element with specified index.
    //!
    //! This function returns the final letter of the element in position
    //! \p pos of the semigroup, which is the index of the generator
    //! corresponding to the final letter of the element.
    //!
    //! \param pos the position.
    //!
    //! \returns A value of type \c generator_index_type.
    //!
    //! \throws LibsemigroupsException if \p pos is greater than or equal to
    //! \ref current_size.
    //!
    //! \complexity
    //! Constant.
    //!
    //! \note
    //! Note that `FroidurePin::generator(first_letter(pos))` is
    //! only equal to `FroidurePin::at(first_letter(pos))` if
    //! there are no duplicate generators.
    //!
    //! \note No enumeration is triggered by calling this function.
    // TODO more notes like the above
    [[nodiscard]] generator_index_type
    final_letter(element_index_type pos) const {
      throw_if_element_index_out_of_range(pos);
      return final_letter_no_checks(pos);
    }

    //! \brief Returns the length of the short-lex least word equal to the
    //! element with given index.
    //!
    //! This function returns the length of the short-lex least word (in the
    //! generators) equal to the element with index \p pos. No enumeration is
    //! triggered by calls to this function.
    //!
    //! \param pos the position.
    //!
    //! \returns The length of the word equal to the element with index \p pos.
    //!
    //! \complexity
    //! Constant.
    //!
    //! \sa
    //! \ref length.
    //!
    //! \warning This function does not check that \p pos is valid. In
    //! particular, if `pos > current_size()`, then bad things will happen.
    [[nodiscard]] size_t
    current_length_no_checks(element_index_type pos) const {
      LIBSEMIGROUPS_ASSERT(pos < _length.size());
      return _length[pos];
    }

    //! \brief Returns the length of the short-lex least word equal to the
    //! element with given index.
    //!
    //! This function returns the length of the short-lex least word (in the
    //! generators) equal to the element with index \p pos.
    //!
    //! \param pos the position.
    //!
    //! \returns The length of the word equal to the element with index \p pos.
    //!
    //! \throws LibsemigroupsException if \p pos is greater than or equal to
    //! \ref current_size.
    //!
    //! \complexity
    //! Constant.
    //!
    //! \sa
    //! \ref length.
    [[nodiscard]] size_t current_length(element_index_type pos) const {
      throw_if_element_index_out_of_range(pos);
      return current_length_no_checks(pos);
    }

    //! \brief Returns the length of the short-lex least word equal to the
    //! element with given index.
    //!
    //! \param pos the position.
    //!
    //! \returns The length of the element with index \p pos.
    //!
    //! \throws LibsemigroupsException if \p pos is greater than or equal to
    //! \ref size.
    //!
    //! \complexity
    //! Constant.
    //!
    //! \sa
    //! \ref current_length.
    // This function could be a helper, but current_length cannot be, so keeping
    // this as a mem fn.
    [[nodiscard]] size_t length(element_index_type pos);

    //! \brief Returns the length of the short-lex least word equal to the
    //! element with given index.
    //!
    //! \param pos the position.
    //!
    //! \returns The length of the element with index \p pos.
    //!
    //! \warning This function does not check that \p pos is valid. In
    //! particular, if \p pos is greater than or equal to \ref size, then bad
    //! things will happen.
    //!
    //! \complexity
    //! Constant.
    //!
    //! \sa
    //! \ref current_length.
    // This function could be a helper, but current_length cannot be, so keeping
    // this as a mem fn.
    [[nodiscard]] size_t length_no_checks(element_index_type pos);

    //! \brief Returns the size of the semigroup represented by a FroidurePin
    //! instance.
    //!
    //! \returns
    //! A value of type `size_t`.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! At worst \f$O(|S|n)\f$ where \f$S\f$ is the semigroup represented by \c
    //! this, and \f$n\f$ is the return value of
    //! FroidurePin::number_of_generators.
    [[nodiscard]] size_t size() {
      run();
      return current_size();
    }

    //! \brief Check if the semigroup is a monoid.
    //!
    //! \returns
    //! \c true if the semigroup represented by \c this contains
    //! FroidurePin::One, and \c false if not.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! At worst \f$O(|S|n)\f$ where \f$S\f$ is the semigroup represented by \c
    //! this, and \f$n\f$ is the return value of
    //! FroidurePin::number_of_generators.
    [[nodiscard]] bool is_monoid();

    //! \brief Returns the total number of relations in the presentation.
    //!
    //! \returns
    //! A value of type `size_t`.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! At worst \f$O(|S|n)\f$ where \f$S\f$ is the semigroup represented by \c
    //! this, and \f$n\f$ is the return value of
    //! FroidurePin::number_of_generators.
    //!
    //! \sa \ref cbegin_rules and \ref cend_rules.
    [[nodiscard]] size_t number_of_rules() {
      run();
      return _nr_rules;
    }

    //! \brief Returns a const reference to the right Cayley graph.
    //!
    //! \returns A const reference to \ref cayley_graph_type.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! At worst \f$O(|S|n)\f$ where \f$S\f$ is the semigroup represented by \c
    //! this, and \f$n\f$ is the return value of
    //! FroidurePin::number_of_generators.
    [[nodiscard]] cayley_graph_type const& right_cayley_graph() {
      run();
      return _right;
    }

    //! \brief Returns a const reference to the right Cayley graph.
    //!
    //! This function triggers a full enumeration, and then returns the right
    //! Cayley graph of the semigroup represented by a FroidurePin instance.
    //!
    //! \returns The full enumerated right Cayley graph.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] cayley_graph_type const&
    current_right_cayley_graph() const noexcept {
      return _right;
    }

    //! \brief Returns a const reference to the left Cayley graph.
    //!
    //! This function triggers a full enumeration, and then returns the left
    //! Cayley graph of the semigroup represented by a FroidurePin instance.
    //!
    //! \returns The fully enumerated left Cayley graph.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] cayley_graph_type const& left_cayley_graph() {
      run();
      return _left;
    }

    //! \brief Returns a const reference to the left Cayley graph.
    //!
    //! \returns The (possibly partially enumerated) left Cayley graph.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! At worst \f$O(|S|n)\f$ where \f$S\f$ is the semigroup represented by \c
    //! this, and \f$n\f$ is the return value of
    //! FroidurePin::number_of_generators.
    [[nodiscard]] cayley_graph_type const&
    current_left_cayley_graph() const noexcept {
      return _left;
    }

    // Here's a little summary of the functions for minimal_factorisation:
    // [x] current_minimal_factorisation_no_checks(2 args)
    // [x] current_minimal_factorisation_no_checks(1 arg)
    // [x] current_minimal_factorisation(2 args)
    // [x] current_minimal_factorisation(1 arg)
    // [x] minimal_factorisation(2 args)
    // [x] minimal_factorisation(1 arg)
    // [ ] ~~minimal_factorisation_no_checks(2 args)~~ NONSENSICLE
    // [ ] ~~minimal_factorisation_no_checks(1 arg)~~ NONSENSICLE

    //! \brief Modify a word to contain the short-lex least word representing an
    //! element given by index.
    //!
    //! Changes \p word in-place to contain a minimal word with respect to the
    //! short-lex ordering in the generators equal to the \p pos element of
    //! the semigroup. No further enumeration is performed.
    //!
    //! \param word the word to clear and change in-place.
    //! \param pos the index of the element whose factorisation is sought.
    //!
    //! \warning This function does not check that \p pos is valid. In
    //! particular, if `pos > current_size()`, then bad things will happen.
    //!
    //! \throws LibsemigroupsException if \p pos is greater than or equal to
    //! \ref current_size.
    //!
    //! \complexity
    //! Constant.
    // This function could be a helper, but
    // FroidurePin::minimal_factorisation(const_reference) isn't so keeping.
    void current_minimal_factorisation_no_checks(word_type&         word,
                                                 element_index_type pos) const;

    //! \brief Returns a short-lex least word representing an element given by
    //! index.
    //!
    //! This is the same as the two-argument member function for
    //! \ref minimal_factorisation, but it returns a \ref word_type by value
    //! instead of modifying its first argument in-place. No enumeration is
    //! triggered by calling this function.
    //!
    //! \param pos the index of the element whose factorisation is sought.
    //!
    //! \returns
    //! A value of type `word_type`.
    //!
    //! \warning This function does not check that \p pos is valid. In
    //! particular, if `pos > current_size()`, then bad things will happen.
    //!
    //! \complexity
    //! At worst \f$O(mn)\f$ where \f$m\f$ equals \p pos and \f$n\f$ is the
    //! return value of FroidurePin::number_of_generators.
    // Notes:
    // 1. This function could be a helper, but
    //    FroidurePin::minimal_factorisation(const_reference) isn't so keeping.
    // 2. There's no no_check version of this function because it doesn't make
    //    sense (see the impl of minimal_factorisation(word_type&,
    //    element_index_type);
    word_type
    current_minimal_factorisation_no_checks(element_index_type pos) const {
      word_type word;
      current_minimal_factorisation_no_checks(word, pos);
      return word;
    }

    //! \brief Modify a word to contain the short-lex least word representing an
    //! element given by index.
    //!
    //! Changes \p word in-place to contain a minimal word with respect to the
    //! short-lex ordering in the generators equal to the \p pos element of
    //! the semigroup. No further enumeration is performed.
    //!
    //! \param word the word to clear and change in-place.
    //! \param pos the index of the element whose factorisation is sought.
    //!
    //! \throws LibsemigroupsException if \p pos is greater than or equal to
    //! current_size().
    //!
    //! \complexity
    //! Constant.
    // This function could be a helper, but
    // FroidurePin::minimal_factorisation(const_reference) isn't so keeping.
    void current_minimal_factorisation(word_type&         word,
                                       element_index_type pos) const {
      throw_if_element_index_out_of_range(pos);
      current_minimal_factorisation_no_checks(word, pos);
    }

    //! \brief Returns a short-lex least word representing an element given by
    //! index.
    //!
    //! This is the same as the two-argument member function for
    //! \ref current_minimal_factorisation, but it returns a \ref word_type by
    //! value instead of modifying its first argument in-place. No enumeration
    //! is triggered by calling this function.
    //!
    //! \param pos the index of the element whose factorisation is sought.
    //!
    //! \returns
    //! A value of type `word_type`.
    //!
    //! \throws LibsemigroupsException if \p pos is out of range.
    //!
    //! \complexity
    //! At worst \f$O(mn)\f$ where \f$m\f$ equals \p pos and \f$n\f$ is the
    //! return value of FroidurePin::number_of_generators.
    // Notes:
    // 1. This function could be a helper, but
    //    FroidurePin::minimal_factorisation(const_reference) isn't so keeping.
    // 2. There's no no_check version of this function because it doesn't make
    //    sense (see the impl of minimal_factorisation(word_type&,
    //    element_index_type);
    // This function could be a helper, but
    // FroidurePin::minimal_factorisation(const_reference) isn't so keeping.
    [[nodiscard]] word_type
    current_minimal_factorisation(element_index_type pos) const {
      word_type word;
      current_minimal_factorisation(word, pos);
      return word;
    }

    //! \brief Modify a word to contain the short-lex least word representing an
    //! element given by index.
    //!
    //! Changes \p word in-place to contain a minimal word with respect to the
    //! short-lex ordering in the generators equal to the \p pos element of
    //! the semigroup.
    //!
    //! If \p pos is less than the size of this semigroup, then this member
    //! function changes its first parameter \p word in-place by first clearing
    //! it and then to contain a minimal factorization of the element in
    //! position \p pos of the semigroup with respect to the generators of the
    //! semigroup.  This function enumerates the semigroup until at least the
    //! \p pos element is known.
    //!
    //! \param word the word to clear and change in-place.
    //! \param pos the index of the element whose factorisation is sought.
    //!
    //! \throws LibsemigroupsException if \p pos is greater than or equal to
    //! size().
    //!
    //! \complexity
    //! At worst \f$O(mn)\f$ where \f$m\f$ equals \p pos and \f$n\f$ is the
    //! return value of FroidurePin::number_of_generators.
    // 1. This function could be a helper, but
    //    FroidurePin::minimal_factorisation(const_reference) isn't so keeping.
    // 2. There's no no_check version of this function because it doesn't make
    //    sense (see the impl of minimal_factorisation(word_type&,
    //    element_index_type);
    void minimal_factorisation(word_type& word, element_index_type pos);

    //! \brief Returns a short-lex least word representing an element given by
    //! index.
    //!
    //! This is the same as the two-argument member function for
    //! \ref minimal_factorisation, but it returns a \ref word_type by value
    //! instead of modifying an argument in-place.
    //!
    //! \param pos the index of the element whose factorisation is sought.
    //!
    //! \returns
    //! A value of type `word_type`.
    //!
    //! \throws LibsemigroupsException if \p pos is greater than or equal to
    //! size().
    //!
    //! \complexity
    //! At worst \f$O(mn)\f$ where \f$m\f$ equals \p pos and \f$n\f$ is the
    //! return value of FroidurePin::number_of_generators.
    // Notes:
    // 1. This function could be a helper, but
    //    FroidurePin::minimal_factorisation(const_reference) isn't so keeping.
    // 2. There's no no_check version of this function because it doesn't make
    //    sense (see the impl of minimal_factorisation(word_type&,
    //    element_index_type);
    [[nodiscard]] word_type minimal_factorisation(element_index_type pos) {
      word_type word;
      minimal_factorisation(word, pos);
      return word;
    }

    //! \brief Returns the short-lex least word representing an element given by
    //! index (no enumeration).
    //!
    //! This function changes its argument \p word in-place to contain the
    //! short-lex least word representing the element of the semigroup with
    //! index \p pos.
    //!
    //! This function does not trigger any enumeration, and does not check that
    //! the argument \p pos is valid.
    //!
    //! \param word the \ref word_type to contain the result.
    //! \param pos the index of the element whose factorisation is sought.
    //!
    //! \returns
    //! The short-lex least word in the generators equal to the element with
    //! index \p pos.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! \f$O(m)\f$ where \f$m\f$ is the length of the returned word.
    // This function could be a helper, but
    // FroidurePin::minimal_factorisation(const_reference) isn't so keeping.
    void current_factorisation_no_checks(word_type&         word,
                                         element_index_type pos) const {
      current_minimal_factorisation_no_checks(word, pos);
    }

    // Here's a little summary of the functions for factorisation:
    // [ ] current_factorisation_no_checks(2 args) TODO
    // [ ] current_factorisation_no_checks(1 arg) TODO
    // [ ] current_factorisation(2 args) TODO
    // [ ] current_factorisation(1 arg) TODO
    // [x] factorisation(2 args)
    // [x] factorisation(1 arg)
    // [ ] ~~factorisation_no_checks(2 args)~~ NONSENSICAL
    // [ ] ~~factorisation_no_checks(1 arg)~~  NONSENSICAL

    //! \brief Obtain a word representing an element given by index.
    //!
    //! Changes \p word in-place to contain a word in the generators equal to
    //! the \p pos element of the semigroup.
    //!
    //! If \p pos is less than the size of this semigroup, then this member
    //! function changes its first parameter \p word in-place by first clearing
    //! it and then setting it to contain a factorization of the element in
    //! position \p pos of the semigroup with respect to the generators of the
    //! semigroup.  This function enumerates the semigroup until at least the
    //! element with index \p pos is known.
    //!
    //! The key difference between this function and
    //! minimal_factorisation(element_index_type) is that the resulting
    //! factorisation may not be minimal.
    //!
    //! \param word the word to contain the result.
    //! \param pos the index of the element.
    //!
    //! \throws LibsemigroupsException if \p pos is greater than or equal to
    //! size().
    //!
    //! \complexity
    //! At worst \f$O(mn)\f$ where \f$m\f$ equals \p pos and \f$n\f$ is the
    //! return value of FroidurePin::number_of_generators.
    // This function could be a helper, but
    // FroidurePin::minimal_factorisation(const_reference) isn't so keeping.
    void factorisation(word_type& word, element_index_type pos) {
      minimal_factorisation(word, pos);
    }

    //! \brief Returns a word representing an element given by index.
    //!
    //! This is the same as the two-argument member function for
    //! \ref factorisation, but it returns a \ref word_type by value
    //! instead of modifying an argument in-place.
    //!
    //! The key difference between this function and
    //! minimal_factorisation(element_index_type) is that the resulting
    //! factorisation may not be minimal.
    //!
    //! \param pos the index of the element whose factorisation is sought.
    //!
    //! \returns
    //! A value of type `word_type`.
    //!
    //! \throws LibsemigroupsException if \p pos is greater than or equal to
    //! size().
    //!
    //! \complexity
    //! At worst \f$O(mn)\f$ where \f$m\f$ equals \p pos and \f$n\f$ is the
    //! return value of FroidurePin::number_of_generators.
    // This function could be a helper, but
    // FroidurePin::minimal_factorisation(const_reference) isn't so keeping.
    [[nodiscard]] word_type factorisation(element_index_type pos) {
      return minimal_factorisation(pos);
    }

    //! \brief Enumerate until at least a specified number of elements are
    //! found.
    //!
    //! If the semigroup is already fully enumerated, or the number of elements
    //! previously enumerated exceeds \p limit, then calling this
    //! function does nothing. Otherwise, \ref run attempts to find at least
    //! the maximum of \p limit and \ref batch_size elements of the
    //! semigroup.
    //!
    //! \param limit the limit for \ref current_size.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! At worst \f$O(mn)\f$ where \f$m\f$ equals \p limit and \f$n\f$ is the
    //! return value of FroidurePin::number_of_generators.
    void enumerate(size_t limit);

    //! \brief Returns the number of elements so far enumerated with length in a
    //! given range.
    //!
    //! This function returns the number of elements that have been enumerated
    //! so far with length in the range \f$[min, max)\f$. This function does
    //! not trigger any enumeration.
    //!
    //! \param min the minimum length.
    //! \param max the maximum length plus one.
    //!
    //! \returns The number of elements with lengths in the specified range.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] size_t number_of_elements_of_length(size_t min,
                                                      size_t max) const;

    //! \brief Returns the number of elements so far enumerated with given
    //! length.
    //!
    //! This function returns the number of elements that have been enumerated
    //! so far with length \p len. This function does not trigger any
    //! enumeration.
    //!
    //! \param len the length.
    //!
    //! \returns The number of elements with length \p len.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] size_t number_of_elements_of_length(size_t len) const;

    //! \brief Return type of \ref cbegin_rules and \ref cend_rules.
    //!
    //! This nested class is the return type of \ref cbegin_rules, \ref
    //! cbegin_current_rules, \ref cend_rules, and \ref cend_current_rules.
    class const_rule_iterator {
#ifndef PARSED_BY_DOXYGEN

     public:
      using size_type = typename std::vector<relation_type>::size_type;
      using difference_type =
          typename std::vector<relation_type>::difference_type;
      using const_pointer = typename std::vector<relation_type>::const_pointer;
      using pointer       = typename std::vector<relation_type>::pointer;
      using const_reference =
          typename std::vector<relation_type>::const_reference;
      using reference         = typename std::vector<relation_type>::reference;
      using value_type        = relation_type;
      using iterator_category = std::forward_iterator_tag;

      // None of the constructors are noexcept because the corresponding
      // constructors for std::vector aren't (until C++17).
      const_rule_iterator() noexcept                           = default;
      const_rule_iterator(const_rule_iterator const&) noexcept = default;
      const_rule_iterator(const_rule_iterator&&) noexcept      = default;
      const_rule_iterator& operator=(const_rule_iterator const&) noexcept
          = default;
      const_rule_iterator& operator=(const_rule_iterator&&) noexcept = default;

      const_rule_iterator(FroidurePinBase const* ptr,
                          enumerate_index_type   pos,
                          generator_index_type   gen);

      ~const_rule_iterator() = default;

      [[nodiscard]] bool
      operator==(const_rule_iterator const& that) const noexcept {
        return _gen == that._gen && _pos == that._pos;
      }

      [[nodiscard]] bool
      operator!=(const_rule_iterator const& that) const noexcept {
        return !(this->operator==(that));
      }

      [[nodiscard]] const_reference operator*() const {
        populate_relation();
        return _relation;
      }

      [[nodiscard]] const_pointer operator->() const {
        populate_relation();
        return &_relation;
      }

      // prefix
      const_rule_iterator const& operator++() noexcept;

      // postfix
      [[nodiscard]] const_rule_iterator operator++(int) noexcept {
        const_rule_iterator copy(*this);
        ++(*this);
        return copy;
      }

      void swap(const_rule_iterator& that) noexcept {
        _current.swap(that._current);
        std::swap(_froidure_pin, that._froidure_pin);
        std::swap(_gen, that._gen);
        std::swap(_pos, that._pos);
      }
#endif  // PARSED_BY_DOXYGEN not defined

     private:
      void populate_relation() const;

      std::array<generator_index_type, 3> _current;
      FroidurePinBase const*              _froidure_pin;
      generator_index_type                _gen;
      enumerate_index_type                _pos;
      mutable relation_type               _relation;
    };  // const_rule_iterator

    // Assert that the forward iterator requirements are met
    static_assert(std::is_default_constructible_v<const_rule_iterator>,
                  "forward iterator requires default-constructible");
    static_assert(std::is_copy_constructible_v<const_rule_iterator>,
                  "forward iterator requires copy-constructible");
    static_assert(std::is_copy_assignable_v<const_rule_iterator>,
                  "forward iterator requires copy-assignable");
    static_assert(std::is_destructible_v<const_rule_iterator>,
                  "forward iterator requires destructible");

    //! \brief Returns a forward iterator pointing to the first rule (if any).
    //!
    //! Returns a forward iterator pointing to the first rule in a confluent
    //! terminating rewriting system defining a semigroup isomorphic to the
    //! one defined by \c this.
    //!
    //! This function does not perform any enumeration of the FroidurePin
    //! object. If you want to obtain the complete set of rules, then
    //! use \ref cbegin_rules instead.
    //!
    //! \returns An iterator of type FroidurePinBase::const_rule_iterator
    //! pointing to a \ref relation_type.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Constant
    //!
    //! \iterator_validity
    //! The iterators returned by this function are valid until the underlying
    //! FroidurePin instance is deleted.
    //!
    //! \sa cend_rules
    //!
    // clang-format off
    //! \par Example
    //! \code
    //! FroidurePin<BMat8> S;
    //! S.add_generator(BMat8({{1, 0, 0, 0},
    //!                        {1, 0, 0, 0},
    //!                        {1, 0, 0, 0},
    //!                        {1, 0, 0, 0}}));
    //! S.add_generator(BMat8({{0, 1, 0, 0},
    //!                        {0, 1, 0, 0},
    //!                        {0, 1, 0, 0},
    //!                        {0, 1, 0, 0}}));
    //! S.add_generator(BMat8({{0, 0, 1, 0},
    //!                        {0, 0, 1, 0},
    //!                        {0, 0, 1, 0},
    //!                        {0, 0, 1, 0}}));
    //! S.add_generator(BMat8({{0, 0, 0, 1},
    //!                        {0, 0, 0, 1},
    //!                        {0, 0, 0, 1},
    //!                        {0, 0, 0, 1}}));
    //! S.size(); // 4
    //! std::vector<relation_type>(S.cbegin_rules(), S.cend_rules());
    //! // {{{0, 0}, {0}},
    //! //  {{0, 1}, {1}},
    //! //  {{0, 2}, {2}},
    //! //  {{0, 3}, {3}},
    //! //  {{1, 0}, {0}},
    //! //  {{1, 1}, {1}},
    //! //  {{1, 2}, {2}},
    //! //  {{1, 3}, {3}},
    //! //  {{2, 0}, {0}},
    //! //  {{2, 1}, {1}},
    //! //  {{2, 2}, {2}},
    //! //  {{2, 3}, {3}},
    //! //  {{3, 0}, {0}},
    //! //  {{3, 1}, {1}},
    //! //  {{3, 2}, {2}},
    //! //  {{3, 3}, {3}}}
    //! \endcode
    // clang-format on
    [[nodiscard]] const_rule_iterator cbegin_current_rules() const {
      return const_rule_iterator(this, UNDEFINED, 0);
    }

    //! \brief Returns a forward iterator pointing to the first rule (if any).
    //!
    //! Returns a forward iterator pointing to the first rule in a confluent
    //! terminating rewriting system defining a semigroup isomorphic to the
    //! one defined by \c this.
    //!
    //! This function fully enumerate the FroidurePin object. If you want to
    //! obtain a (possibly incomplete) set of rules without triggering a full
    //! enumeration, then use \ref cbegin_current_rules instead.
    //!
    //! \returns An iterator of type FroidurePinBase::const_rule_iterator
    //! pointing to a \ref relation_type.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Constant
    //!
    //! \iterator_validity
    //! The iterators returned by this function are valid until the underlying
    //! FroidurePin instance is deleted.
    //!
    //! \sa cend_rules
    [[nodiscard]] const_rule_iterator cbegin_rules() {
      run();
      return const_rule_iterator(this, UNDEFINED, 0);
    }

    //! \brief Returns a forward iterator pointing one past the last rule (if
    //! any).
    //!
    //! Returns a forward iterator pointing one-past-the-last rule (currently
    //! known) in a confluent terminating rewriting system defining a semigroup
    //! isomorphic to the one defined by \c this.
    //!
    //! This function does not perform any enumeration of the FroidurePin. If
    //! you want to obtain the complete set of rules, then use \ref cend_rules
    //! instead.
    //!
    //! \returns An iterator of type FroidurePinBase::const_rule_iterator
    //! pointing to a \ref relation_type.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Constant
    //!
    //! \iterator_validity
    //! The iterators returned by this function are valid until the underlying
    //! FroidurePin instance is deleted.
    //!
    //! \sa cbegin_rules
    //!
    // clang-format off
    //! \par Example
    //! \code
    //! FroidurePin<BMat8> S;
    //! S.add_generator(BMat8({{1, 0, 0, 0},
    //!                        {1, 0, 0, 0},
    //!                        {1, 0, 0, 0},
    //!                        {1, 0, 0, 0}}));
    //! S.add_generator(BMat8({{0, 1, 0, 0},
    //!                        {0, 1, 0, 0},
    //!                        {0, 1, 0, 0},
    //!                        {0, 1, 0, 0}}));
    //! S.add_generator(BMat8({{0, 0, 1, 0},
    //!                        {0, 0, 1, 0},
    //!                        {0, 0, 1, 0},
    //!                        {0, 0, 1, 0}}));
    //! S.add_generator(BMat8({{0, 0, 0, 1},
    //!                        {0, 0, 0, 1},
    //!                        {0, 0, 0, 1},
    //!                        {0, 0, 0, 1}}));
    //! S.size(); // 4
    //! std::vector<relation_type>(S.cbegin_rules(), S.cend_rules());
    //! // {{{0, 0}, {0}},
    //! //  {{0, 1}, {1}},
    //! //  {{0, 2}, {2}},
    //! //  {{0, 3}, {3}},
    //! //  {{1, 0}, {0}},
    //! //  {{1, 1}, {1}},
    //! //  {{1, 2}, {2}},
    //! //  {{1, 3}, {3}},
    //! //  {{2, 0}, {0}},
    //! //  {{2, 1}, {1}},
    //! //  {{2, 2}, {2}},
    //! //  {{2, 3}, {3}},
    //! //  {{3, 0}, {0}},
    //! //  {{3, 1}, {1}},
    //! //  {{3, 2}, {2}},
    //! //  {{3, 3}, {3}}}
    //! \endcode
    // clang-format on
    [[nodiscard]] const_rule_iterator cend_current_rules() const {
      return const_rule_iterator(this, current_size(), 0);
    }

    //! \brief Returns a forward iterator pointing one past the last rule (if
    //! any).
    //!
    //! Returns a forward iterator pointing one-past-the-last rule in a
    //! confluent terminating rewriting system defining a semigroup isomorphic
    //! to the one defined by \c this.
    //!
    //! This function fully enumerate the FroidurePin object. If you want to
    //! obtain a (possibly incomplete) set of rules without triggering a full
    //! enumeration, then use \ref cend_rules instead.
    //!
    //! \returns An iterator of type \ref const_rule_iterator
    //! pointing to a \ref relation_type.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Constant
    //!
    //! \iterator_validity
    //! The iterators returned by this function are valid until the underlying
    //! FroidurePin instance is deleted.
    //!
    //! \sa cbegin_rules
    [[nodiscard]] const_rule_iterator cend_rules() {
      run();
      return const_rule_iterator(this, current_size(), 0);
    }

    //! \brief Returns a range object containing the so-far enumerated
    //! rules.
    //!
    //! This function returns a range object containing the rules of the
    //! semigroup that have been enumerated so far. Calling this function does
    //! not trigger any enumeration.
    //!
    //! \returns A range object containing the rules that have been enumerated
    //! so far.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Constant
    [[nodiscard]] auto current_rules() const {
      return rx::iterator_range(cbegin_current_rules(), cend_current_rules());
    }

    //! \brief Returns a range object containing all of the rules.
    //!
    //! This function returns a range object containing all of the rules of the
    //! semigroup that have been enumerated so far. Calling this function
    //! triggers a full enumeration.
    //!
    //! \returns A range object containing all of the rules
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! The same as \ref enumerate.
    [[nodiscard]] auto rules() {
      return rx::iterator_range(cbegin_rules(), cend_rules());
    }

    // TODO(later) it'd be more efficient to have this be a forward
    // iterator only (i.e. as is done in the GAP version of FroidurePin)
    //! \brief Return type of \ref cbegin_normal_forms and \ref
    //! cend_normal_forms.
    //!
    //! This nested class is the return type of \ref cbegin_normal_forms, \ref
    //! cbegin_current_normal_forms, \ref cend_normal_forms, and \ref
    //! cend_current_normal_forms.
    class const_normal_form_iterator {
#ifndef PARSED_BY_DOXYGEN
      // Private data
      mutable FroidurePinBase const* _froidure_pin;
      enumerate_index_type           _pos;
      mutable word_type              _word;

     public:
      using size_type       = typename std::vector<word_type>::size_type;
      using difference_type = typename std::vector<word_type>::difference_type;
      using const_pointer   = typename std::vector<word_type>::const_pointer;
      using pointer         = typename std::vector<word_type>::pointer;
      using const_reference = typename std::vector<word_type>::const_reference;
      using reference       = typename std::vector<word_type>::reference;
      using value_type      = word_type;
      using iterator_category = std::random_access_iterator_tag;

      const_normal_form_iterator()                                  = default;
      const_normal_form_iterator(const_normal_form_iterator const&) = default;
      const_normal_form_iterator(const_normal_form_iterator&&)      = default;
      const_normal_form_iterator& operator=(const_normal_form_iterator const&)
          = default;
      const_normal_form_iterator& operator=(const_normal_form_iterator&&)
          = default;

      ~const_normal_form_iterator() = default;

      const_normal_form_iterator(FroidurePinBase const* ptr,
                                 enumerate_index_type   pos)
          : _froidure_pin(ptr), _pos(pos), _word() {}

      [[nodiscard]] bool
      operator==(const_normal_form_iterator const& that) const noexcept {
        return _pos == that._pos;
      }

      [[nodiscard]] bool
      operator!=(const_normal_form_iterator const& that) const noexcept {
        return !(*this == that);
      }

      [[nodiscard]] bool
      operator<(const_normal_form_iterator const& that) const noexcept {
        return _pos < that._pos;
      }

      [[nodiscard]] bool
      operator>(const_normal_form_iterator const& that) const noexcept {
        return _pos > that._pos;
      }

      [[nodiscard]] bool
      operator<=(const_normal_form_iterator const& that) const noexcept {
        return _pos < that._pos;
      }

      [[nodiscard]] bool
      operator>=(const_normal_form_iterator const& that) const noexcept {
        return _pos > that._pos;
      }

      [[nodiscard]] const_reference operator*() const noexcept {
        populate_word();
        return _word;
      }

      [[nodiscard]] const_pointer operator->() const noexcept {
        populate_word();
        return &_word;
      }

      [[nodiscard]] const_reference operator[](size_type index) const {
        const_cast<const_normal_form_iterator*>(this)->_pos += index;
        populate_word();
        const_cast<const_normal_form_iterator*>(this)->_pos -= index;
        return _word;
      }

      // prefix
      const_normal_form_iterator const& operator++() noexcept {
        _pos++;
        return *this;
      }

      [[nodiscard]] const_normal_form_iterator operator++(int) noexcept {
        const_normal_form_iterator copy(*this);
        ++(*this);
        return copy;
      }

      const_normal_form_iterator const& operator--() noexcept {
        _pos--;
        return *this;
      }

      [[nodiscard]] const_normal_form_iterator operator--(int) noexcept {
        const_normal_form_iterator copy(*this);
        --(*this);
        return copy;
      }

      void operator+=(size_type val) noexcept {
        _pos += val;
      }

      void operator-=(size_type val) noexcept {
        _pos -= val;
      }

      [[nodiscard]] const_normal_form_iterator
      operator+(size_type val) const noexcept {
        const_normal_form_iterator copy(*this);
        copy += val;
        return copy;
      }

      [[nodiscard]] const_normal_form_iterator
      operator-(size_type val) const noexcept {
        const_normal_form_iterator copy(*this);
        copy -= val;
        return copy;
      }

      void swap(const_normal_form_iterator& that) noexcept {
        std::swap(_froidure_pin, that._froidure_pin);
        std::swap(_pos, that._pos);
        std::swap(_word, that._word);
      }

     private:
      void populate_word() const {
        _froidure_pin->current_minimal_factorisation_no_checks(_word, _pos);
      }
#endif  // PARSED_BY_DOXYGEN not defined
    };

    //! \brief Returns an iterator pointing at the first normal form (if any).
    //!
    //! This function returns an iterator pointing at the normal form of the
    //! first element of the semigroup represented by a FroidurePinBase
    //! instance (if any).
    //!
    //! This function does not perform any enumeration of the FroidurePin. If
    //! you want to obtain the complete set of rules, then use \ref
    //! cbegin_normal_forms instead.
    //!
    //! \returns An iterator of type \ref const_normal_form_iterator
    //! pointing to a \ref word_type.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] const_normal_form_iterator
    cbegin_current_normal_forms() const {
      return const_normal_form_iterator(this, 0);
    }

    //! \brief Returns an iterator pointing one beyond the last normal form (if
    //! any).
    //!
    //! This function returns an iterator pointing one beyond the normal
    //! form of the last element of the semigroup represented by a
    //! FroidurePinBase instance (if any).
    //!
    //! This function does not perform any enumeration of the FroidurePin. If
    //! you want to obtain the complete set of rules, then use \ref
    //! cend_normal_forms instead.
    //!
    //! \returns An iterator of type \ref const_normal_form_iterator
    //! pointing to a \ref word_type.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] const_normal_form_iterator cend_current_normal_forms() const {
      return const_normal_form_iterator(this, current_size());
    }

    //! \brief Returns a range object containing normal forms for the so-far
    //! enumerated elements.
    //!
    //! This function returns a range object containing normal forms for the
    //! elements of the semigroup that have been enumerated so far. Calling this
    //! function does not trigger any enumeration.
    //!
    //! \returns The normal forms that have been enumerated so far.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Constant
    [[nodiscard]] auto current_normal_forms() const {
      return rx::iterator_range(cbegin_current_normal_forms(),
                                cend_current_normal_forms());
    }

    //! \brief Returns an iterator pointing at the first normal form (if any).
    //!
    //! This function returns an iterator pointing at the normal form of the
    //! first element of the semigroup represented by a FroidurePinBase
    //! instance (if any).
    //!
    //! This function performs a full enumeration of the FroidurePin. If you
    //! want to obtain the current set of rules without triggering an
    //! enumeration, then use \ref cbegin_current_normal_forms instead.
    //!
    //! \returns An iterator of type \ref const_normal_form_iterator
    //! pointing to a \ref word_type.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Same as \ref enumerate.
    [[nodiscard]] const_normal_form_iterator cbegin_normal_forms() {
      run();
      return const_normal_form_iterator(this, 0);
    }

    //! \brief Returns an iterator pointing one beyond the last normal form (if
    //! any).
    //!
    //! This function returns an iterator pointing one beyond the normal
    //! form of the last element of the semigroup represented by a
    //! FroidurePinBase instance (if any).
    //!
    //! This function performs a full enumeration of the FroidurePin. If you
    //! want to obtain the current set of rules without triggering an
    //! enumeration, then use \ref cend_current_normal_forms instead.
    //!
    //! \returns An iterator of type \ref const_normal_form_iterator
    //! pointing to a \ref word_type.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Constant.
    [[nodiscard]] const_normal_form_iterator cend_normal_forms() {
      run();
      return const_normal_form_iterator(this, size());
    }

    //! \brief Returns a range object containing normal forms for all the
    //! elements.
    //!
    //! This function returns a range object containing normal forms for all of
    //! the elements of the semigroup. Calling this function triggers a full
    //! enumeration.
    //!
    //! \returns A range object containing the normal forms.
    //!
    //! \exceptions
    //! \no_libsemigroups_except
    //!
    //! \complexity
    //! Constant
    [[nodiscard]] auto normal_forms() {
      return rx::iterator_range(cbegin_normal_forms(), cend_normal_forms());
    }

    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - validation member functions - public
    ////////////////////////////////////////////////////////////////////////

    //! \brief Throw an exception if an index is out of range.
    //!
    //! This function throws an exception if the argument \p i exceeds \ref
    //! current_size.
    //!
    //! \param i the index to check.
    //!
    //! \throws LibsemigroupsException if \p i exceeds \ref current_size.
    void throw_if_element_index_out_of_range(element_index_type i) const;

    //! \brief Throw an exception if a generator index is out of range.
    //!
    //! This function throws an exception if the argument \p i exceeds
    //! FroidurePin::number_of_generators.
    //!
    //! \param i the index to check.
    //!
    //! \throws LibsemigroupsException if \p i exceeds
    //! FroidurePin::number_of_generators.
    void throw_if_generator_index_out_of_range(generator_index_type i) const;

   private:
    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - member functions - private
    ////////////////////////////////////////////////////////////////////////
    void partial_copy(FroidurePinBase const& S);
  };  // class FroidurePinBase

  //! \ingroup froidure_pin_group
  //!
  //! TODO
  namespace froidure_pin {
    using element_index_type = typename FroidurePinBase::element_index_type;

    //! \brief Compute a product using the Cayley graph.
    //!
    //! This function finds the product of `fpb.at(i)` and `fpb.at(j)` by
    //! following the path in the right Cayley graph from \p i labelled by the
    //! word `minimal_factorisation(j)` or, if `minimal_factorisation(i)` is
    //! shorter, by following the path in the left Cayley graph from \p j
    //! labelled by `minimal_factorisation(i)`.
    //!
    //! \param fpb the FroidurePinBase object.
    //! \param i the first index of an element.
    //! \param j the second index of an element.
    //!
    //! \returns
    //! A value of type \ref FroidurePinBase::element_index_type.
    //!
    //! \warning This function does not check its arguments. In particular,
    //! if \p i or \p j is greater than or equal
    //! to FroidurePinBase::current_size, then bad things will happen.
    //!
    //! \complexity
    //! \f$O(n)\f$ where \f$n\f$ is the minimum of the lengths of
    //! `minimal_factorisation(i)` and `minimal_factorisation(j)`.
    [[nodiscard]] element_index_type
    product_by_reduction_no_checks(FroidurePinBase const& fpb,
                                   element_index_type     i,
                                   element_index_type     j);

    //! \brief Compute a product using the Cayley graph.
    //!
    //! This function finds the product of `at(i)` and `at(j)` by following the
    //! path in the right Cayley graph from \p i labelled by the word
    //! `minimal_factorisation(j)` or, if `minimal_factorisation(i)` is
    //! shorter, by following the path in the left Cayley graph from \p j
    //! labelled by `minimal_factorisation(i)`.
    //!
    //! \param fpb the FroidurePinBase object.
    //! \param i the first index of an element.
    //! \param j the second index of an element.
    //!
    //! \returns
    //! A value of type \ref FroidurePinBase::element_index_type.
    //!
    //! \throws LibsemigroupsException if \p i or \p j is greater than or equal
    //! to FroidurePinBase::current_size.
    //!
    //! \complexity
    //! \f$O(n)\f$ where \f$n\f$ is the minimum of the lengths of
    //! `minimal_factorisation(i)` and `minimal_factorisation(j)`.
    [[nodiscard]] element_index_type
    product_by_reduction(FroidurePinBase const& fpb,
                         element_index_type     i,
                         element_index_type     j);
  }  // namespace froidure_pin
}  // namespace libsemigroups
#endif  // LIBSEMIGROUPS_FROIDURE_PIN_BASE_HPP_
