//
// libsemigroups - C++ library for semigroups and monoids
// Copyright (C) 2022 James D. Mitchell
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

#ifndef LIBSEMIGROUPS_TO_FROIDURE_PIN_HPP_
#define LIBSEMIGROUPS_TO_FROIDURE_PIN_HPP_

#include <cstddef>      // for size_t
#include <type_traits>  // for enable_if_t, is_base_of

#include "debug.hpp"       // for LIBSEMIGROUPS_ASSERT
#include "exception.hpp"   // for LIBSEMIGROUPS_EXCEPTION
#include "word-graph.hpp"  // for WordGraph

#include "detail/kbe.hpp"  // for KBE
#include "detail/ke.hpp"   // for KE
#include "detail/rewriters.hpp"
#include "detail/tce.hpp"  // for TCE

namespace libsemigroups {
#ifndef LIBSEMIGROUPS_PARSED_BY_DOXYGEN
  class FroidurePinBase;  // forward decl

  template <typename Word>
  class Congruence;
#endif

  namespace detail {

    class ToddCoxeterImpl;

    template <typename Rewriter, typename ReductionOrder>
    class KnuthBendixImpl;

    template <typename Thing>
    struct to_froidure_pin_helper;

    template <typename Word>
    struct to_froidure_pin_helper<Kambites<Word>> {
      using type = FroidurePin<detail::KE<Word>>;
    };
  }  // namespace detail

  template <typename Thing>
  using froidure_pin_t = typename detail::to_froidure_pin_helper<Thing>::type;

  //! Make a FroidurePin object from a WordGraph.
  //!
  //! If \f$m\f$ is the number of nodes in a WordGraph, \f$0 \leq a,  b< m\f$,
  //! and \f$n\f$ is an edge label, then we define \f$f: \{a, \ldots, b - 1\}
  //! \to \{0, \ldots, n - 1\}\f$ so that \f$(x)f\f$ equals the target of the
  //! edge starting at node \f$x\f$ with label \f$n\f$. In this way, every edge
  //! label in a WordGraph corresponds to a transformation of the nodes of the
  //! digraph. If \f$\{a, \ldots, b - 1\}f \subseteq \{a, \ldots, b - 1\}\f$,
  //! then \f$f\f$ is a transformation in the sense of Transf. Assuming that for
  //! every edge label of the WordGraph the corresponding \f$f\f$ satisfies
  //! \f$\{a, \ldots, b - 1\}f \subseteq \{a, \ldots, b - 1\}\f$, then this
  //! function returns the FroidurePin object corresponding to the semigroup
  //! generated by the set of all such transformations.
  //!
  //! \tparam S the type of the FroidurePin object being constructed (must
  //! be derived from FroidurePinBase).
  //! \tparam T the type of the nodes of the digraph.
  //!
  //! \param wg the WordGraph being used to construct the FroidurePin
  //! object.
  //! \param first the value of \f$a\f$ in the preceding discussion
  //! \param last the value of \f$b\f$ in the preceding discussion
  //!
  //! \returns The constructed FroidurePin object, a value of type \p S.
  //!
  //! \throws LibsemigroupsException if \ref validate(Transf<N, Scalar>
  //! const&) throws for any of the constructed transformations. This can
  //! happen if, for example, the WordGraph is not complete (i.e. there
  //! exists an edge label and node for which there is no edge with the
  //! given label and given source) or if there is an edge label such that
  //! \f$\{a, \ldots, b - 1\}f
  //! \not\subseteq \{a, \ldots, b - 1\}\f$ for the corresponding \f$f\f$.
  template <typename Element, typename Node>
  FroidurePin<Element> to_froidure_pin(WordGraph<Node> const& wg,
                                       size_t                 first,
                                       size_t                 last) {
    using node_type = typename WordGraph<Node>::node_type;

    if (first > last) {
      LIBSEMIGROUPS_EXCEPTION("the 2nd argument (first node) must be at most "
                              "the 3rd argument (last node), found {} > {}",
                              first,
                              last);
    } else if (first > wg.number_of_nodes()) {
      LIBSEMIGROUPS_EXCEPTION(
          "the 2nd argument (first node) must be at most the out-degree of the "
          "1st argument (WordGraph), found {} > {}",
          first,
          wg.out_degree());
    } else if (last > wg.number_of_nodes()) {
      LIBSEMIGROUPS_EXCEPTION(
          "the 3rd argument (last node) must be at most the out-degree of the "
          "1st argument (WordGraph), found {} > {}",
          last,
          wg.out_degree());
    }

    LIBSEMIGROUPS_ASSERT(wg.out_degree() > 0);
    FroidurePin<Element> result;
    Element              x(last - first);
    // Each label corresponds to a generator of S
    for (node_type lbl = 0; lbl < wg.out_degree(); ++lbl) {
      for (size_t n = first; n < last; ++n) {
        x[n - first] = wg.target(n, lbl) - first;
      }
      // The next loop is required because if element_type is a fixed degree
      // type, such as Transf<5> for example, but first = last = 0, then the
      // degree of x is still 5 not last - first = 0.
      for (size_t n = last - first; n < x.degree(); ++n) {
        x[n] = n;
      }

      validate(x);
      result.add_generator(x);
    }
    return result;
  }

  //! Make a FroidurePin object from a WordGraph.
  //!
  //! Calls `to_froidure_pin(wg, 0, wg.number_of_nodes())`; see above.
  template <typename Element, typename Node>
  FroidurePin<Element> to_froidure_pin(WordGraph<Node> const& wg) {
    return to_froidure_pin<Element>(wg, 0, wg.number_of_nodes());
  }

  FroidurePin<detail::TCE> to_froidure_pin(detail::ToddCoxeterImpl& tc);

  template <typename Rewriter, typename ReductionOrder>
  FroidurePin<detail::KBE<detail::KnuthBendixImpl<Rewriter, ReductionOrder>>>
  to_froidure_pin(detail::KnuthBendixImpl<Rewriter, ReductionOrder>& kb) {
    using KBE = detail::KBE<detail::KnuthBendixImpl<Rewriter, ReductionOrder>>;
    size_t const n = kb.internal_presentation().alphabet().size();

    if (n == 0) {
      LIBSEMIGROUPS_EXCEPTION("TODO(0)");
    } else if (kb.kind() != congruence_kind::twosided) {
      LIBSEMIGROUPS_EXCEPTION(
          "the argument must be a 2-sided congruence, found a {} congruence",
          kb.kind());
    }
    kb.run();

    FroidurePin<KBE> result(kb);
    for (size_t i = 0; i < n; ++i) {
      result.add_generator(KBE(kb, i));
    }
    if (kb.internal_presentation().contains_empty_word()) {
      result.add_generator(KBE(kb, ""));
    }
    return result;
  }

  // TODO(0) convert other to_froidure_pin's to return unique_ptr
  template <typename Word>
  std::unique_ptr<FroidurePinBase> to_froidure_pin(Kambites<Word>& k) {
    if (k.small_overlap_class() < 4) {
      LIBSEMIGROUPS_EXCEPTION(
          "the small overlap class of the argument must be >= 4, found {}",
          k.small_overlap_class());
    }

    // TODO(0) deduction guide
    FroidurePin<detail::KE<Word>> result(k);

    size_t const n = k.presentation().alphabet().size();
    for (size_t i = 0; i < n; ++i) {
      result.add_generator(detail::KE<Word>(k, i));
    }
    return std::make_unique<decltype(result)>(std::move(result));
  }

  template <typename Word>
  std::unique_ptr<FroidurePinBase> to_froidure_pin(Congruence<Word>& cong) {
    cong.run();
    if (cong.template has<Kambites<Word>>()) {
      // TODO(2) there an issue here that if the Kambites clause isn't first,
      // then we incorrectly start running the other algos here, which run
      // forever. Probably something goes wrong that the other runners don't
      // get deleted if Kambites wins, since it's run first.
      return to_froidure_pin(*cong.template get<Kambites<Word>>());
    } else if (cong.template has<ToddCoxeter<Word>>()) {
      auto fp = to_froidure_pin(*cong.template get<ToddCoxeter<Word>>());
      return std::make_unique<decltype(fp)>(std::move(fp));
    } else if (cong.template has<KnuthBendix<Word>>()) {
      auto fp = to_froidure_pin(*cong.template get<KnuthBendix<Word>>());
      return std::make_unique<decltype(fp)>(std::move(fp));
    }
    LIBSEMIGROUPS_EXCEPTION("TODO");
  }

}  // namespace libsemigroups
#endif  // LIBSEMIGROUPS_TO_FROIDURE_PIN_HPP_
