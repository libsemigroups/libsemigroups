//
// libsemigroups - C++ library for semigroups and monoids
// Copyright (C) 2016 James D. Mitchell
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

#ifndef LIBSEMIGROUPS_SEMIGROUPS_H_
#define LIBSEMIGROUPS_SEMIGROUPS_H_

#include <assert.h>

#include <algorithm>
#include <mutex>
#include <string>
#include <thread>
#include <unordered_map>
#include <utility>
#include <vector>

#include "elements.h"
#include "util/recvec.h"
#include "util/report.h"

//! Namespace for everything in the libsemigroups library.

namespace libsemigroups {

  class RWSE;

  // This object is used for printing information during a computation.  The
  // reason it is global is that we must be able to report from different
  // threads running concurrently.
  extern Reporter glob_reporter;

  //! Type for the index of a generator of a semigroup.
  typedef size_t letter_t;

  //! Type for a word over the generators of a semigroup.
  typedef std::vector<letter_t> word_t;

  //! Type for a pair of word_t (a *relation*) of a semigroup.
  typedef std::pair<word_t, word_t> relation_t;

  //! Type for a left or right Cayley graph of a semigroup.
  typedef RecVec<size_t> cayley_graph_t;

  //! Class for semigroups generated by instances of Element.
  //!
  //! Semigroups are defined by a generating set, and the main method here is
  //! Semigroup::enumerate, which implements the [Froidure-Pin Algorithm]().
  //! When the enumeration of the semigroup is complete the size, the left and
  //! right Cayley graphs are determined, and a confluent terminating
  //! presentation for the semigroup is known.
  class Semigroup {
    typedef RecVec<bool> flags_t;
    typedef size_t       index_t;

   public:
    //! Type for the position of an element in an instance of Semigroup.
    typedef size_t pos_t;

    //! Deleted.
    //!
    //! The Semigroup class does not support an assignment contructor to avoid
    //! accidental copying. An object in Semigroup may use many gigabytes of
    //! memory and might be extremely expensive to copy. A copy constructor is
    //! provided in case such a copy should it be required anyway.
    Semigroup& operator=(Semigroup const& semigroup) = delete;

    //! Construct from generators.
    //!
    //! This is the default constructor for a semigroup generated by \p gens.
    //! The generators \p gens must all be of the same derived subclass of the
    //! Element base class. Additionally, \p gens must satisfy the following:
    //!
    //! 1. there must be at least one generator
    //! 2. the generators must have equal degree Element::degree
    //!
    //! if either of these points is not satisfied, then an asssertion failure
    //! will occur.
    //!
    //! There can be duplicate generators and although they do not count as
    //! distinct elements, they do count as distinct generators. In other words,
    //! the generators of the semigroup are precisely (a copy of) \p gens in the
    //! same order they occur in \p gens.
    //!
    //! The generators \p gens are copied by the constructor, and so it is the
    //! responsibility of the caller to delete \p gens.
    explicit Semigroup(std::vector<Element*> const* gens);

    //! Construct from generators.
    //!
    //! See Semigroup::Semigroup.
    explicit Semigroup(std::vector<Element*> const& gens);

    //! Copy constructor.
    //!
    //! Constructs a new Semigroup which is an exact copy of \p copy. No
    //! enumeration is triggered for either \p copy or of the newly constructed
    //! semigroup.
    Semigroup(const Semigroup& copy);

   private:
    // Partial copy.
    // \p copy a semigroup
    // \p coll a collection of additional generators
    //
    // This is a constructor for a semigroup generated by the generators of the
    // Semigroup copy and the (possibly) additional generators coll.
    //
    // The relevant parts of the data structure of copy are copied and
    // \c this will be corrupt unless add_generators or closure is called
    // subsequently. This is why this method is private.
    //
    // The same effect can be obtained by copying copy using the copy
    // constructor and then calling add_generators or closure. However,
    // this constructor avoids copying those parts of the data structure of
    // copy that add_generators invalidates anyway. If copy has not been
    // enumerated at all, then these two routes for adding more generators are
    // equivalent.
    Semigroup(Semigroup const& copy, std::vector<Element*> const* coll);

   public:
    //! A default destructor.
    ~Semigroup();

    //! Returns the position in the semigroup corresponding to the element
    //! represented by the word \p w.
    //!
    //! The parameter \p w must consist of non-negative integers less than
    //! Semigroup::nrgens. This method returns the position in \c this of the
    //! element obtained by evaluating \p w. This is equivalent to finding the
    //! product \c x of the generators Semigroup::gens(\c w[i]) and then
    //! calling Semigroup::position with argument \c x.
    //!
    //! See also Semigroup::word_to_element.
    pos_t word_to_pos(word_t const& w) const;

    //! Returns a pointer to the element of \c this represented by the word
    //! \p w.
    //!
    //! The parameter \p w must consist of non-negative integers less than
    //! Semigroup::nrgens. This method returns a pointer to the element of
    //! \c this obtained by evaluating \p w. This is equivalent to finding the
    //! product \c x of the generators Semigroup::gens(\c w[i]).
    //!
    //! See also Semigroup::word_to_pos.
    Element* word_to_element(word_t const& w) const;

    //! Returns the maximum length of a word in the generators so far computed.
    //!
    //! Every elements of the semigroup can be expressed as a product of the
    //! generators. The elements of the semigroup are enumerated in the
    //! short-lex order induced by the order of the generators (as passed to
    //! Semigroup::Semigroup).  This method returns the length of the longest
    //! word in the generators that has so far been enumerated.
    size_t current_max_word_length() const {
      if (is_done()) {
        return _lenindex.size() - 2;
      } else if (_nr > _lenindex.back()) {
        return _lenindex.size();
      } else {
        return _lenindex.size() - 1;
      }
    }

    //! Returns the degree of any (and all) Element's in the semigroup.
    size_t degree() const {
      return _degree;
    }

    //! Returns the number of generators of the semigroup.
    size_t nrgens() const {
      return _gens->size();
    }

    //! Returns a pointer to the vector containing the generators of the
    //! semigroup.
    // FIXME these should be Element const*
    std::vector<Element*>* gens() const {
      return _gens;
    }

    //! Return a pointer to the generator with index \p pos.
    // FIXME these should be Element const*
    Element* gens(size_t pos) const {
      assert(pos < _gens->size());
      return (*_gens)[pos];
    }

    //! Returns \c true if the semigroup is fully enumerated and \c false if
    //! not.
    //!
    //! The semigroup is fully enumerated when the product of every element
    //! by every generator is known.
    bool is_done() const {
      return (_pos >= _nr);
    }

    //! Returns  \c true if no elements other than the generators have
    //! been enumerated so far and \c false otherwise.
    bool is_begun() const {
      assert(_lenindex.size() > 1);
      return (_pos >= _lenindex[1]);
    }

    //! Returns the position of the element \p x in the semigroup if it is
    //! already known to belong to the semigroup.
    //!
    //! This method finds the position of the element \p x in the semigroup if
    //! it is already known to belong to the semigroup, and
    //! libsemigroups::Semigroup::UNDEFINED if not. If the semigroup is
    //! not fully enumerated, then this method may return
    //! libsemigroups::Semigroup::UNDEFINED when \p x is in the semigroup,
    //! but not this is not yet known. See also Semigroup::position and
    //! Semigroup::sorted_position.
    // FIXME these should be Element const*
    pos_t current_position(Element* x) const {
      if (x->degree() != _degree) {
        return UNDEFINED;
      }

      auto it = _map.find(x);
      return (it == _map.end() ? UNDEFINED : it->second);
    }

    //! Returns the number of elements in the semigroup that have been
    //! enumerated so far.
    //!
    //! This is only the actual size of the semigroup if the semigroup is fully
    //! enumerated.
    size_t current_size() const {
      return _elements->size();
    }

    //! Returns the number of relations in the presentation for the semigroup
    //! that have been found so far.
    //!
    //! This is only the actual number of relations in a presentation defining
    //! the semigroup if the semigroup is fully enumerated.
    size_t current_nrrules() const {
      return _nrrules;
    }

    //! Returns the position of the prefix of the element \c x in position
    //! \p pos (of the semigroup) of length one less than the length of \c x.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, this is asserted in the method.
    pos_t prefix(pos_t pos) const {
      assert(pos < _nr);
      return _prefix[pos];
    }

    //! Returns the position of the suffix of the element \c x in position
    //! \p pos (of the semigroup) of length one less than the length of \c x.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, this is asserted in the method.
    pos_t suffix(pos_t pos) const {
      assert(pos < _nr);
      return _suffix[pos];
    }

    //! Returns the first letter of the element in position \p pos.
    //!
    //! This method returns the first letter of the element in position \p pos
    //! of the semigroup, which is the index of the generator corresponding to
    //! the first letter of the element.
    //!
    //! Note that Semigroup::gens[Semigroup::first_letter(\c pos)] is only
    //! equal to Semigroup::at(Semigroup::first_letter(\c pos)) if there are no
    //! duplicate generators.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, this is asserted in the method.
    letter_t first_letter(pos_t pos) const {
      assert(pos < _nr);
      return _first[pos];
    }

    //! Returns the last letter of the element in position \p pos.
    //!
    //! This method returns the final letter of the element in position \p pos
    //! of the semigroup, which is the index of the generator corresponding to
    //! the first letter of the element.
    //!
    //! Note that Semigroup::gens[Semigroup::final_letter(\c pos)] is only
    //! equal to Semigroup::at(Semigroup::final_letter(\c pos)) if there are no
    //! duplicate generators.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, this is asserted in the method.
    letter_t final_letter(pos_t pos) const {
      assert(pos < _nr);
      return _final[pos];
    }

    //! Returns the current value of the batch size. This is the minimum
    //! number of elements enumerated in any call to Semigroup::enumerate.
    size_t batch_size() const {
      return _batch_size;
    }

    //! Returns the length of the element in position \c pos of the semigroup.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, this is asserted in the method. This method
    //! causes no enumeration of the semigroup.
    size_t length_const(pos_t pos) const {
      assert(pos < _nr);
      return _length[pos];
    }

    //! Returns the length of the element in position \c pos of the semigroup.
    //!
    //! The parameter \p pos must be a valid position of an element of the
    //! semigroup, this is asserted in the method.
    size_t length_non_const(pos_t pos) {
      if (pos >= _nr) {
        enumerate();
      }
      return length_const(pos);
    }

    //! Returns the position in \c this of the product of \c this->at(i) and
    //! \c this->at(j) by following a path in the Cayley graph.
    //!
    //! This method asserts that the values \p i and \p j are valid, in that
    //! they are less than Semigroup::current_size.  This method returns the
    //! position Semigroup::pos_t in the semigroup of the product of  \c
    //! this->at(i) and \c this->at(j) elements by following the path in the
    //! right or left Cayley graph from \p i to \p j, whichever is shorter.
    pos_t product_by_reduction(pos_t i, pos_t j) const;

    //! Returns the position in \c this of the product of \c this->at(i) and
    //! \c this->at(j).
    //!
    //! This method asserts that the parameters \p i and \p j are less than
    //! Semigroup::current_size, and it either:
    //!
    //! * follows the path in the right or left Cayley graph from \p i to \p j,
    //!   whichever is shorter using Semigroup::product_by_reduction; or
    //!
    //! * multiplies the elements in postions \p i and \p j together;
    //!
    //! whichever is better. The method used is determined by comparing
    //! Element::complexity and the Semigroup::length_const of \p i and \p j.
    //!
    //! For example, if the Element::complexity of the multiplication is linear
    //! and \c this is a semigroup of transformations of degree 20, and the
    //! shortest paths in the left and right Cayley graphs from \p i to \p j
    //! are of length 100 and 1131, then it better to just multiply the
    //! transformations together.
    pos_t fast_product(pos_t i, pos_t j) const;

    //! Returns the position in \c this of the generator with index \p i
    //!
    //! This method asserts that the value of \p i is valid.  In many cases \p
    //! letter_to_pos(i) will equal \p i, examples of when this will not be the
    //! case are:
    //!
    //! * there are duplicate generators;
    //!
    //! * Semigroup::add_generators was called after the semigroup was already
    //! partially enumerated.
    pos_t letter_to_pos(letter_t i) const {
      assert(i < _nrgens);
      return _letter_to_pos[i];
    }

    //! Returns the total number of idempotents in the semigroup.
    //!
    //! This method involves fully enumerating the semigroup, if it is not
    //! already fully enumerated.  The value of the positions, and number, of
    //! idempotents is stored after they are first computed.
    size_t nr_idempotents();

    //! Returns \c true if the element in position \p pos is an idempotent
    //! and \c false if it is not.
    //!
    //! This method involves fully enumerating the semigroup, if it is not
    //! already fully enumerated.
    bool is_idempotent(pos_t pos);

    //! Returns a const iterator pointing at the first position of an
    //! idempotent in the semigroup.
    //!
    //! If the returned iterator is incremented, then it points to the second
    //! position of an idempotent in the semigroup (if it exists), and every
    //! subsequent increment points to the next position of an idempotent.
    //!
    //! This method involves fully enumerating the semigroup, if it is not
    //! already fully enumerated.
    std::vector<pos_t>::const_iterator idempotents_cbegin();

    //! Returns a const iterator referring to past the end of the position of
    //! the last idempotent in the semigroup.
    //!
    //! This method involves fully enumerating the semigroup, if it is not
    //! already fully enumerated.
    std::vector<pos_t>::const_iterator idempotents_cend();

    //! Returns  the total number of relations in the presentation defining the
    //! semigroup.
    //!
    //! See also Semigroup::next_relation.
    size_t nrrules() {
      enumerate();
      return _nrrules;
    }

    //! Set a new value for the batch size.
    //!
    //! The *batch size* is the number of new elements to be found by any call
    //! to Semigroup::enumerate. A call to enumerate returns between 0 and
    //! approximately the batch size.
    //!
    //! The default value of the batch size is 8192.
    //!
    //! This is used by, for example, Semigroup::position so that it is
    //! possible to find the position of an element without fully enumerating
    //! the semigroup.
    // FIXME Make _batch_size mutable and this const
    void set_batch_size(size_t batch_size) {
      _batch_size = batch_size;
    }

    //! Requests that the capacity (i.e. number of elements) of the semigroup
    //! be at least enough to contain n elements.
    //!
    //! The parameter \p n is also used to initialise certain data members, if
    //! you know a good upper bound for the size of your semigroup, then it is
    //! a good idea to call this method with that upper bound as an argument,
    //! this can significantly improve the performance of the
    //! Semigroup::enumerate method, and consequently every other method too.
    void reserve(size_t n);

    //! Returns the size of the semigroup.
    size_t size() {
      enumerate();
      return _elements->size();
    }

    //! Returns \c true if \p x is an element of \c this and \c false if it is
    //! not.
    //!
    //! This method can be used to check if the element \p x is an element of
    //! the semigroup. The semigroup is enumerated in batches until \p x is
    //! found or the semigroup is fully enumerated but \p x was not found (see
    //! Semigroup::set_batch_size).
    // FIXME Element const*
    bool test_membership(Element* x) {
      return (position(x) != UNDEFINED);
    }

    //! Returns the position of \p x in \c this, or Semigroup::UNDEFINED if \p
    //! x is not an element of \c this.
    //!
    //! This method can be used to find the Semigroup::pos_t position of the
    //! element \p x if it belongs to the semigroup. The semigroup is
    //! enumerated in batches until \p x is found or the semigroup is fully
    //! enumerated but \p x was not found (see Semigroup::set_batch_size).
    pos_t position(Element* x);

    //! Returns the position of \p x in the sorted array of elements of the
    //! semigroup, or Semigroup::UNDEFINED if \p x is not an element of \c
    //! this.
    size_t sorted_position(Element* x);

    //! Returns the vector consisting of pointers to all of the elements of the
    //! semigroup.
    // TODO(JDM) replace this with a method for cbegin and cend, don't allow
    // direct access to _elements.
    std::vector<Element*>* elements() {
      enumerate();
      return _elements;
    }

    //! Returns a vector consisting of pairs \c pair where \c pair.first is a
    //! pointer to an element of the semigroup and \c pair.second is the
    //! position of that element in the semigroup. This vector is sorted
    //! according to the Element::operator< method of the elements.
    // TODO(JDM) replace this with a method for sorted_cbegin and sorted_cend.
    std::vector<std::pair<Element*, pos_t>>* sorted_elements() {
      sort_elements();
      return _sorted;
    }

    //! Returns  the element of the semigroup in position \p pos, or a
    //! \c nullptr if there is no such element.
    //!
    //! This method attempts to enumerate the semigroup until at least
    //! \c pos + 1 elements have been found. If \p pos is greater than
    //! Semigroup::size, then this method returns \c nullptr.
    Element* at(pos_t pos);

    //! Returns the element of the semigroup in position \p pos.
    //!
    //! This method performs no checks on its argument, and performs no
    //! enumeration of the semigroup.
    // FIXME const
    Element* operator[](pos_t pos) const {
      return (*_elements)[pos];
    }

    //! Returns the element of the semigroup in position \p pos of the sorted
    //! array of elements, or \c nullptr in \p pos is not valid (i.e. too big).
    //!
    //! This method fully enumerates the semigroup.
    Element* sorted_at(pos_t pos);

    //! Returns a pointer to the right Cayley graph of the semigroup.
    //!
    //! This method fully enumerates the semigroup.
    // TODO expand this doc
    cayley_graph_t* right_cayley_graph() {
      enumerate();
      return _right;
    }

    //! Returns a pointer to the left Cayley graph of the semigroup.
    //!
    //! This method fully enumerates the semigroup.
    // TODO expand this doc
    cayley_graph_t* left_cayley_graph() {
      enumerate();
      return _left;
    }

    //! Changes \p word in-place to contain a minimal word with respect to the
    //! short-lex ordering in the generators equal to the \p pos element of
    //! the semigroup.
    //!
    //! If \p pos is less than the size of this semigroup, then this method
    //! changes its first parameter \p word in-place by first clearing it and
    //! then to contain a minimal factorization of the element in position \p
    //! pos of the semigroup with respect to the generators of the semigroup.
    //! This method enumerates the semigroup until at least the \p pos element
    //! is known. If \p pos is greater than the size of the semigroup, then
    //! nothing happens and word is not modified, in particular not cleared.
    void minimal_factorisation(word_t& word, pos_t pos);

    //! Returns a pointer to a minimal libsemigroups::word_t which evaluates to
    //! the Element in position \p pos of \c this.
    //!
    //! This is the same as the two-argument method for
    //! Semigroup::minimal_factorisation, but it returns a pointer to the
    //! factorisation instead of modifying an argument in-place.
    word_t* minimal_factorisation(pos_t pos);

    //! Returns a pointer to a minimal libsemigroups::word_t which evaluates to
    //! \p x.
    //!
    //! This is the same as the method taking a Semigroup::pos_t, but it
    //! factorises an Element instead of using the position of an element.
    word_t* minimal_factorisation(Element* x);

    //! Changes \p word in-place to contain a word in the generators equal to
    //! the \p pos element of the semigroup.
    //!
    //! The key difference between this method and
    //! Semigroup::minimal_factorisation(word_t& word, pos_t pos), is that the
    //! resulting factorisation may not be minimal.
    void factorisation(word_t& word, pos_t pos) {
      minimal_factorisation(word, pos);
    }

    //! Returns a pointer to a libsemigroups::word_t which evaluates to
    //! the Element in position \p pos of \c this.
    //!
    //! The key difference between this method and
    //! Semigroup::minimal_factorisation(pos_t pos), is that the resulting
    //! factorisation may not be minimal.
    word_t* factorisation(pos_t pos) {
      return minimal_factorisation(pos);
    }

    //! Returns a pointer to a libsemigroups::word_t which evaluates to
    //!
    //! The key difference between this method and
    //! Semigroup::minimal_factorisation(Element* x), is that the resulting
    //! factorisation may not be minimal.
    word_t* factorisation(Element* x);

    //! This method resets Semigroup::next_relation so that when it is next
    //! called the resulting relation is the first one.
    //!
    //! After a call to this function, the next call to
    //! Semigroup::next_relation will return the first relation of the
    //! presentation defining the semigroup.
    void reset_next_relation() {
      _relation_pos = UNDEFINED;
      _relation_gen = 0;
    }

    //! This method changes \p relation in-place to contain the next relation
    //! of the presentation defining \c this.
    //!
    //! This method changes \p relation in-place so that one of the following
    //! holds:
    //!
    //! * \p relation is a vector consisting of a libsemigroups::letter_t and a
    //! libsemigroups::letter_t such that
    //! Semigroup::gens(\c relation[\c 0]) ==
    //! Semigroup::gens(\c relation[\c 1]), i.e. if the
    //! semigroup was defined with duplicate generators;
    //!
    //! * \p relation is a vector consisting of a libsemigroups::pos_t,
    //! libsemigroups::letter_t, and libsemigroups::pos_t such that
    //! \code{.cpp}
    //!   this[relation[0]] * Semigroup::gens(relation[1]) == this[relation[2]]
    //! \endcode
    //!
    //! * \p relation is empty if there are no more relations.
    //!
    //! Semigroup::next_relation is guaranteed to output all relations of
    //! length 2 before any relations of length 3. If called repeatedly after
    //! Semigroup::reset_next_relation, and until relation is empty, the values
    //! placed in \p relation correspond to a length-reducing confluent
    //! rewriting system that defines the semigroup.
    //!
    //! This method can be used in conjunction with Semigroup::factorisation to
    //! obtain a presentation defining the semigroup.
    //!
    //! See also Semigroup::reset_next_relation.
    void next_relation(std::vector<size_t>& relation);

    //! Enumerate the semigroup until \p limit elements are found or \p killed
    //! is \c true.
    //!
    //! This is the main method of the Semigroup class, where the
    //! Froidure-Pin Algorithm is implemented.
    //!
    //! If the semigroup is already fully enumerated, or the number of elements
    //! previously enumerated exceeds \p limit, then calling this method does
    //! nothing. Otherwise, enumerate attempts to find at least the maximum of
    //! \p limit and Semigroup::batch_size elements of the semigroup. If \p
    //! killed is set to \c true (usually by another process), then the
    //! enumeration is terminated as soon as possible.  It is possible to
    //! resume enumeration at some later point after any call to this method,
    //! even if it has been killed.
    //!
    //! If the semigroup is fully enumerated, then it knows its left and right
    //! Cayley graphs, and a minimal factorisation of every element (in terms of
    //! its generating set).  All of the elements are stored in memory until the
    //! object is destroyed.
    //!
    //! The parameter \p limit defaults to Semigroup::LIMIT_MAX.
    void enumerate(std::atomic<bool>& killed, size_t limit = LIMIT_MAX);

    //! Enumerate the semigroup until \p limit elements are found.
    //!
    //! See Semigroup::enumerate(std::atomic<bool>& killed, size_t limit) for
    //! more details.
    void enumerate(size_t limit = LIMIT_MAX) {
      std::atomic<bool> killed(false);
      enumerate(killed, limit);
    }

    //! Add copies of the generators \p coll to the generators of \c this.
    //!
    //! This method can be used to add new generators to the existing semigroup
    //! in such a way that any previously enumerated data is preserved and not
    //! recomputed, or copied. This can be faster than recomputing the semigroup
    //! generated by the old generators and the new generators in the parameter
    //! \p coll.
    //!
    //! This method changes the semigroup in-place, thereby invalidating
    //! possibly previously known data about the semigroup, such as the left or
    //! right Cayley graphs, number of idempotents, and so on.
    //!
    //! Every generator in \p coll is added regardless of whether or not it is
    //! already a generator or element of the semigroup (it may belong to the
    //! semigroup but just not be known to belong). If \p coll is empty, then
    //! the semigroup is left unchanged. The order the generators is added is
    //! also the order they occur in the parameter \p coll.
    //!
    //! The semigroup is returned in a state where all of the previously
    //! enumerated elements which had been multiplied by all of the old
    //! generators, have now been multiplied by all of the old and new
    //! generators. This means that after this method is called the semigroup
    //! might contain many more elements than before (whether it is fully
    //! enumerating or not).  It can also be the case that the new generators
    //! are the only new elements, unlike, say, in the case of non-trivial
    //! groups.
    //!
    //! The elements the argument \p coll are copied into the semigroup, and
    //! should be deleted by the caller.
    void add_generators(const std::vector<Element*>* coll);

    //! Add copies of the generators \p coll to the generators of \c this.
    //!
    //! See Semigroup::add_generators for more details.
    void add_generators(std::vector<Element*> const& coll);

    //! Returns a new semigroup generated by \c this->gens() and \p coll.
    //!
    //! This method is equivalent to copying \c this using
    //! Semigroup::Semigroup(const Semigroup& copy) and then calling
    //! Semigroup::add_generators on the copy, but this method avoids copying
    //! the parts of \c this that are immediately invalidated by
    //! Semigroup::add_generators.
    //!
    //! The elements the argument \p coll are copied into the semigroup, and
    //! should be deleted by the caller.
    Semigroup* copy_add_generators(const std::vector<Element*>* coll) const;

    //! Add copies of the non-redundant generators in \p coll to the generators
    //! of \c this.
    //!
    //! This method can be used to add new generators to an existing semigroup
    //! in such a way that any previously enumerated data is preserved and not
    //! recomputed, or copied. This can be faster than recomputing the semigroup
    //! generated by the old generators and the new in \p coll.
    //!
    //! This method differs from Semigroup::add_generators in that it tries to
    //! add the new generators one by one, and only adds those generators that
    //! are not products of existing generators (including any new generators
    //! from \p coll that were added before). The generators are added in the
    //! order they occur in \p coll.
    //!
    //! This method changes the semigroup in-place, thereby
    //! invalidating possibly previously known data about the semigroup, such as
    //! the left or right Cayley graphs, or number of idempotents, for example.
    //!
    //! The elements the parameter \p coll are copied into the semigroup, and
    //! should be deleted by the caller.
    void closure(const std::vector<Element*>* coll);

    //! Add copies of the non-redundant generators in \p coll to the
    //! generators of \c this.
    //!
    //! See Semigroup::closure for more details.
    void closure(std::vector<Element*> const& coll);

    //! Returns a new semigroup generated by \c this->gens() and copies of the
    //! non-redundant elements of \p coll.
    //!
    //! This method is equivalent to copying \c this and then calling
    //! Semigroup::closure on the copy with \p coll, but this method avoids
    //! copying the parts of \c this that are immediately invalidated by
    //! Semigroup::closure.
    //!
    //! The elements the argument \p coll are copied into the semigroup, and
    //! should be deleted by the caller.
    Semigroup* copy_closure(std::vector<Element*> const* coll);

    //! This variable is used to indicate that a value is undefined, such as,
    //! for example, the position of an element that does not belong to a
    //! semigroup.
    static size_t const UNDEFINED;

    //! This variable is used to indicate the maximum possible limit that can
    //! be used with Semigroup::enumerate.
    static size_t const LIMIT_MAX;

    //! Turn reporting on or off.
    //
    //!  If \p val is true, then some methods for a Semigroup object may
    //! report information about the progress of the computation.
    void set_report(bool val) const {
      glob_reporter.set_report(val);
    }

    //! Set the maximum number of threads that any method of an instance of
    //! Semigroup can use.
    //!
    //! This method sets the maximum number of threads to be used by any method
    //! of a Semigroup object. The number of threads is limited to the maximum
    //! of 1 and the minimum of \p nr_threads and the number of threads
    //! supported by the hardware.
    void set_max_threads(size_t nr_threads) {
      unsigned int n =
          static_cast<unsigned int>(nr_threads == 0 ? 1 : nr_threads);
      _max_threads = std::min(n, std::thread::hardware_concurrency());
    }

   private:
    // Initialise the data member _sorted. We store a list of pairs consisting
    // of an Element* and pos_t which is sorted on the first entry using
    // the myless subclass. This is done so that we can both get the elements
    // in sorted order, and find the position of an element in the sorted list
    // of elements.

    void sort_elements();

    // Find the idempotents and store their positions and their number
    void find_idempotents();

    // Function for counting idempotents in a thread, changes the parameter nr
    // in place.

    void idempotents_thread(size_t&             nr,
                            std::vector<pos_t>& idempotents,
                            std::vector<bool>&  is_idempotent,
                            pos_t               begin,
                            pos_t               end);

    // Expand the data structures in the semigroup with space for nr elements

    void inline expand(size_t nr) {
      _left->add_rows(nr);
      _reduced.add_rows(nr);
      _right->add_rows(nr);
      _multiplied.resize(_multiplied.size() + nr, false);
    }

    // Check if an element is the identity, x should be in the position pos
    // of _elements.

    void inline is_one(Element const* x, pos_t pos) {
      if (!_found_one && *x == *_id) {
        _pos_one   = pos;
        _found_one = true;
      }
    }

    // Update the data structure in add_generators
    void inline closure_update(pos_t              i,
                               letter_t           j,
                               letter_t           b,
                               letter_t           s,
                               std::vector<bool>& old_new,
                               pos_t              old_nr,
                               size_t const&      thread_id);

    struct myless {
      // For sorting the elements of \c this.
      explicit myless(Semigroup const& semigroup) : _semigroup(semigroup) {}

      bool operator()(std::pair<Element const*, size_t> const& x,
                      std::pair<Element const*, size_t> const& y) {
        return *(x.first) < *(y.first);
      }

      Semigroup const& _semigroup;
    };

    void copy_gens();

    size_t _batch_size;
    size_t _degree;
    std::vector<std::pair<letter_t, letter_t>> _duplicate_gens;
    std::vector<Element*>* _elements;
    std::vector<letter_t>  _final;
    std::vector<letter_t>  _first;
    bool                   _found_one;
    std::vector<Element*>* _gens;
    Element*               _id;
    std::vector<size_t>    _idempotents;
    bool                   _idempotents_found;
    pos_t                  _idempotents_start_pos;
    std::vector<bool>      _is_idempotent;
    std::vector<pos_t>     _index;
    cayley_graph_t*        _left;
    std::vector<pos_t>     _length;
    std::vector<size_t>    _lenindex;
    std::vector<pos_t>     _letter_to_pos;
    std::unordered_map<const Element*, size_t, Element::Hash, Element::Equal>
                         _map;
    size_t               _max_threads;
    std::vector<bool>    _multiplied;
    std::mutex           _mtx;
    size_t               _nr;
    size_t               _nrgens;
    size_t               _nr_idempotents;
    size_t               _nrrules;
    index_t              _pos;
    pos_t                _pos_one;
    std::vector<size_t>* _pos_sorted;
    std::vector<pos_t>   _prefix;
    flags_t              _reduced;
    letter_t             _relation_gen;
    pos_t                _relation_pos;
    cayley_graph_t*      _right;
    std::vector<std::pair<Element*, size_t>>* _sorted;
    std::vector<size_t> _suffix;
    Element*            _tmp_product;
    size_t              _wordlen;
  };

}  // namespace libsemigroups

#endif  // LIBSEMIGROUPS_SEMIGROUPS_H_
