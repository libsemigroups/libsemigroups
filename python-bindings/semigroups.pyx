#cython: infer_types=True, embedsignature=True
"""
Python bindings for the libsemigroups C++ library.

`libsemigroups <https://github.com/james-d-mitchell/libsemigroups/>`_
is a C++ mathematical library for computing with finite `semigroups
<https://en.wikipedia.org/wiki/Semigroup>`_. This Cython module
provides bindings to call it from Python.

We construct the semigroup generated by `0` and `-1`::

    >>> from semigroups import Semigroup
    >>> S = Semigroup([0,-1])
    >>> S.size()
    3

We construct the semigroup generated by `0` and complex number `i`::

    >>> S = Semigroup([0, 1j])
    >>> S.size()
    5
"""
from libc.stdint cimport uint16_t
from libcpp.vector cimport vector
cimport semigroups_cpp as cpp
from libcpp cimport bool
from libcpp.string cimport string
from libcpp.pair cimport pair
from libc.stdint cimport uint32_t
from libc.stdint cimport uint64_t

#cdef class MyCppElement(cpp.Element):
#    pass


cdef class Element:
    """
    An abstract base class for handles to libsemigroups elements.

    Any subclass shall implement an ``__init__`` method which
    initializes _handle.

    .. WARNING::

        For now, the ``__init__`` method should also accept to be
        called with ``None`` as argument, in which case it *should
        not* initialize the handle.

        This is used by ``new_from_handle``.

    .. TODO::

        Find a better protocol to create an instance from a class and
        a handle.
    """
    cdef cpp.Element* _handle

    def __cinit__(self):
        self._handle = NULL

    def __dealloc__(self):
        """
        Deallocate the handle of ``self``.

        TESTS::

            >>> from semigroups import Semigroup, PythonElement, Transformation
            >>> x = PythonElement(-1)
            >>> x = 3

            >>> x = Transformation([1,2,0])
            >>> del x
        """
        if self._handle != NULL:
            self._handle[0].really_delete()
            del self._handle

    def __mul__(Element self, Element other):
        """
        Return the product of ``self`` and ``other``.

        EXAMPLES::

            >>> from semigroups import Semigroup, PythonElement, Transformation
            >>> x = Transformation([2,1,1])
            >>> y = Transformation([2,1,0])
            >>> x * y
            [0, 1, 1]
            >>> y * x
            [1, 1, 2]
        """
        cdef cpp.Element* product = self._handle.identity()
        assert self._handle.degree() == other._handle.degree()
        product.redefine(self._handle, other._handle)
        return self.new_from_handle(product)
    
    def __richcmp__(Element self, Element other, int op):
        """Ref: http://docs.cython.org/src/userguide/special_methods.html#rich-comparisons"""
        if op==2:
            # op==2 is __eq__() in pure python
            if self._handle[0] == other._handle[0]:
                return True
            return False
        elif op==0:
            if self._handle[0] < other._handle[0]:
                return True
            return False
        # TODO more comparisons!
        else:
            err_msg = "op {0} isn't implemented yet".format(op)
            raise NotImplementedError(err_msg)
    
    # TODO: Make this a class method
    cdef new_from_handle(self, cpp.Element* handle):
        """
        Construct a new element from a specified handle and with the
        same class as ``self``.
        """
        cdef Element result = self.__class__(None)
        result._handle = handle[0].really_copy()
        return result

cdef class Transformation(Element):
    """
    A class for handles to libsemigroups transformations.

    EXAMPLES::

        >>> from semigroups import Semigroup, PythonElement, Transformation
        >>> Transformation([2,1,1])
        [2, 1, 1]
    """
    def __init__(self, iterable):
        if iterable is not None:
            self._handle = new cpp.Transformation[uint16_t](iterable)

    def __iter__(self):
        """
        Return an iterator over ``self``

        EXAMPLES::

            >>> from semigroups import Transformation
            >>> list(Transformation([1,2,0]))
            [1, 2, 0]
        """
        cdef cpp.Element* e = self._handle
        e2 = <cpp.Transformation[uint16_t] *>e
        for x in e2[0]:
            yield x

    def __repr__(self):
        """
        Return a string representation of `self`.

        EXAMPLES::

            >>> from semigroups import Transformation
            >>> Transformation([1,2,0])
            [1, 2, 0]
        """
        return "Transformation(" + str(list(self)) + ")"

cdef class PartialPerm(Element):
    """
    A class for handles to libsemigroups partial perm.
    """
    def __init__(self, *args):
        if len(args) == 1 and args[0] == None:
            return
        #TODO check the args 
        dom, ran, deg = args[0], args[1], args[2]
        assert max(dom) < deg and max(ran) < deg
        assert type(deg) is int
        imglist = [-1] * deg
        for x in dom:
            imglist[x] = ran[x]

        self._handle = new cpp.PartialPerm[uint16_t](imglist)

    def __iter__(self):
        cdef cpp.Element* e = self._handle
        e2 = <cpp.PartialPerm[uint16_t] *>e
        for x in e2[0]:
            yield x

    def __repr__(self):
        """
        Return a string representation of `self`.

        EXAMPLES::

            >>> from semigroups import PartialPerm
            >>> PartialPerm([1,2,0])
            [1, 2, 0]
        """
        return "PartialPerm(" + str(list(self)) + ")"

cdef class PythonElement(Element):
    """
    A class for handles to libsemigroups elements that themselves wrap
    back a Python element

    EXAMPLE::

        >>> from semigroups import Semigroup, PythonElement
        >>> x = PythonElement(-1); x
        -1

        >>> Semigroup([PythonElement(-1)]).size()
        2
        >>> Semigroup([PythonElement(1)]).size()
        1
        >>> Semigroup([PythonElement(0)]).size()
        1
        >>> Semigroup([PythonElement(0), PythonElement(-1)]).size()
        3

        x = [PythonElement(-1)]
        x = 2

        sage: W = SymmetricGroup(4)
        sage: pi = W.simple_projections()
        sage: F = FiniteSetMaps(W)
        sage: S = Semigroup([PythonElement(F(p)) for p in pi])
        sage: S.size()
        23

    TESTS::

        Testing reference counting::

            >>> s = "UN NOUVEL OBJET"
            >>> sys.getrefcount(s)
            2
            >>> x = PythonElement(s)
            >>> sys.getrefcount(s)
            3
            >>> del x
            >>> sys.getrefcount(s)
            2
    """
    def __init__(self, value):
        if value is not None:
            self._handle = new cpp.PythonElement(value)

    def get_value(self):
        """

        """
        return (<cpp.PythonElement *>self._handle).get_value()

    def __repr__(self):
        return repr(self.get_value())

cdef class Semigroup:
    """
    A class for handles to libsemigroups semigroups

    EXAMPLES:

    We construct the symmetric group::

        >>> from semigroups import Semigroup, Transformation
        >>> S = Semigroup([Transformation([1,2,0]),Transformation([2,1,0])])
        >>> S.size()
        6
    """
    cdef cpp.Semigroup* _handle      # holds a pointer to the C++ instance which we're wrapping
    cdef Element _an_element

    def __cinit__(self):
        self._handle = NULL

    def __init__(self, generators):
        """
        TESTS::

            >>> Semigroup([1, Transformation([1,0])])
            ...
            TypeError: all generators should have the same type
        """
        generators = [g if isinstance(g, Element) else PythonElement(g)
                      for g in generators]
        if not len({type(g) for g in generators}) <= 1:
            raise TypeError("all generators should have the same type")
        cdef vector[cpp.Element *] gens
        for g in generators:
            gens.push_back((<Element>g)._handle)
        self._handle = new cpp.Semigroup(gens)
        self._an_element = generators[0]

    def __dealloc__(self):
        del self._handle

    def current_max_word_length(self):
        return self._handle.current_max_word_length()

    def nridempotents(self):
        return self._handle.nridempotents()
    
    def is_done(self):
        return self._handle.is_done()
    
    def is_begun(self):
        return self._handle.is_begun()
    
    def current_position(self, Element x):
        pos = self._handle.current_position(x._handle)
        if pos == -1:
            return None # TODO Ok?
        return pos
    
    def __contains__(self, Element x):
        return self._handle.test_membership(x._handle)

    def set_report(self, val):
        if val == True:
            self._handle.set_report(1)
        else:
            self._handle.set_report(0)

    def factorisation(self, Element x):
        '''
        >>> import from semigroups *
        >>> S = FullTransformationMonoid(5)
        >>> S.factorisation(Transformation([0] * 5))
        [1, 0, 2, 1, 0, 2, 1, 0, 2, 1]
        >>> S[1] * S[0] * S[2] * S[1] * S[0] * S[2] * S[1] * S[0] * S[2] * S[1]
        '''
        pos = self._handle.position(x._handle)
        if pos == -1:
            return None # TODO Ok?
        cdef vector[size_t]* c_word = self._handle.factorisation(pos)
        assert c_word != NULL
        py_word = [letter for letter in c_word[0]]
        del c_word
        return py_word
    
    def enumerate(self, limit):
        self._handle.enumerate(limit)

    def size(self):
        """
        Return the size of this semigroup

        EXAMPLES::

            >>> from semigroups import Semigroup, Transformation
            >>> S = Semigroup([Transformation([1,1,4,5,4,5]),Transformation([2,3,2,3,5,5])])
            >>> S.size()
            5
        """
        # Plausibly wrap in sig_off / sig_on
        return self._handle.size()

    cdef new_from_handle(self, cpp.Element* handle):
        return self._an_element.new_from_handle(handle)

    def __getitem__(self, size_t pos):
        """
        Return the ``pos``-th element of ``self``.

        EXAMPLES::

            >>> from semigroups import Semigroup
            >>> S = Semigroup([1j])
            >>> S[0]
            1j
            >>> S[1]
            (-1+0j)
            >>> S[2]
            (-0-1j)
            >>> S[3]
            (1-0j)
        """
        cdef cpp.Element* element
        element = self._handle.at(pos)
        if element == NULL:
            return None
        else:
            return self.new_from_handle(element)

    def __iter__(self):
        """
        An iterator over the elements of self.

        EXAMPLES::

            >>> from semigroups import Semigroup
            >>> S = Semigroup([1j])
            >>> for x in S:
            ...     print(x)
            1j
            (-1+0j)
            (-0-1j)
            (1-0j)
        """
        cdef size_t pos = 0
        cdef cpp.Element* element
        while True:
            element = self._handle.at(pos)
            if element == NULL:
                break
            else:
                yield self.new_from_handle(element)
            pos += 1

def FullTransformationMonoid(n):
    assert isinstance(n, int) and n >= 1
    if n == 1: 
        return Semigroup(Transformation([0]))
    elif n == 2:
        return Semigroup(Transformation([1, 0]), Transformation([0, 0]))
    
    return Semigroup([Transformation([1, 0] + list(range(2, n))), 
                      Transformation([0, 0] + list(range(2, n))), 
                      Transformation([n - 1] + list(range(n - 1)))])

cdef class FpSemigroup(Semigroup):
    """FpSemigroup Object

    Examples:
        >>> FpSemigroup(["a","b"],[["aa","a"],["bbb","ab"],["ab","ba"]])
        <Fpsemigroup <a,b|aa=a,bbb=ab,ab=ba>>
        >>> FpSemigroup([1,2],[[[1,1],[1]],[[2,2,2],[1,2]],[[1,2],[2,1]]])
        <Fpsemigroup <1,2|11=1,222=12,12=21>>

    Todo:
         write == method  
         write normal_form method
         test compatability with existing semigroup member functions
         add link to documentation for functions when it becomes available.
    """    

    cdef cpp.Congruence* _congruence

    cdef cpp.RWS* _rws
    
    #list of single character strings which store the alphabet
    #(even if using integer notation)
    cdef vector[string] _alphabet

    cdef vector[pair[vector[uint64_t],vector[uint64_t]]] _relations

    #a vector of relations used to define a congruence
    cdef vector[pair[vector[uint64_t],vector[uint64_t]]] _extra

    #a boolean which is true when string notation is used for words 
    #and false when integer notation is used for words
    cdef bool _is_string_alphabet

    cdef size_t _size 
    
    #a string containing "twosided" which is used to define a congruence
    cdef string _cong

    def __init__(self, alphabet, rels):
        '''
        Construct an FpSemigroup from generators and relations.
        
        Args:
            alphabet (list): the generators of the fp semigroup, must be 
            either a list of ints or a list of strings of length 1.

            rels (list): the relations containing pairs of words which are
            equivalent in the given FpSemigroup, must be a list of length 2 
            lists of lists of ints or a list of length 2 lists of strings.

        Returns:
            None.

        Raises:
            TypeError: If the alphabet is not a list of integers or strings,
            if the relations are not a double nested list of integers or a
            nested list strings.

            ValueError: If the alphabet contains repeated elements, if any of
            the lists which are supposed to contain pairs of words don't 
            contain 2 elements or any of the words in relations use generators
            not in the given alphabet.
        '''
        if not isinstance(alphabet,list):
            raise TypeError("alphabet should be a list")
        self._size = len(alphabet)
        self._cong = "twosided"
        
        # Checks if semigroup is empty.
        if self._size > 0:
            if not(isinstance(alphabet[0],int) or isinstance(alphabet[0],str)):
                raise TypeError("alphabet should contain characters or ints")
            self._is_string_alphabet = isinstance(alphabet[0],str)

            # Check that the alphabet does not contain duplicates.
            for i in alphabet:
                if not alphabet.count(i)==1:
                    raise ValueError("alphabet elements shouldn't be repeated")

            if not isinstance(rels,list):
                raise TypeError("relations should be stored n a list")

            if self._is_string_alphabet:
                for i in xrange(len(rels)):
                    if not isinstance(rels[i],list):
                        raise TypeError("each relation should"+ 
                                        " be a pair of lists")

                    if not len(rels[i]) == 2:
                        raise ValueError("each relation should "+ 
                                         "be a pair of lists")

                    for j in [0,1]:
                        if not isinstance(rels[i][j],str):
                            raise TypeError("if alphabet contains characters"+
                                  " then relations should be pairs of strings")
                        rels[i][j] = list(rels[i][j])
                        for k in xrange(len(rels[i][j])):
                            if not rels[i][j][k] in alphabet:
                                raise ValueError("elements referenced in "+
                                  "relations should be in the given alphabet")
                            rels[i][j][k]=alphabet.index(rels[i][j][k])
            else:
                for i in xrange(len(rels)):
                    if not isinstance(rels[i],list):
                        raise TypeError("each relation should "+
                                        "be a pair of lists")
                    if not len(rels[i]) == 2:
                        raise ValueError("each relation should"+
                                        " be a pair of lists")
                    for j in [0,1]:
                        if not isinstance(rels[i][j],list):
                            raise TypeError("each word in relations should"+
                                            " be represented by a list")
                        for k in xrange(len(rels[i][j])):
                            if not isinstance(rels[i][j][k],int):
                                raise TypeError("elements referenced in"+
                                  " relations should be in the given alphabet")
                            if not rels[i][j][k] in alphabet:
                                raise ValueError("elements referenced in"+
                                " relations should be in the given alphabet")
                            rels[i][j][k]=alphabet.index(rels[i][j][k])
        else:
            #Checks that not attempting to define relations on empty semigroup.
            if not len(rels)==0: raise ValueError("empty semigroup can't have"+
                                                    " any valid relations")
            self._is_string_alphabet = True

        #stores alphabet as a c string vector(even if input is integer vector)
        self._alphabet = [str(i).encode('UTF-8')for i in alphabet]
        self._relations = rels
        self._extra = rels
        self._congruence = new cpp.Congruence(self._cong,self._size,
                                                self._relations,self._extra)

    #TODO write == method for FpSemigroup
    def size(self):
        '''
        Compute the size of an FpSemigroup (when finite).

        Examples:
            >>> FpSemigroup(["a","b"],[["aa","a"],["bbb","ab"],
                                                  ["ab","ba"]]).size()
            5
            >>> FpMonoid(["a","b"],[["aa","a"],["bbb","ab"],
                                                  ["ab","ba"]]).size()
            6
            >>> FpMonoid(["a","b"],[["aa","a"],["bbb","ab"],
                                                  ["ab","ba"]]).size()
            6
            >>> FpMonoid([1,2],[[[1,1],[1]],[[2,2,2,2,2],[2]],
                                                  [[1,2],[2,1]]]).size()
            10

        Args:
            None.

        Returns:
            int: The size of the FpSemigroup.

        Raises:
            None.
        '''
        return self._congruence.nr_classes()

    def is_finite(self):
        '''
        attempts to check if a given FpSemigroup is finite(not always possible)

        Examples:
            >>> FpSemigroup(["a","b"],[["aa","a"],["bbb","ab"],
                                                  ["ab","ba"]]).is_finite()
            True
            >>> FpSemigroup(["a","b"],[]).is_finite()
            False

        Args:
            None.

        Returns:
            bool: True for finite, False otherwise.

        Raises:
            None.
        '''
        if len(self._relations) < len(self._alphabet):return False
        
        for i in xrange(len(self._alphabet)):
            check = False
            for j in self._relations:
                if i in list(j.first) or i in list(j.second):
                    check=True
            if not check:return False
        self.size()
        return True

    def set_report(self, val):
        '''
        toggles wheather or not to report data when running certain functions

        Examples:
            None.

        Args:
            bool:toggle to True or False

        Returns:
            None.

        Raises:
            None.
        '''
        if not (val == True or val == False):
            raise TypeError("set report input should be a boolean")
        if val:
            self._congruence.set_report(1)
        else:
            self._congruence.set_report(0)

    def set_max_threads(self, nr_threads):
        '''
        sets the maximum number of threads to be used at once.

        Examples:
            None.

        Args:
            int:number of threads

        Returns:
            None.

        Raises:
            None.
        '''
        return self._congruence.set_max_threads(nr_threads)

    def alphabet(self):
        '''
        returns the alphabet of the FpSemigroup.

        Examples:
            >>> FpSemigroup(["a","b"],[["aa","a"],["bbb","ab"],
                                                  ["ab","ba"]]).alphabet()
            ['a', 'b']
            >>> FpSemigroup([1,2],[[[1,1],[1]],[[2,1,2],[1,2]],
                                               [[1,2],[2,1]]]).alphabet()
            [1, 2]

        Args:
            None.

        Returns:
            list: the alphabet of the semigroup as a list.

        Raises:
            None.
        '''
        if self._is_string_alphabet:
            return [str(i)[2:-1]for i in self._alphabet]
        else:
            return [int(i)for i in self._alphabet]

    def is_confluent(self):
        '''
        check if the relations of the FpSemigroup are confulent.

        Examples:
            >>> FpSemigroup(["a","b"],[["aa","a"],["bbb","ab"],
                                                  ["ab","ba"]]).is_confluent()
            True
            >>> FpSemigroup(["a","b"],[["aa","a"],["bab","ab"],
                                                  ["ab","ba"]]).is_confluent()
            False

        Args:
            None.

        Returns:
            bool: True for confluent, False otherwise.

        Raises:
            None.
        '''
        self._rws = new cpp.RWS(self._relations)
        return self._rws.is_confluent()

    def word_to_class_index(self,word):
        '''
        returns the class index of a given word

        Examples:
        >>> FpS=FpSemigroup(["a","b"],[["aa","a"],["bab","ab"],["ab","ba"]])
        >>> FpS.word_to_class_index(FpSemigroupElement(FpS,"a"))
        0
        >>> FpS.word_to_class_index(FpSemigroupElement(FpS,"b"))
        1
        >>> FpS=FpSemigroup([1,2],[[[1,1],[1]],[[2,1,2],[1,2]],[[1,2],[2,1]]])
        >>> FpS.word_to_class_index(FpSemigroupElement(FpS,[1]))
        0
        >>> FpS.word_to_class_index(FpSemigroupElement(FpS,[2]))
        1

        Args:
            FpSemigroupElement:word whose class index is to be returned.

        Returns:
            int: class index of the given word.

        Raises:
            TypeError: if 1st argument is not an FpSemigroupElement.
            ValueError: if 1st argument is an FpSemigroupElement 
            but not in this semigroup.
        '''
        if not isinstance(word,FpSemigroupElement):
            raise TypeError("given word is not an FpSemigroupElement")

        if isinstance(word,FpSemigroupElement):
            if not word.semigroup() is self:
                raise ValueError("given word is not in given semigroup")
            word=word.word()

        if isinstance(word,str):word=list(word)
        
        for i in xrange(len(word)):
            word[i]=self.alphabet().index(word[i])

        cdef vector[uint64_t] Word = word
        return self._congruence.word_to_class_index(Word)


    def __dealloc__(self):
        '''
        deletes c objects when semigroup is deleted

        Examples:
            None.

        Args:
            None.

        Returns:
            None.

        Raises:
            None.
        '''
        del self._congruence
        del self._rws

    def __repr__(self):
        '''
        displays the FpSemigroup via it's generators and relations
        (or the number of them if ouput would be too long)

        Examples:
        >>> FpSemigroup(["a","b"],[["aa","a"],["bbb","ab"],["ab","ba"]])
        <Fpsemigroup <a,b|aa=a,bbb=ab,ab=ba>>
        >>> FpSemigroup([1,2],[[[1,1],[1]],[[2,2,2],[1,2]],[[1,2],[2,1]]])
        <Fpsemigroup <1,2|11=1,222=12,12=21>>

        Args:
            None.

        Returns:
            str: <FpSemigroup with 'generators'|'relations'>>

        Raises:
            None.
        '''
        repalphabet = ','.join([str(j)[2:-1]for j in self._alphabet])
        reprelations=','.join([''.join([str(self._alphabet[j])[2:-1]
         for j in i.first]+["="]+[str(self._alphabet[j])[2:-1]
         for j in i.second])for i in self._relations])
        rep="<FpSemigroup <" + repalphabet + "|" + reprelations + ">>"
        if len(rep)<80:
            return rep
        else:
            return "<FpSemigroup with " + str(len(self._alphabet)) + \
            " generators and " + str(len(self._relations)) + " relations>"

cdef class FpMonoid(FpSemigroup):
    """FpMonoid Object

    Examples:
    >>> FpMonoid(["a","b"],[["aa","a"],["bbb","ab"],["ab","ba"]])
    <FpMonoid <a,b|aa=a,bbb=ab,ab=ba>>
    >>> FpMonoid([1,2],[[[1,1],[1]],[[2,2,2],[1,2]],[[1,2],[2,1]]])
    <FpMonoid <1,2|11=1,222=12,12=21>>

    """    
    cdef vector[pair[vector[uint64_t],vector[uint64_t]]] _e_relations

    cdef vector[string] _e_alphabet

    def __init__(self, alphabet, rels):
        '''
        Construct an FpMonoid from generators and relations.
        
        Args:
            alphabet (list): the generators of the FpMonoid, must be 
            either a list of ints or a list of strings of length 1.

            rels (list): the relations containing pairs of words which are
            equivalent in the given FpMonoid, must be a list of length 2 
            lists of lists of ints or a list of length 2 lists of strings.

        Returns:
            None.

        Raises:
            TypeError: If the alphabet is not a list of integers or strings,
            if the relations are not a double nested list of integers or a
            nested list strings.

            ValueError: If the alphabet contains repeated elements, if the 
            alphabet uses the character 'e' or integer 0, if any of
            the lists which are supposed to contain pairs of words don't 
            contain 2 elements or any of the words in relations use generators
            not in the given alphabet.
        '''
        if not isinstance(alphabet,list):
            raise TypeError("alphabet should be a list")
        self._size = len(alphabet)
        self._cong = "twosided"
        
        # Checks if monoid is trivial.
        if self._size > 0:
            if not (isinstance(alphabet[0],int) or 
            isinstance(alphabet[0],str)):
                raise TypeError("alphabet should contain"+
                    " characters or integers")
            self._is_string_alphabet = isinstance(alphabet[0],str)

            # Check that the alphabet does not contain duplicates.
            for i in alphabet:
                if not alphabet.count(i)==1:
                    raise ValueError("alphabet should not"+
                                    " have repeated elements")

            if not isinstance(rels,list):
                raise TypeError("relations should be stored n a list")
            if self._is_string_alphabet:
                if 'e' in alphabet: raise ValueError("alphabet can't"+
                    " contain 'e' as this is reserved for the identity")
                for i in xrange(len(rels)):
                    if not isinstance(rels[i],list):
                        raise TypeError("each relation should be" 
                                        + " a pair of lists")
                    if not len(rels[i]) == 2: 
                        raise ValueError("each relation should"+
                                        " be a pair of lists")
                    for j in [0,1]:
                        if not isinstance(rels[i][j],str):
                            raise TypeError("if alphabet contains characters "
                            + "then relations should be pairs of strings")
                        rels[i][j] = list(rels[i][j])
                        for k in xrange(len(rels[i][j])):
                            if not rels[i][j][k] in ['e']+alphabet:
                                raise ValueError("elements referenced in "+
                                "relations should be in the given alphabet")
                            rels[i][j][k]=(['e']+alphabet).index(rels[i][j][k])
            else:
                if 0 in alphabet:
                    raise ValueError("alphabet can't contain 0 as this"+
                                    " is reserved for the identity")
                for i in xrange(len(rels)):
                    if not isinstance(rels[i],list):
                        raise TypeError("each relation should be"+
                                        " a pair of lists")
                    if not len(rels[i]) == 2:
                        raise ValueError("each relation should be"+
                                        " a pair of lists")
                    for j in [0,1]:
                        if not isinstance(rels[i][j],list):
                            raise TypeError("each word in relations "+
                                            "should be represented by a list")
                        for k in xrange(len(rels[i][j])):
                            if not isinstance(rels[i][j][k],int):
                                raise TypeError("elements referenced in "+
                                "relations should be in the given alphabet")
                            if not rels[i][j][k] in [0]+alphabet:
                                raise ValueError("elements referenced in "+
                                "relations should be in the given alphabet")
                            rels[i][j][k]=([0]+alphabet).index(rels[i][j][k])
        else:
            # Checks that not attempting to define relations on trivial monoid.
            if not len(rels)==0:
                raise ValueError("trivial monoid can't have any valid relations")
            self._is_string_alphabet = True

        #stores alphabet as a c string vector(even if input is integer vector)
        self._alphabet = [str(i).encode('UTF-8')for i in alphabet]
        self._relations = rels
        self._extra = rels

        if self._is_string_alphabet:
            self._e_alphabet = [str(i).encode('UTF-8')for i in ['e']+alphabet]
        else:
            self._e_alphabet = [str(i).encode('UTF-8')for i in [0]+alphabet]

        lefteq = [[[i+1,0],[i+1]]for i in xrange(self._size)]
        righteq = [[[0,i+1],[i+1]]for i in xrange(self._size)]

        self._e_relations = rels + [[[0,0],[0]]] + lefteq + righteq
        self._congruence = new cpp.Congruence(self._cong,self._size + 1,
                                                self._e_relations,self._extra)


    def alphabet(self):
        '''
        returns the alphabet of the FpMonoid(including the identity which is represented as 0 or 'e').

        Examples:
            >>> FpMonoid(["a","b"],[["aa","a"],["bbb","ab"],["ab","ba"]]).alphabet()
            ['e', 'a', 'b']
            >>> FpMonoid([1,2],[[[1,1],[1]],[[2,1,2],[1,2]],[[1,2],[2,1]]]).alphabet()
            [0, 1, 2]

        Args:
            None.

        Returns:
            list: the alphabet of the monoid as a list.

        Raises:
            None.
        '''
        if self._is_string_alphabet:
            return [str(i)[2:-1]for i in self._e_alphabet]
        else:
            return [int(i)for i in self._e_alphabet]

    def __repr__(self):
        '''
        displays the FpMonoid via it's generators and relations
        (or the number of them if ouput would be too long)

        Examples:
            >>> FpMonoid(["a","b"],[["aa","a"],["bbb","ab"],["ab","ba"]])
            <FpMonoid <a,b|aa=a,bbb=ab,ab=ba>>
            >>> FpMonoid([1,2],[[[1,1],[1]],[[2,2,2],[1,2]],[[1,2],[2,1]]])
            <FpMonoid <1,2|11=1,222=12,12=21>>

        Args:
            None.

        Returns:
            str: <FpMonoid with 'generators'|'relations'>>

        Raises:
            None.
        '''
        repalphabet = ','.join([str(j)[2:-1]for j in self._alphabet])
        reprelations=','.join(
                    [''.join([str(self._e_alphabet[j])[2:-1]for j in i.first]+
                    ["="]+[str(self._e_alphabet[j])[2:-1]for j in i.second])
                    for i in self._relations])

        rep="<FpMonoid <" + repalphabet + "|" + reprelations + ">>"
        if len(rep)<80:
            return rep
        else:
            return "<FpMonoid with %s generators and %s relations>"%(
                    `len(self._alphabet)`,`len(self._relations)`)

cdef class FpSemigroupElement(Element):
    """FpSemigroupElement Object

    Examples:
    >>> FpS=FpSemigroup(["a","b"],[["aa","a"],["bbb","ab"],["ab","ba"]])
    >>> FpSemigroupElement(FpS,"a")
    <FpSemigroup Element 'a'>
    >>> FpSemigroupElement(FpS,"bab")
    <FpSemigroup Element 'bab'>
    >>> FpS=FpSemigroup([1,2],[[[1,1],[1]],[[2,1,2],[1,2]],[[1,2],[2,1]]])
    >>> FpSemigroupElement(FpS,[1])
    <FpSemigroup Element '[1]'>
    >>> FpSemigroupElement(FpS,[2,1,2])
    <FpSemigroup Element '[2, 1, 2]'>


    """ 
    cdef FpSemigroup _FpS
    cdef string _Word

    def __init__(self,FpS,word):
        '''
        Construct an FpSemigroup element from an FpSemigroup and a string.
        
        Args:
            FpS (FpSemigroup): The FpSemigroup of which the given word is 
            an element.
            word (list/string): a string or a list containg generators of
            the given semigroup.

        Returns:
            None.

        Raises:
            TypeError: If 1st argument is not an FpSemigroup object or the
            second argument is not a string or a list.
            ValueError: If the word contains a generator not n the alphabet
            of the given semigroup.
        '''       
        if not isinstance(FpS,FpSemigroup):
            raise TypeError("given Semigroup is not a valid FpSemigroup") 
        if not (isinstance(word,str) or isinstance(word,list)):
            raise TypeError("given word must be a string or list of integers")
        self._FpS = FpS

        for i in word:
                if not i in FpS.alphabet():
                    raise ValueError("given word is not in the given FpMonoid")

        if self._FpS._is_string_alphabet:
            if word =="":
                raise ValueError("empty word not well defined")
            else:
                self._Word = word.encode('UTF-8')
        else:
            if word =="":
                raise ValueError("empty word not well defined")
            else:
                self._Word = str(word).encode('UTF-8')

    def semigroup(self):
        '''
        retrurns the semigroup of which this element is a member.

        Examples:
            >>> FpS=FpSemigroup(["a","b"],[["aa","a"],["bbb","ab"]
                                                     ,["ab","ba"]])
            >>> FpSemigroupElement(FpS,"bab").semigroup()
            <FpSemigroup <a,b|aa=a,bbb=ab,ab=ba>>
            >>> FpS=FpSemigroup([1,2],[[[1,1],[1]],[[2,1,2],[1,2]]
                                                  ,[[1,2],[2,1]]])
            >>> FpSemigroupElement(FpS,[1]).semigroup()
            <FpSemigroup <1,2|11=1,212=12,12=21>>

        Args:
            None.

        Returns:
            FpSemigroup:semigroup of which this element is a member

        Raises:
            None.
        '''
        return self._FpS

    def word(self):
        '''
        retrurns the word representing the element as a string or list.

        Examples:
            >>> FpS=FpSemigroup(["a","b"],[["aa","a"],["bbb","ab"]
                                                     ,["ab","ba"]])
            >>> FpSemigroupElement(FpS,"ab").word()
            'ab'
            >>> FpS=FpSemigroup([1,2],[[[1,1],[1]],[[2,1,2],[1,2]]
                                                  ,[[1,2],[2,1]]])
            >>> FpSemigroupElement(FpS,[1]).word()
            [1]

        Args:
            None.

        Returns:
            string/list:word representing the element as a string or list.

        Raises:
            None.
        '''
        if self._FpS._is_string_alphabet:
            return str(self._Word)[2:-1]
        else:
            return eval(self._Word)
        

    def __mul__(self, other):
        '''
        multiplies 2 FpSemigroup elements(self on left, other on right).

        Examples:
            >>> FpS=FpSemigroup(["a","b"],[["aa","a"],["bbb","ab"]
                                                     ,["ab","ba"]])
            >>> FpSemigroupElement(FpS,"a")*FpSemigroupElement(FpS,"a")
            0
            >>> FpSemigroupElement(FpS,"a")*FpSemigroupElement(FpS,"ab")
            1
            >>> FpS=FpSemigroup([1,2],[[[1,1],[1]],[[2,2,2],[2]]
                                                  ,[[1,2],[2,1]]])
            >>> FpSemigroupElement(FpS,[1])*FpSemigroupElement(FpS,[1])
            0
            >>> FpSemigroupElement(FpS,[1])*FpSemigroupElement(FpS,[1,2])
            1

        Args:
            other (FpSemigroupElement):element to be multiplied by on the right

        Returns:
            int:class index of the solution to the multiplication

        Raises:
            None.
        '''
        if not (isinstance(other,FpSemigroupElement) and 
                self.semigroup() is other.semigroup()):
            raise TypeError("given words are not members"+
                            " of the same FpSemigroup")
        if isinstance(self.semigroup(),FpMonoid):
            return self.semigroup().word_to_class_index(FpMonoidElement(
                            self.semigroup(),self.word() + other.word()))
        else:
            return self.semigroup().word_to_class_index(FpSemigroupElement(
                            self.semigroup(),self.word() + other.word()))

    def __repr__(self):
        '''
        displays the FpSemigroup element

        Examples:
            >>> FpS=FpSemigroup(["a","b"],[["aa","a"],["bbb","ab"]
                                                     ,["ab","ba"]])
            >>> FpSemigroupElement(FpS,"a")
            <FpSemigroup Element 'a'>
            >>> FpSemigroupElement(FpS,"ab")
            <FpSemigroup Element 'ab'>
            >>> FpS=FpSemigroup([1,2],[[[1,1],[1]],[[2,2,2],[2]]
                                                  ,[[1,2],[2,1]]])
            >>> FpSemigroupElement(FpS,[1])
            <FpSemigroup Element '[1]'>
            >>> FpSemigroupElement(FpS,[1,2])
            <FpSemigroup Element '[1, 2]'>

        Args:
            None.

        Returns:
            str: "<FpSemigroup Element 'word'>"

        Raises:
            None.
        '''
        return "<FpSemigroup Element " + str(self._Word)[1:] + ">"

    def __dealloc__(self):
        '''
        deletes c objects when FpSemigroup element is deleted

        Examples:
            None.

        Args:
            None.

        Returns:
            None.

        Raises:
            None.
        '''
        del self._handle

cdef class FpMonoidElement(FpSemigroupElement):
    """FpMonoidElement Object

    Examples:
    >>> FpM=FpMonoid(["a","b"],[["aa","a"],["bbb","ab"],["ab","ba"]])
    >>> FpMonoidElement(FpM,"a")
    <FpMonoid Element 'a'>
    >>> FpMonoidElement(FpM,"bab")
    <FpMonoid Element 'bab'>
    >>> FpM=FpMonoid([1,2],[[[1,1],[1]],[[2,1,2],[1,2]],[[1,2],[2,1]]])
    >>> FpMonoidElement(FpM,[1])
    <FpMonoid Element '[1]'>
    >>> FpMonoidElement(FpM,[2,1,2])
    <FpMonoid Element '[2, 1, 2]'>
    """ 


    def __init__(self,FpM,word):
        '''
        Construct an fpMonoid element from an FpMonoid and a word.
        
        Args:
            FpM (FpMonoid): The FpMonoid of which the given word is an element.
            word (list/string): a string or a list containg generators of the
            given semigroup.

        Returns:
            None.

        Raises:
            TypeError: If 1st argument is not an FpMonoid object or the second
            argument is not a string or a list.
            ValueError: If the word contains a generator not n the alphabet of
            the given monoid.
        '''       
        if not isinstance(FpM,FpMonoid):
            raise TypeError("given monoid is not a valid FpMonoid") 
        if not (isinstance(word,str) or isinstance(word,list)):
            raise TypeError("given word must be a string or list of integers")
        self._FpS = FpM

        for i in word:
            if not i in FpM.alphabet():
                raise ValueError("given word is not in the given FpMonoid")

        if self._FpS._is_string_alphabet:
            if word =="":
                self._Word ="e".encode('UTF-8')
            else:
                self._Word = word.encode('UTF-8')
        else:
            if word =="":
                self._Word ="0".encode('UTF-8')
            else:
                self._Word = str(word).encode('UTF-8')


    def monoid(self):
        '''
        retrurns the monoid of which this element is a member.

        Examples:
            >>> FpM=FpMonoid(["a","b"],[["aa","a"],["bbb","ab"],["ab","ba"]])
            >>> FpMonoidElement(FpM,"bab").monoid()
            <FpMonoid <a,b|aa=a,bbb=ab,ab=ba>>
            >>> FpM=FpMonoid([1,2],[[[1,1],[1]],[[2,1,2],[1,2]],[[1,2],[2,1]]])
            >>> FpMonoidElement(FpM,[1]).monoid()
            <FpMonoid <1,2|11=1,212=12,12=21>>

        Args:
            None.

        Returns:
            FpMonoid:monoid of which this element is a member

        Raises:
            None.
        '''
        return self._FpS

    def __repr__(self):
        '''
        displays the FpMonoid element

        Examples:
            >>> FpM=FpMonoid(["a","b"],[["aa","a"],["bbb","ab"],["ab","ba"]])
            >>> FpMonoidElement(FpM,"a")
            <FpMonoid Element 'a'>
            >>> FpMonoidElement(FpM,"ab")
            <FpMonoid Element 'ab'>
            >>> FpM=FpMonoid([1,2],[[[1,1],[1]],[[2,2,2],[2]],[[1,2],[2,1]]])
            >>> FpMonoidElement(FpM,[1])
            <FpMonoid Element '[1]'>
            >>> FpMonoidElement(FpM,[1,2])
            <FpMonoid Element '[1, 2]'>

        Args:
            None.

        Returns:
            str: "<FpSemigroup Element 'word'>"

        Raises:
            None.
        '''
        return "<FpMonoid Element " + str(self._Word)[1:] + ">"

