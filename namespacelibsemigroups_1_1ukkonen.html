<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- BEGIN opengraph metadata -->
    <meta property="og:title" content="libsemigroups" />
    <meta property="og:image" content="libsemi_logo.jpeg" />
    <meta
      property="og:description"
      content="C++ library for semigroups and monoids."
    />
    <meta
      property="og:url"
      content="https://github.com/libsemigroups/libsemigroups"
    />
    <!-- END opengraph metadata -->
<title>libsemigroups: libsemigroups::ukkonen Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/libsemigroups/libsemigroups" class="github-corner" title="View source on GitHub" target="_blank" rel="noopener noreferrer">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<a href="index.html">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="libsemi_logo.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsemigroups
   &#160;<span id="projectnumber">v3.1.3</span>
   </div>
   <div id="projectbrief">C++ library for semigroups and monoids</div>
  </td>
 </tr>
 </tbody>
</table>
</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="_HEADING_"><span>Library&#160;Info</span></a></li>
      <li><a href="md_authors.html"><span>Authors</span></a></li>
      <li><a href="citelist.html"><span>Bibliography</span></a></li>
      <li><a href="md_changelog-v3.html"><span>Changelog&#160;-&#160;version&#160;3</span></a></li>
      <li><a href="md_changelog-v2.html"><span>Changelog&#160;-&#160;version&#160;2</span></a></li>
      <li><a href="md_changelog-v1.html"><span>Changelog&#160;-&#160;version&#160;1</span></a></li>
      <li><a href="md_deprecate.html"><span>Deprecation</span></a></li>
      <li><a href="md_install.html"><span>Installation</span></a></li>
      <li><a href="_HEADING_"><span>Data&#160;structures</span></a></li>
      <li><a href="group__adapters__group.html"><span>Adapters</span></a></li>
      <li><a href="group__constants__group.html"><span>Constants</span></a></li>
      <li><a href="group__elements__group.html"><span>Elements</span></a></li>
      <li><a href="group__exception__group.html"><span>Exceptions</span></a></li>
      <li><a href="group__orders__group.html"><span>Orders</span></a></li>
      <li><a href="group__presentations__group.html"><span>Presentations</span></a></li>
      <li><a href="group__ranges__group.html"><span>Ranges</span></a></li>
      <li><a href="group__ukkonen__group.html"><span>Suffix&#160;trees</span></a></li>
      <li><a href="group__make__group.html"><span>The&#160;`make`&#160;function</span></a></li>
      <li><a href="group__to__group.html"><span>The&#160;`to`&#160;function</span></a></li>
      <li><a href="group__aho__corasick__group.html"><span>Tries</span></a></li>
      <li><a href="group__types__group.html"><span>Enums&#160;+&#160;Types</span></a></li>
      <li><a href="group__dot__group.html"><span>Visualisation</span></a></li>
      <li><a href="group__word__graph__group.html"><span>Word&#160;graphs</span></a></li>
      <li><a href="group__words__group.html"><span>Words</span></a></li>
      <li><a href="_HEADING_"><span>Main&#160;Algorithms</span></a></li>
      <li><a href="group__action__group.html"><span>Actions</span></a></li>
      <li><a href="group__cong__common__helpers__group.html"><span>Common&#160;congruence&#160;helper&#160;function</span></a></li>
      <li><a href="group__congruence__group.html"><span>Congruence</span></a></li>
      <li><a href="group__core__classes__group.html"><span>Core&#160;classes</span></a></li>
      <li><a href="group__froidure__pin__group.html"><span>Froidure-Pin</span></a></li>
      <li><a href="group__kambites__group.html"><span>Kambites</span></a></li>
      <li><a href="group__knuth__bendix__group.html"><span>Knuth-Bendix</span></a></li>
      <li><a href="group__konieczny__group.html"><span>Konieczny</span></a></li>
      <li><a href="group__sims__group.html"><span>Low&#160;Index&#160;Congruences</span></a></li>
      <li><a href="group__freeband__group.html"><span>Radoszewski-Rytter</span></a></li>
      <li><a href="group__schreier__sims__group.html"><span>Schreier-Sims</span></a></li>
      <li><a href="group__stephen__group.html"><span>Stephen</span></a></li>
      <li><a href="group__todd__coxeter__group.html"><span>Todd-Coxeter</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacelibsemigroups_1_1ukkonen.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">libsemigroups::ukkonen Namespace Reference<div class="ingroups"><a class="el" href="group__ukkonen__group.html">Ukkonen</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a>
<div class="textblock"><p>This namespace contains helper functions for the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> class. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac26b124334bb4655b78df7a287b47f65" id="r_ac26b124334bb4655b78df7a287b47f65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac26b124334bb4655b78df7a287b47f65">add_word</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;u, char const *w)</td></tr>
<tr class="memdesc:ac26b124334bb4655b78df7a287b47f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a word to the suffix tree.     <br /></td></tr>
<tr class="separator:ac26b124334bb4655b78df7a287b47f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367be71c6f581d8aa8e6c0e20a8c05ed" id="r_a367be71c6f581d8aa8e6c0e20a8c05ed"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a367be71c6f581d8aa8e6c0e20a8c05ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a367be71c6f581d8aa8e6c0e20a8c05ed">add_word</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a367be71c6f581d8aa8e6c0e20a8c05ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a word to the suffix tree.     <br /></td></tr>
<tr class="separator:a367be71c6f581d8aa8e6c0e20a8c05ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5669adb5d92867299c9651a60a56e6" id="r_a3c5669adb5d92867299c9651a60a56e6"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a3c5669adb5d92867299c9651a60a56e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c5669adb5d92867299c9651a60a56e6">add_word</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:a3c5669adb5d92867299c9651a60a56e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a word to the suffix tree.     <br /></td></tr>
<tr class="separator:a3c5669adb5d92867299c9651a60a56e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896ba1e0e457beb44c782e8d2fbc2fc2" id="r_a896ba1e0e457beb44c782e8d2fbc2fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a896ba1e0e457beb44c782e8d2fbc2fc2">add_word</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:a896ba1e0e457beb44c782e8d2fbc2fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a word to the suffix tree.     <br /></td></tr>
<tr class="separator:a896ba1e0e457beb44c782e8d2fbc2fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8a1c4caa1d3fbf5ff5a90b2126a744" id="r_aeb8a1c4caa1d3fbf5ff5a90b2126a744"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb8a1c4caa1d3fbf5ff5a90b2126a744">add_word_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;u, char const *w)</td></tr>
<tr class="memdesc:aeb8a1c4caa1d3fbf5ff5a90b2126a744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a word to the suffix tree.     <br /></td></tr>
<tr class="separator:aeb8a1c4caa1d3fbf5ff5a90b2126a744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bb800f4f656a0712a2664c5fe341b1" id="r_ab6bb800f4f656a0712a2664c5fe341b1"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:ab6bb800f4f656a0712a2664c5fe341b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab6bb800f4f656a0712a2664c5fe341b1">add_word_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:ab6bb800f4f656a0712a2664c5fe341b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a word to the suffix tree.     <br /></td></tr>
<tr class="separator:ab6bb800f4f656a0712a2664c5fe341b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a4f6d5693c4fd33129277263b4e68e" id="r_a25a4f6d5693c4fd33129277263b4e68e"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a25a4f6d5693c4fd33129277263b4e68e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a25a4f6d5693c4fd33129277263b4e68e">add_word_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:a25a4f6d5693c4fd33129277263b4e68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a word to the suffix tree.     <br /></td></tr>
<tr class="separator:a25a4f6d5693c4fd33129277263b4e68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41c96255d5896aaa6923d823a74b6dd" id="r_af41c96255d5896aaa6923d823a74b6dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af41c96255d5896aaa6923d823a74b6dd">add_word_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:af41c96255d5896aaa6923d823a74b6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a word to the suffix tree.     <br /></td></tr>
<tr class="separator:af41c96255d5896aaa6923d823a74b6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f285fbf40f04dc9d510af0015937460" id="r_a4f285fbf40f04dc9d510af0015937460"><td class="memTemplParams" colspan="2">template&lt;typename Iterator1, typename Iterator2&gt; </td></tr>
<tr class="memitem:a4f285fbf40f04dc9d510af0015937460"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4f285fbf40f04dc9d510af0015937460">add_words</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;u, Iterator1 first, Iterator2 last)</td></tr>
<tr class="memdesc:a4f285fbf40f04dc9d510af0015937460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all words in a range to a <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object.  <br /></td></tr>
<tr class="separator:a4f285fbf40f04dc9d510af0015937460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34bc4933235029d42d37474fc03db97" id="r_ab34bc4933235029d42d37474fc03db97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab34bc4933235029d42d37474fc03db97">add_words</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;u, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> &gt; const &amp;words)</td></tr>
<tr class="memdesc:ab34bc4933235029d42d37474fc03db97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all words in a range to a <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object.  <br /></td></tr>
<tr class="separator:ab34bc4933235029d42d37474fc03db97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f6a7c707cc746d6ad78500526a1a31" id="r_a54f6a7c707cc746d6ad78500526a1a31"><td class="memTemplParams" colspan="2">template&lt;typename Iterator1, typename Iterator2&gt; </td></tr>
<tr class="memitem:a54f6a7c707cc746d6ad78500526a1a31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a54f6a7c707cc746d6ad78500526a1a31">add_words_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;u, Iterator1 first, Iterator2 last)</td></tr>
<tr class="memdesc:a54f6a7c707cc746d6ad78500526a1a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all words in a range to a <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object.  <br /></td></tr>
<tr class="separator:a54f6a7c707cc746d6ad78500526a1a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88d38acf67a38a65f62de95314b1508" id="r_af88d38acf67a38a65f62de95314b1508"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af88d38acf67a38a65f62de95314b1508">add_words_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;u, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> &gt; const &amp;words)</td></tr>
<tr class="memdesc:af88d38acf67a38a65f62de95314b1508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all words in a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> to a <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object.  <br /></td></tr>
<tr class="separator:af88d38acf67a38a65f62de95314b1508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625d952d68cfd0ccf4bb6a5d276b6eb2" id="r_a625d952d68cfd0ccf4bb6a5d276b6eb2"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a625d952d68cfd0ccf4bb6a5d276b6eb2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a625d952d68cfd0ccf4bb6a5d276b6eb2">dfs</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, T &amp;helper)</td></tr>
<tr class="memdesc:a625d952d68cfd0ccf4bb6a5d276b6eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a depth first search in a suffix tree.  <br /></td></tr>
<tr class="separator:a625d952d68cfd0ccf4bb6a5d276b6eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb29bc3442dc8de158ed08441303a99" id="r_a9cb29bc3442dc8de158ed08441303a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_dot.html">Dot</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cb29bc3442dc8de158ed08441303a99">dot</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u)</td></tr>
<tr class="memdesc:a9cb29bc3442dc8de158ed08441303a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classlibsemigroups_1_1_dot.html">Dot</a> object representing a suffix tree.  <br /></td></tr>
<tr class="separator:a9cb29bc3442dc8de158ed08441303a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e9d93f73d5c844fa7204af9da1377e" id="r_ab4e9d93f73d5c844fa7204af9da1377e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4e9d93f73d5c844fa7204af9da1377e">is_piece</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:ab4e9d93f73d5c844fa7204af9da1377e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a piece (occurs in two distinct places in the words of the suffix tree).     <br /></td></tr>
<tr class="separator:ab4e9d93f73d5c844fa7204af9da1377e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac591be6c50606e02145c84e2fdbc63f1" id="r_ac591be6c50606e02145c84e2fdbc63f1"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:ac591be6c50606e02145c84e2fdbc63f1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac591be6c50606e02145c84e2fdbc63f1">is_piece</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:ac591be6c50606e02145c84e2fdbc63f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a piece (occurs in two distinct places in the words of the suffix tree).     <br /></td></tr>
<tr class="separator:ac591be6c50606e02145c84e2fdbc63f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a438d82a8a13e5c7d8ef9ecd0ce575" id="r_a66a438d82a8a13e5c7d8ef9ecd0ce575"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a66a438d82a8a13e5c7d8ef9ecd0ce575"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a66a438d82a8a13e5c7d8ef9ecd0ce575">is_piece</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:a66a438d82a8a13e5c7d8ef9ecd0ce575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a piece (occurs in two distinct places in the words of the suffix tree).     <br /></td></tr>
<tr class="separator:a66a438d82a8a13e5c7d8ef9ecd0ce575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade45b21c792ace95bb86d750e7d1b8c7" id="r_ade45b21c792ace95bb86d750e7d1b8c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade45b21c792ace95bb86d750e7d1b8c7">is_piece</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:ade45b21c792ace95bb86d750e7d1b8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a piece (occurs in two distinct places in the words of the suffix tree).     <br /></td></tr>
<tr class="separator:ade45b21c792ace95bb86d750e7d1b8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791c65a9e7aab0505b3fa547267c1bce" id="r_a791c65a9e7aab0505b3fa547267c1bce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a791c65a9e7aab0505b3fa547267c1bce">is_piece_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a791c65a9e7aab0505b3fa547267c1bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a piece (occurs in two distinct places in the words of the suffix tree).     <br /></td></tr>
<tr class="separator:a791c65a9e7aab0505b3fa547267c1bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae754f9dcff6bd3ca974cf6522dc95058" id="r_ae754f9dcff6bd3ca974cf6522dc95058"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:ae754f9dcff6bd3ca974cf6522dc95058"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae754f9dcff6bd3ca974cf6522dc95058">is_piece_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:ae754f9dcff6bd3ca974cf6522dc95058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a piece (occurs in two distinct places in the words of the suffix tree).  <br /></td></tr>
<tr class="separator:ae754f9dcff6bd3ca974cf6522dc95058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bdd4b72bcc6e0ca2a24cc7432f51f8" id="r_a37bdd4b72bcc6e0ca2a24cc7432f51f8"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a37bdd4b72bcc6e0ca2a24cc7432f51f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a37bdd4b72bcc6e0ca2a24cc7432f51f8">is_piece_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:a37bdd4b72bcc6e0ca2a24cc7432f51f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a piece (occurs in two distinct places in the words of the suffix tree).     <br /></td></tr>
<tr class="separator:a37bdd4b72bcc6e0ca2a24cc7432f51f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8490ec7dd4f42277a79c32f8bf7afc9f" id="r_a8490ec7dd4f42277a79c32f8bf7afc9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8490ec7dd4f42277a79c32f8bf7afc9f">is_piece_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:a8490ec7dd4f42277a79c32f8bf7afc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a piece (occurs in two distinct places in the words of the suffix tree).     <br /></td></tr>
<tr class="separator:a8490ec7dd4f42277a79c32f8bf7afc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277aba3d3d819b95154561ba0507417f" id="r_a277aba3d3d819b95154561ba0507417f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a277aba3d3d819b95154561ba0507417f">is_subword</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a277aba3d3d819b95154561ba0507417f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a subword of any word in a suffix tree.     <br /></td></tr>
<tr class="separator:a277aba3d3d819b95154561ba0507417f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bac175d71787c6210473e5fb3e15318" id="r_a9bac175d71787c6210473e5fb3e15318"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a9bac175d71787c6210473e5fb3e15318"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9bac175d71787c6210473e5fb3e15318">is_subword</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a9bac175d71787c6210473e5fb3e15318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a subword of any word in a suffix tree.     <br /></td></tr>
<tr class="separator:a9bac175d71787c6210473e5fb3e15318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fac6e4827d997a383e6b5e4ecdbe78" id="r_ae3fac6e4827d997a383e6b5e4ecdbe78"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ae3fac6e4827d997a383e6b5e4ecdbe78"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae3fac6e4827d997a383e6b5e4ecdbe78">is_subword</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:ae3fac6e4827d997a383e6b5e4ecdbe78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a subword of any word in a suffix tree.     <br /></td></tr>
<tr class="separator:ae3fac6e4827d997a383e6b5e4ecdbe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3054612eb3c707925455d21bc217fab" id="r_ac3054612eb3c707925455d21bc217fab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3054612eb3c707925455d21bc217fab">is_subword</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:ac3054612eb3c707925455d21bc217fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a subword of any word in a suffix tree.     <br /></td></tr>
<tr class="separator:ac3054612eb3c707925455d21bc217fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad07d9aeeadfb2491d61448d35ffc15" id="r_a3ad07d9aeeadfb2491d61448d35ffc15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ad07d9aeeadfb2491d61448d35ffc15">is_subword_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a3ad07d9aeeadfb2491d61448d35ffc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a subword of any word in a suffix tree.     <br /></td></tr>
<tr class="separator:a3ad07d9aeeadfb2491d61448d35ffc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449f7176c9f4d4f461ca2f1e134cd510" id="r_a449f7176c9f4d4f461ca2f1e134cd510"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a449f7176c9f4d4f461ca2f1e134cd510"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a449f7176c9f4d4f461ca2f1e134cd510">is_subword_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a449f7176c9f4d4f461ca2f1e134cd510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a subword of any word in a suffix tree.  <br /></td></tr>
<tr class="separator:a449f7176c9f4d4f461ca2f1e134cd510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96b6178e7e265808756fb0ab0f9940e" id="r_ad96b6178e7e265808756fb0ab0f9940e"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ad96b6178e7e265808756fb0ab0f9940e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad96b6178e7e265808756fb0ab0f9940e">is_subword_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:ad96b6178e7e265808756fb0ab0f9940e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a subword of any word in a suffix tree.     <br /></td></tr>
<tr class="separator:ad96b6178e7e265808756fb0ab0f9940e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4993bcb34a16c49313a66b38867060e2" id="r_a4993bcb34a16c49313a66b38867060e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4993bcb34a16c49313a66b38867060e2">is_subword_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:a4993bcb34a16c49313a66b38867060e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a subword of any word in a suffix tree.     <br /></td></tr>
<tr class="separator:a4993bcb34a16c49313a66b38867060e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb332392726f49bfbbcb4e35cc46e021" id="r_acb332392726f49bfbbcb4e35cc46e021"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb332392726f49bfbbcb4e35cc46e021">is_suffix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:acb332392726f49bfbbcb4e35cc46e021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a suffix of any word in a suffix tree.     <br /></td></tr>
<tr class="separator:acb332392726f49bfbbcb4e35cc46e021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f087948c82aed77cf185aefbb4b77b" id="r_af4f087948c82aed77cf185aefbb4b77b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:af4f087948c82aed77cf185aefbb4b77b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af4f087948c82aed77cf185aefbb4b77b">is_suffix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:af4f087948c82aed77cf185aefbb4b77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a suffix of any word in a suffix tree.     <br /></td></tr>
<tr class="separator:af4f087948c82aed77cf185aefbb4b77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e7c905fe8656afcff4d533e24c80cc" id="r_a27e7c905fe8656afcff4d533e24c80cc"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a27e7c905fe8656afcff4d533e24c80cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a27e7c905fe8656afcff4d533e24c80cc">is_suffix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:a27e7c905fe8656afcff4d533e24c80cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a suffix of any word in a suffix tree.     <br /></td></tr>
<tr class="separator:a27e7c905fe8656afcff4d533e24c80cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf6a0db48f6863c5aac2530cf6b670a" id="r_a2cf6a0db48f6863c5aac2530cf6b670a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cf6a0db48f6863c5aac2530cf6b670a">is_suffix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:a2cf6a0db48f6863c5aac2530cf6b670a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a suffix of any word in a suffix tree.     <br /></td></tr>
<tr class="separator:a2cf6a0db48f6863c5aac2530cf6b670a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ba59a47378a6198bf441ad8fb1877b" id="r_a79ba59a47378a6198bf441ad8fb1877b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79ba59a47378a6198bf441ad8fb1877b">is_suffix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a79ba59a47378a6198bf441ad8fb1877b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a suffix of any word in a suffix tree.     <br /></td></tr>
<tr class="separator:a79ba59a47378a6198bf441ad8fb1877b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab614c02c5b9bb27d4c61fb3aafea7fb6" id="r_ab614c02c5b9bb27d4c61fb3aafea7fb6"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:ab614c02c5b9bb27d4c61fb3aafea7fb6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab614c02c5b9bb27d4c61fb3aafea7fb6">is_suffix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:ab614c02c5b9bb27d4c61fb3aafea7fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a suffix of any word in a suffix tree.  <br /></td></tr>
<tr class="separator:ab614c02c5b9bb27d4c61fb3aafea7fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ace245bad5f14192c8902b6c926d35a" id="r_a1ace245bad5f14192c8902b6c926d35a"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a1ace245bad5f14192c8902b6c926d35a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ace245bad5f14192c8902b6c926d35a">is_suffix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:a1ace245bad5f14192c8902b6c926d35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a suffix of any word in a suffix tree.     <br /></td></tr>
<tr class="separator:a1ace245bad5f14192c8902b6c926d35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70e7f1d42104f84eea9bd583bd0372c" id="r_ae70e7f1d42104f84eea9bd583bd0372c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae70e7f1d42104f84eea9bd583bd0372c">is_suffix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:ae70e7f1d42104f84eea9bd583bd0372c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a word is a suffix of any word in a suffix tree.     <br /></td></tr>
<tr class="separator:ae70e7f1d42104f84eea9bd583bd0372c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061a537b88a50dcdda951284d13fc614" id="r_a061a537b88a50dcdda951284d13fc614"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a061a537b88a50dcdda951284d13fc614">length_maximal_piece_prefix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a061a537b88a50dcdda951284d13fc614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal prefix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a061a537b88a50dcdda951284d13fc614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1270ad49329edb54ff64e69df987c2" id="r_aab1270ad49329edb54ff64e69df987c2"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:aab1270ad49329edb54ff64e69df987c2"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aab1270ad49329edb54ff64e69df987c2">length_maximal_piece_prefix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:aab1270ad49329edb54ff64e69df987c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal prefix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:aab1270ad49329edb54ff64e69df987c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f3d8862a8e78efeff4267ad0e73c24" id="r_a78f3d8862a8e78efeff4267ad0e73c24"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a78f3d8862a8e78efeff4267ad0e73c24"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a78f3d8862a8e78efeff4267ad0e73c24">length_maximal_piece_prefix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:a78f3d8862a8e78efeff4267ad0e73c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal prefix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a78f3d8862a8e78efeff4267ad0e73c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f56b70ff5dbe5510c1eca12f0042ba" id="r_a64f56b70ff5dbe5510c1eca12f0042ba"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64f56b70ff5dbe5510c1eca12f0042ba">length_maximal_piece_prefix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:a64f56b70ff5dbe5510c1eca12f0042ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal prefix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a64f56b70ff5dbe5510c1eca12f0042ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6482be504c3b1829d0861b4bb0ef94" id="r_a4a6482be504c3b1829d0861b4bb0ef94"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a6482be504c3b1829d0861b4bb0ef94">length_maximal_piece_prefix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a4a6482be504c3b1829d0861b4bb0ef94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal prefix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a4a6482be504c3b1829d0861b4bb0ef94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6fb119912edd43442d944f4e206e76" id="r_aeb6fb119912edd43442d944f4e206e76"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:aeb6fb119912edd43442d944f4e206e76"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeb6fb119912edd43442d944f4e206e76">length_maximal_piece_prefix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:aeb6fb119912edd43442d944f4e206e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal prefix of a word occurring in two different places in a word in a suffix tree.  <br /></td></tr>
<tr class="separator:aeb6fb119912edd43442d944f4e206e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaceb8ff90a8b5fc07ec244c3c9961bd8" id="r_aaceb8ff90a8b5fc07ec244c3c9961bd8"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:aaceb8ff90a8b5fc07ec244c3c9961bd8"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaceb8ff90a8b5fc07ec244c3c9961bd8">length_maximal_piece_prefix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:aaceb8ff90a8b5fc07ec244c3c9961bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal prefix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:aaceb8ff90a8b5fc07ec244c3c9961bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3605d5cc6de83020f0e8b22e54c54b" id="r_a8c3605d5cc6de83020f0e8b22e54c54b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c3605d5cc6de83020f0e8b22e54c54b">length_maximal_piece_prefix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:a8c3605d5cc6de83020f0e8b22e54c54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal prefix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a8c3605d5cc6de83020f0e8b22e54c54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302fc6bd7a9fe1cc7ace273a79f29c3f" id="r_a302fc6bd7a9fe1cc7ace273a79f29c3f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a302fc6bd7a9fe1cc7ace273a79f29c3f">length_maximal_piece_suffix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a302fc6bd7a9fe1cc7ace273a79f29c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal suffix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a302fc6bd7a9fe1cc7ace273a79f29c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13113552f63b84fae81e46477e1a70f" id="r_ab13113552f63b84fae81e46477e1a70f"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:ab13113552f63b84fae81e46477e1a70f"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab13113552f63b84fae81e46477e1a70f">length_maximal_piece_suffix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:ab13113552f63b84fae81e46477e1a70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal suffix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:ab13113552f63b84fae81e46477e1a70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b3aa79045cb48befb850b691789b4e" id="r_a90b3aa79045cb48befb850b691789b4e"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a90b3aa79045cb48befb850b691789b4e"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a90b3aa79045cb48befb850b691789b4e">length_maximal_piece_suffix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:a90b3aa79045cb48befb850b691789b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal suffix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a90b3aa79045cb48befb850b691789b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cd1cc686117de2a70c7f5e24985299" id="r_af9cd1cc686117de2a70c7f5e24985299"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9cd1cc686117de2a70c7f5e24985299">length_maximal_piece_suffix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:af9cd1cc686117de2a70c7f5e24985299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal suffix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:af9cd1cc686117de2a70c7f5e24985299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bef1a3839d53cc4016427009169dfe" id="r_a16bef1a3839d53cc4016427009169dfe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16bef1a3839d53cc4016427009169dfe">length_maximal_piece_suffix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a16bef1a3839d53cc4016427009169dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal suffix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a16bef1a3839d53cc4016427009169dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57225ee5b878a7044413dcd4debe26d8" id="r_a57225ee5b878a7044413dcd4debe26d8"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a57225ee5b878a7044413dcd4debe26d8"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57225ee5b878a7044413dcd4debe26d8">length_maximal_piece_suffix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a57225ee5b878a7044413dcd4debe26d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal suffix of a word occurring in two different places in a word in a suffix tree.  <br /></td></tr>
<tr class="separator:a57225ee5b878a7044413dcd4debe26d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae04cf8f63c39780ff923ad74432c6f6" id="r_aae04cf8f63c39780ff923ad74432c6f6"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:aae04cf8f63c39780ff923ad74432c6f6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aae04cf8f63c39780ff923ad74432c6f6">length_maximal_piece_suffix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:aae04cf8f63c39780ff923ad74432c6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal suffix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:aae04cf8f63c39780ff923ad74432c6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28a3668f3648a4bc7485858779a7516" id="r_ad28a3668f3648a4bc7485858779a7516"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad28a3668f3648a4bc7485858779a7516">length_maximal_piece_suffix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:ad28a3668f3648a4bc7485858779a7516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the maximal suffix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:ad28a3668f3648a4bc7485858779a7516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530cccc05ab7a16101e14ec24beea34d" id="r_a530cccc05ab7a16101e14ec24beea34d"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a530cccc05ab7a16101e14ec24beea34d">maximal_piece_prefix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a530cccc05ab7a16101e14ec24beea34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal prefix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a530cccc05ab7a16101e14ec24beea34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7031dbe8c04571bf4bfac3edf6c9d0de" id="r_a7031dbe8c04571bf4bfac3edf6c9d0de"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a7031dbe8c04571bf4bfac3edf6c9d0de"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7031dbe8c04571bf4bfac3edf6c9d0de">maximal_piece_prefix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a7031dbe8c04571bf4bfac3edf6c9d0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal prefix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a7031dbe8c04571bf4bfac3edf6c9d0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae217f1bb5670f3a49da6ae7f6172a8ba" id="r_ae217f1bb5670f3a49da6ae7f6172a8ba"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ae217f1bb5670f3a49da6ae7f6172a8ba"><td class="memTemplItemLeft" align="right" valign="top">Word::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae217f1bb5670f3a49da6ae7f6172a8ba">maximal_piece_prefix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:ae217f1bb5670f3a49da6ae7f6172a8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal prefix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:ae217f1bb5670f3a49da6ae7f6172a8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf5f30049cdd24cd5e1d99dbc64622c" id="r_a6cf5f30049cdd24cd5e1d99dbc64622c"><td class="memItemLeft" align="right" valign="top">word_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cf5f30049cdd24cd5e1d99dbc64622c">maximal_piece_prefix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:a6cf5f30049cdd24cd5e1d99dbc64622c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal prefix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a6cf5f30049cdd24cd5e1d99dbc64622c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c98336040c5eb60617db4362ae79937" id="r_a5c98336040c5eb60617db4362ae79937"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c98336040c5eb60617db4362ae79937">maximal_piece_prefix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a5c98336040c5eb60617db4362ae79937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal prefix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a5c98336040c5eb60617db4362ae79937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac420d98d59ef03a29bb8d926f15f591a" id="r_ac420d98d59ef03a29bb8d926f15f591a"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:ac420d98d59ef03a29bb8d926f15f591a"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac420d98d59ef03a29bb8d926f15f591a">maximal_piece_prefix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:ac420d98d59ef03a29bb8d926f15f591a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal prefix of a word occurring in two different places in a word in a suffix tree.  <br /></td></tr>
<tr class="separator:ac420d98d59ef03a29bb8d926f15f591a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff126c607d812b6e34033e9dd5530b58" id="r_aff126c607d812b6e34033e9dd5530b58"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:aff126c607d812b6e34033e9dd5530b58"><td class="memTemplItemLeft" align="right" valign="top">Word::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aff126c607d812b6e34033e9dd5530b58">maximal_piece_prefix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:aff126c607d812b6e34033e9dd5530b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal prefix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:aff126c607d812b6e34033e9dd5530b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29542263815a149be75dfe951b80327e" id="r_a29542263815a149be75dfe951b80327e"><td class="memItemLeft" align="right" valign="top">word_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29542263815a149be75dfe951b80327e">maximal_piece_prefix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:a29542263815a149be75dfe951b80327e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal prefix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a29542263815a149be75dfe951b80327e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45cb9aaf7265d6f2fd6afb94af7ac7e" id="r_ab45cb9aaf7265d6f2fd6afb94af7ac7e"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab45cb9aaf7265d6f2fd6afb94af7ac7e">maximal_piece_suffix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:ab45cb9aaf7265d6f2fd6afb94af7ac7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal suffix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:ab45cb9aaf7265d6f2fd6afb94af7ac7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10660b309f09686c06fb951a2a197bf9" id="r_a10660b309f09686c06fb951a2a197bf9"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a10660b309f09686c06fb951a2a197bf9"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a10660b309f09686c06fb951a2a197bf9">maximal_piece_suffix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a10660b309f09686c06fb951a2a197bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal suffix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a10660b309f09686c06fb951a2a197bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ffbf5555b31fd7cc763adb3c20a90a" id="r_a65ffbf5555b31fd7cc763adb3c20a90a"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a65ffbf5555b31fd7cc763adb3c20a90a"><td class="memTemplItemLeft" align="right" valign="top">Word::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a65ffbf5555b31fd7cc763adb3c20a90a">maximal_piece_suffix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:a65ffbf5555b31fd7cc763adb3c20a90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal suffix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a65ffbf5555b31fd7cc763adb3c20a90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5dd0124552e487751ec13c9977457f" id="r_a4b5dd0124552e487751ec13c9977457f"><td class="memItemLeft" align="right" valign="top">word_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b5dd0124552e487751ec13c9977457f">maximal_piece_suffix</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:a4b5dd0124552e487751ec13c9977457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal suffix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:a4b5dd0124552e487751ec13c9977457f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39b1e6966e7623ab1cc382a146c1169" id="r_ae39b1e6966e7623ab1cc382a146c1169"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae39b1e6966e7623ab1cc382a146c1169">maximal_piece_suffix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:ae39b1e6966e7623ab1cc382a146c1169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal suffix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:ae39b1e6966e7623ab1cc382a146c1169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57014d536cbd0d38d446255011a54337" id="r_a57014d536cbd0d38d446255011a54337"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a57014d536cbd0d38d446255011a54337"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57014d536cbd0d38d446255011a54337">maximal_piece_suffix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a57014d536cbd0d38d446255011a54337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal suffix of a word occurring in two different places in a word in a suffix tree.  <br /></td></tr>
<tr class="separator:a57014d536cbd0d38d446255011a54337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dda5af639db82ec6ea74c91e3be2c4" id="r_ab4dda5af639db82ec6ea74c91e3be2c4"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ab4dda5af639db82ec6ea74c91e3be2c4"><td class="memTemplItemLeft" align="right" valign="top">Word::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4dda5af639db82ec6ea74c91e3be2c4">maximal_piece_suffix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:ab4dda5af639db82ec6ea74c91e3be2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal suffix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:ab4dda5af639db82ec6ea74c91e3be2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa731b22f223133da475e7323566c079b" id="r_aa731b22f223133da475e7323566c079b"><td class="memItemLeft" align="right" valign="top">word_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa731b22f223133da475e7323566c079b">maximal_piece_suffix_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:aa731b22f223133da475e7323566c079b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal suffix of a word occurring in two different places in a word in a suffix tree.     <br /></td></tr>
<tr class="separator:aa731b22f223133da475e7323566c079b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ade375bc20389fb2b90021326e52fb1" id="r_a6ade375bc20389fb2b90021326e52fb1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ade375bc20389fb2b90021326e52fb1">number_of_distinct_subwords</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u)</td></tr>
<tr class="memdesc:a6ade375bc20389fb2b90021326e52fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of distinct subwords of the words in a suffix tree.  <br /></td></tr>
<tr class="separator:a6ade375bc20389fb2b90021326e52fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43b65c1fe81152dacdedb4c942d5319" id="r_ac43b65c1fe81152dacdedb4c942d5319"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac43b65c1fe81152dacdedb4c942d5319">number_of_pieces</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:ac43b65c1fe81152dacdedb4c942d5319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the number of pieces in a decomposition of a word (if any).     <br /></td></tr>
<tr class="separator:ac43b65c1fe81152dacdedb4c942d5319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0064633035bd942a0c03fc731f5fe4" id="r_aef0064633035bd942a0c03fc731f5fe4"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:aef0064633035bd942a0c03fc731f5fe4"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aef0064633035bd942a0c03fc731f5fe4">number_of_pieces</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:aef0064633035bd942a0c03fc731f5fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the number of pieces in a decomposition of a word (if any).     <br /></td></tr>
<tr class="separator:aef0064633035bd942a0c03fc731f5fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21f6d4532b4bd636d15a6b073436098" id="r_ac21f6d4532b4bd636d15a6b073436098"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ac21f6d4532b4bd636d15a6b073436098"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac21f6d4532b4bd636d15a6b073436098">number_of_pieces</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:ac21f6d4532b4bd636d15a6b073436098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the number of pieces in a decomposition of a word (if any).     <br /></td></tr>
<tr class="separator:ac21f6d4532b4bd636d15a6b073436098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf2c40149e3cfa0df005d0e070f8967" id="r_a9cf2c40149e3cfa0df005d0e070f8967"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cf2c40149e3cfa0df005d0e070f8967">number_of_pieces</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:a9cf2c40149e3cfa0df005d0e070f8967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the number of pieces in a decomposition of a word (if any).     <br /></td></tr>
<tr class="separator:a9cf2c40149e3cfa0df005d0e070f8967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f185424d85eb01488b89bb7f94fe7e3" id="r_a8f185424d85eb01488b89bb7f94fe7e3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f185424d85eb01488b89bb7f94fe7e3">number_of_pieces_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a8f185424d85eb01488b89bb7f94fe7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the number of pieces in a decomposition of a word (if any).     <br /></td></tr>
<tr class="separator:a8f185424d85eb01488b89bb7f94fe7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d51097ab96a4718fab91c4391693be8" id="r_a9d51097ab96a4718fab91c4391693be8"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a9d51097ab96a4718fab91c4391693be8"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d51097ab96a4718fab91c4391693be8">number_of_pieces_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a9d51097ab96a4718fab91c4391693be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the number of pieces in a decomposition of a word (if any).  <br /></td></tr>
<tr class="separator:a9d51097ab96a4718fab91c4391693be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df2b455e9541a6a564e4fd702f158cf" id="r_a7df2b455e9541a6a564e4fd702f158cf"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a7df2b455e9541a6a564e4fd702f158cf"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7df2b455e9541a6a564e4fd702f158cf">number_of_pieces_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:a7df2b455e9541a6a564e4fd702f158cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the number of pieces in a decomposition of a word (if any).     <br /></td></tr>
<tr class="separator:a7df2b455e9541a6a564e4fd702f158cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16e1a35d22c8dfcae5a40bfe22bc1df" id="r_aa16e1a35d22c8dfcae5a40bfe22bc1df"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa16e1a35d22c8dfcae5a40bfe22bc1df">number_of_pieces_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:aa16e1a35d22c8dfcae5a40bfe22bc1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the number of pieces in a decomposition of a word (if any).     <br /></td></tr>
<tr class="separator:aa16e1a35d22c8dfcae5a40bfe22bc1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851aac35bdff2fa49481b11515d0c240" id="r_a851aac35bdff2fa49481b11515d0c240"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a851aac35bdff2fa49481b11515d0c240">pieces</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a851aac35bdff2fa49481b11515d0c240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the pieces in a decomposition of a word (if any).     <br /></td></tr>
<tr class="separator:a851aac35bdff2fa49481b11515d0c240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cf17876de23c60e798d72ed9b7e6e3" id="r_aa5cf17876de23c60e798d72ed9b7e6e3"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:aa5cf17876de23c60e798d72ed9b7e6e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa5cf17876de23c60e798d72ed9b7e6e3">pieces</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:aa5cf17876de23c60e798d72ed9b7e6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the pieces in a decomposition of a word (if any).     <br /></td></tr>
<tr class="separator:aa5cf17876de23c60e798d72ed9b7e6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d82f9bfd77d8f20304656af034339a" id="r_ab1d82f9bfd77d8f20304656af034339a"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ab1d82f9bfd77d8f20304656af034339a"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab1d82f9bfd77d8f20304656af034339a">pieces</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:ab1d82f9bfd77d8f20304656af034339a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the pieces in a decomposition of a word (if any).     <br /></td></tr>
<tr class="separator:ab1d82f9bfd77d8f20304656af034339a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13da717b7bf151bf8e299da14323ed90" id="r_a13da717b7bf151bf8e299da14323ed90"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13da717b7bf151bf8e299da14323ed90">pieces</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:a13da717b7bf151bf8e299da14323ed90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the pieces in a decomposition of a word (if any).     <br /></td></tr>
<tr class="separator:a13da717b7bf151bf8e299da14323ed90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692bd7ac03eefa6d5b51d5f1486849b4" id="r_a692bd7ac03eefa6d5b51d5f1486849b4"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a692bd7ac03eefa6d5b51d5f1486849b4">pieces_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a692bd7ac03eefa6d5b51d5f1486849b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the pieces in a decomposition of a word (if any).     <br /></td></tr>
<tr class="separator:a692bd7ac03eefa6d5b51d5f1486849b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc114eda5f519e9a0a6c8307255b26b0" id="r_abc114eda5f519e9a0a6c8307255b26b0"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:abc114eda5f519e9a0a6c8307255b26b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abc114eda5f519e9a0a6c8307255b26b0">pieces_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:abc114eda5f519e9a0a6c8307255b26b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the pieces in a decomposition of a word (if any).  <br /></td></tr>
<tr class="separator:abc114eda5f519e9a0a6c8307255b26b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9fd74905c9b5f3c07b20e240ea63b4" id="r_a2b9fd74905c9b5f3c07b20e240ea63b4"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a2b9fd74905c9b5f3c07b20e240ea63b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b9fd74905c9b5f3c07b20e240ea63b4">pieces_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:a2b9fd74905c9b5f3c07b20e240ea63b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the pieces in a decomposition of a word (if any).     <br /></td></tr>
<tr class="separator:a2b9fd74905c9b5f3c07b20e240ea63b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a88e0d74704bb7a604836aa1f9099b0" id="r_a4a88e0d74704bb7a604836aa1f9099b0"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a88e0d74704bb7a604836aa1f9099b0">pieces_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:a4a88e0d74704bb7a604836aa1f9099b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the pieces in a decomposition of a word (if any).     <br /></td></tr>
<tr class="separator:a4a88e0d74704bb7a604836aa1f9099b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299a3895d2231e409d49c1bd6db9c1e5" id="r_a299a3895d2231e409d49c1bd6db9c1e5"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a>, char const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a299a3895d2231e409d49c1bd6db9c1e5">traverse</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a299a3895d2231e409d49c1bd6db9c1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.     <br /></td></tr>
<tr class="separator:a299a3895d2231e409d49c1bd6db9c1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4844f5274a3c63278e8bc067ca4b6f97" id="r_a4844f5274a3c63278e8bc067ca4b6f97"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a4844f5274a3c63278e8bc067ca4b6f97"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4844f5274a3c63278e8bc067ca4b6f97">traverse</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:a4844f5274a3c63278e8bc067ca4b6f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.     <br /></td></tr>
<tr class="separator:a4844f5274a3c63278e8bc067ca4b6f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3549c46a4471bbbed06849b91f09966" id="r_ae3549c46a4471bbbed06849b91f09966"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a>, word_type::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3549c46a4471bbbed06849b91f09966">traverse</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:ae3549c46a4471bbbed06849b91f09966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.     <br /></td></tr>
<tr class="separator:ae3549c46a4471bbbed06849b91f09966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41589479aac3edad67ae8b8259b5b638" id="r_a41589479aac3edad67ae8b8259b5b638"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41589479aac3edad67ae8b8259b5b638">traverse</a> (<a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a> &amp;st, <a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a41589479aac3edad67ae8b8259b5b638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.     <br /></td></tr>
<tr class="separator:a41589479aac3edad67ae8b8259b5b638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4784868a02247789bb6fa68fe5274ad1" id="r_a4784868a02247789bb6fa68fe5274ad1"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a4784868a02247789bb6fa68fe5274ad1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4784868a02247789bb6fa68fe5274ad1">traverse</a> (<a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a> &amp;st, <a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:a4784868a02247789bb6fa68fe5274ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.     <br /></td></tr>
<tr class="separator:a4784868a02247789bb6fa68fe5274ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc4c987b29a12cc9e70b4fa9230da78" id="r_a0dc4c987b29a12cc9e70b4fa9230da78"><td class="memItemLeft" align="right" valign="top">word_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dc4c987b29a12cc9e70b4fa9230da78">traverse</a> (<a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a> &amp;st, <a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:a0dc4c987b29a12cc9e70b4fa9230da78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.     <br /></td></tr>
<tr class="separator:a0dc4c987b29a12cc9e70b4fa9230da78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b496a364ab4fc95c062dd9d1e9f1d73" id="r_a1b496a364ab4fc95c062dd9d1e9f1d73"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a>, char const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b496a364ab4fc95c062dd9d1e9f1d73">traverse_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:a1b496a364ab4fc95c062dd9d1e9f1d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.     <br /></td></tr>
<tr class="separator:a1b496a364ab4fc95c062dd9d1e9f1d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab413a110accdb966387d9fbdfa19b919" id="r_ab413a110accdb966387d9fbdfa19b919"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ab413a110accdb966387d9fbdfa19b919"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab413a110accdb966387d9fbdfa19b919">traverse_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:ab413a110accdb966387d9fbdfa19b919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.     <br /></td></tr>
<tr class="separator:ab413a110accdb966387d9fbdfa19b919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccfa2d86e15d495d59fbe4989ad0f6c" id="r_a8ccfa2d86e15d495d59fbe4989ad0f6c"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a>, word_type::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ccfa2d86e15d495d59fbe4989ad0f6c">traverse_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:a8ccfa2d86e15d495d59fbe4989ad0f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.     <br /></td></tr>
<tr class="separator:a8ccfa2d86e15d495d59fbe4989ad0f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad007286c43c4ab0214f764c0ba79ed40" id="r_ad007286c43c4ab0214f764c0ba79ed40"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad007286c43c4ab0214f764c0ba79ed40">traverse_no_checks</a> (<a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a> &amp;st, <a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, char const *w)</td></tr>
<tr class="memdesc:ad007286c43c4ab0214f764c0ba79ed40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.     <br /></td></tr>
<tr class="separator:ad007286c43c4ab0214f764c0ba79ed40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3a35eeb570b8d38a14c2b6b9763f9d" id="r_a7b3a35eeb570b8d38a14c2b6b9763f9d"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a7b3a35eeb570b8d38a14c2b6b9763f9d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b3a35eeb570b8d38a14c2b6b9763f9d">traverse_no_checks</a> (<a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a> &amp;st, <a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, Word const &amp;w)</td></tr>
<tr class="memdesc:a7b3a35eeb570b8d38a14c2b6b9763f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.   .  <br /></td></tr>
<tr class="separator:a7b3a35eeb570b8d38a14c2b6b9763f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b865db29a12821d8a79056d3fe6567" id="r_ae9b865db29a12821d8a79056d3fe6567"><td class="memItemLeft" align="right" valign="top">word_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9b865db29a12821d8a79056d3fe6567">traverse_no_checks</a> (<a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a> &amp;st, <a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;u, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;w)</td></tr>
<tr class="memdesc:ae9b865db29a12821d8a79056d3fe6567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the suffix tree from the root.     <br /></td></tr>
<tr class="separator:ae9b865db29a12821d8a79056d3fe6567"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac26b124334bb4655b78df7a287b47f65" name="ac26b124334bb4655b78df7a287b47f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26b124334bb4655b78df7a287b47f65">&#9670;&#160;</a></span>add_word() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a54b89d9ef7b86c8a2042f9d35877d26b">add_word_no_checks</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w, w + std::strlen(w))</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a367be71c6f581d8aa8e6c0e20a8c05ed" name="a367be71c6f581d8aa8e6c0e20a8c05ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367be71c6f581d8aa8e6c0e20a8c05ed">&#9670;&#160;</a></span>add_word() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a54b89d9ef7b86c8a2042f9d35877d26b">add_word_no_checks</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>throw_if_contains_unique_letter(first, last)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the <code>value_type</code> of <code class="param">Iterator</code> is a signed integer, then this is converted to an unsigned integer using <a class="elRef" href="http://en.cppreference.com/w/cpp/types/make_signed.html">std::make_signed</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a3c5669adb5d92867299c9651a60a56e6" name="a3c5669adb5d92867299c9651a60a56e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5669adb5d92867299c9651a60a56e6">&#9670;&#160;</a></span>add_word() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a54b89d9ef7b86c8a2042f9d35877d26b">add_word_no_checks</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>throw_if_contains_unique_letter(w)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a896ba1e0e457beb44c782e8d2fbc2fc2" name="a896ba1e0e457beb44c782e8d2fbc2fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896ba1e0e457beb44c782e8d2fbc2fc2">&#9670;&#160;</a></span>add_word() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a54b89d9ef7b86c8a2042f9d35877d26b">add_word_no_checks</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>throw_if_contains_unique_letter(w)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="aeb8a1c4caa1d3fbf5ff5a90b2126a744" name="aeb8a1c4caa1d3fbf5ff5a90b2126a744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8a1c4caa1d3fbf5ff5a90b2126a744">&#9670;&#160;</a></span>add_word_no_checks() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_word_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a54b89d9ef7b86c8a2042f9d35877d26b">add_word_no_checks</a>. </p>

</div>
</div>
<a id="ab6bb800f4f656a0712a2664c5fe341b1" name="ab6bb800f4f656a0712a2664c5fe341b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bb800f4f656a0712a2664c5fe341b1">&#9670;&#160;</a></span>add_word_no_checks() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_word_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a54b89d9ef7b86c8a2042f9d35877d26b">add_word_no_checks</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If the <code>value_type</code> of <code class="param">Iterator</code> is a signed integer, then this is converted to an unsigned integer using <a class="elRef" href="http://en.cppreference.com/w/cpp/types/make_signed.html">std::make_signed</a>. </dd></dl>

</div>
</div>
<a id="a25a4f6d5693c4fd33129277263b4e68e" name="a25a4f6d5693c4fd33129277263b4e68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a4f6d5693c4fd33129277263b4e68e">&#9670;&#160;</a></span>add_word_no_checks() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_word_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a54b89d9ef7b86c8a2042f9d35877d26b">add_word_no_checks</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If the values in <code class="param">w</code> are signed integers, then they are converted to unsigned integers using <a class="elRef" href="http://en.cppreference.com/w/cpp/types/make_signed.html">std::make_signed</a>. </dd></dl>

</div>
</div>
<a id="af41c96255d5896aaa6923d823a74b6dd" name="af41c96255d5896aaa6923d823a74b6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41c96255d5896aaa6923d823a74b6dd">&#9670;&#160;</a></span>add_word_no_checks() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_word_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a54b89d9ef7b86c8a2042f9d35877d26b">add_word_no_checks</a>. </p>

</div>
</div>
<a id="a4f285fbf40f04dc9d510af0015937460" name="a4f285fbf40f04dc9d510af0015937460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f285fbf40f04dc9d510af0015937460">&#9670;&#160;</a></span>add_words() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator1, typename Iterator2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_words </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator2</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a54f6a7c707cc746d6ad78500526a1a31">add_words_no_checks(Ukkonen&amp;, Iterator1, Iterator2)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w)</code> throws for any <code>w</code> in <code>[first, last)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>if the <code>value_type</code> of <code class="param">Iterator</code> is a signed integer, then this is converted to an unsigned integer using <a class="elRef" href="http://en.cppreference.com/w/cpp/types/make_signed.html">std::make_signed</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="ab34bc4933235029d42d37474fc03db97" name="ab34bc4933235029d42d37474fc03db97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34bc4933235029d42d37474fc03db97">&#9670;&#160;</a></span>add_words() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_words </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>words</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#af88d38acf67a38a65f62de95314b1508">vector&lt;word_type&gt; const&amp;)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w)</code> throws for any <code>w</code> in <code class="param">words</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a54f6a7c707cc746d6ad78500526a1a31" name="a54f6a7c707cc746d6ad78500526a1a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f6a7c707cc746d6ad78500526a1a31">&#9670;&#160;</a></span>add_words_no_checks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator1, typename Iterator2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_words_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator2</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add all words in a range to a <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the 2nd and 3rd parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>if the <code>value_type</code> of <code class="param">Iterator</code> is a signed integer, then this is converted to an unsigned integer using <a class="elRef" href="http://en.cppreference.com/w/cpp/types/make_signed.html">std::make_signed</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="af88d38acf67a38a65f62de95314b1508" name="af88d38acf67a38a65f62de95314b1508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88d38acf67a38a65f62de95314b1508">&#9670;&#160;</a></span>add_words_no_checks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_words_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>words</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add all words in a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> to a <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object. </td></tr>
    <tr><td class="paramname">words</td><td>the words to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="a625d952d68cfd0ccf4bb6a5d276b6eb2" name="a625d952d68cfd0ccf4bb6a5d276b6eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625d952d68cfd0ccf4bb6a5d276b6eb2">&#9670;&#160;</a></span>dfs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto dfs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used to perform a depth first search in the suffix tree <code class="param">u</code>. The 2nd parameter is a helper object that must implement:</p>
<ul>
<li>A function <code>void pre_order(<a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> const&amp; u, size_t i)</code>;</li>
<li>A function <code>void post_order(<a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> const&amp; u, size_t i)</code>; and</li>
<li>A function <code>auto yield(<a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> const&amp; u)</code>.</li>
</ul>
<p>The function <code>T::pre_order</code> is called when the node <code>n</code> with index <code>i</code> is first encountered in the depth-first search, and the function <code>T::post_order</code> is called when the subtree rooted at <code>n</code> has been completely explored.</p>
<p>The function <code>yield</code> is called at the end of the depth-first search and its return value is returned by this function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the helper object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object. </td></tr>
    <tr><td class="paramname">helper</td><td>the helper object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value whose type is the same as the return type of <code>T::yield</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="a9cb29bc3442dc8de158ed08441303a99" name="a9cb29bc3442dc8de158ed08441303a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb29bc3442dc8de158ed08441303a99">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_dot.html">Dot</a> dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns a <a class="el" href="classlibsemigroups_1_1_dot.html">Dot</a> object representing the suffix tree defined by <code class="param">u</code>.</p>
<p>Internally, all words added to the suffix tree are stored as a single string delimited by unique letters. The edge labels present in this <a class="el" href="classlibsemigroups_1_1_dot.html">Dot</a> object correspond to intervals of letters in that delimited string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classlibsemigroups_1_1_dot.html">Dot</a> object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">u</code> does not contain any words. </td></tr>
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the number of words in <code class="param">u</code> is greater than 24. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4e9d93f73d5c844fa7204af9da1377e" name="ab4e9d93f73d5c844fa7204af9da1377e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e9d93f73d5c844fa7204af9da1377e">&#9670;&#160;</a></span>is_piece() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_piece </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#ae754f9dcff6bd3ca974cf6522dc95058">is_piece_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w, w + std::strlen(w))</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="ac591be6c50606e02145c84e2fdbc63f1" name="ac591be6c50606e02145c84e2fdbc63f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac591be6c50606e02145c84e2fdbc63f1">&#9670;&#160;</a></span>is_piece() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_piece </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#ae754f9dcff6bd3ca974cf6522dc95058">is_piece_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(first, last)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a66a438d82a8a13e5c7d8ef9ecd0ce575" name="a66a438d82a8a13e5c7d8ef9ecd0ce575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a438d82a8a13e5c7d8ef9ecd0ce575">&#9670;&#160;</a></span>is_piece() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_piece </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#ae754f9dcff6bd3ca974cf6522dc95058">is_piece_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w.cbegin(), w.cend())</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="ade45b21c792ace95bb86d750e7d1b8c7" name="ade45b21c792ace95bb86d750e7d1b8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade45b21c792ace95bb86d750e7d1b8c7">&#9670;&#160;</a></span>is_piece() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_piece </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#ae754f9dcff6bd3ca974cf6522dc95058">is_piece_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a791c65a9e7aab0505b3fa547267c1bce" name="a791c65a9e7aab0505b3fa547267c1bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791c65a9e7aab0505b3fa547267c1bce">&#9670;&#160;</a></span>is_piece_no_checks() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_piece_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#ae754f9dcff6bd3ca974cf6522dc95058">is_piece_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>. </p>

</div>
</div>
<a id="ae754f9dcff6bd3ca974cf6522dc95058" name="ae754f9dcff6bd3ca974cf6522dc95058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae754f9dcff6bd3ca974cf6522dc95058">&#9670;&#160;</a></span>is_piece_no_checks() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_piece_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the word corresponding to <code class="param">first</code> and <code class="param">last</code> that occurs in at least \(2\) different (possibly overlapping) places in the words contained in <code class="param">u</code>. If no such prefix exists, then <code>false</code> is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the 2nd and 3rd parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the distance between <code>first</code> and <code>last</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="a37bdd4b72bcc6e0ca2a24cc7432f51f8" name="a37bdd4b72bcc6e0ca2a24cc7432f51f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bdd4b72bcc6e0ca2a24cc7432f51f8">&#9670;&#160;</a></span>is_piece_no_checks() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_piece_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#ae754f9dcff6bd3ca974cf6522dc95058">is_piece_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>. </p>

</div>
</div>
<a id="a8490ec7dd4f42277a79c32f8bf7afc9f" name="a8490ec7dd4f42277a79c32f8bf7afc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8490ec7dd4f42277a79c32f8bf7afc9f">&#9670;&#160;</a></span>is_piece_no_checks() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_piece_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#ae754f9dcff6bd3ca974cf6522dc95058">is_piece_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>. </p>

</div>
</div>
<a id="a277aba3d3d819b95154561ba0507417f" name="a277aba3d3d819b95154561ba0507417f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277aba3d3d819b95154561ba0507417f">&#9670;&#160;</a></span>is_subword() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_subword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a449f7176c9f4d4f461ca2f1e134cd510">is_subword_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w, w + std::strlen(w))</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a9bac175d71787c6210473e5fb3e15318" name="a9bac175d71787c6210473e5fb3e15318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bac175d71787c6210473e5fb3e15318">&#9670;&#160;</a></span>is_subword() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_subword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a449f7176c9f4d4f461ca2f1e134cd510">is_subword_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(first, last)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="ae3fac6e4827d997a383e6b5e4ecdbe78" name="ae3fac6e4827d997a383e6b5e4ecdbe78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fac6e4827d997a383e6b5e4ecdbe78">&#9670;&#160;</a></span>is_subword() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_subword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a449f7176c9f4d4f461ca2f1e134cd510">is_subword_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w.cbegin(), w.cend())</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="ac3054612eb3c707925455d21bc217fab" name="ac3054612eb3c707925455d21bc217fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3054612eb3c707925455d21bc217fab">&#9670;&#160;</a></span>is_subword() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_subword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a449f7176c9f4d4f461ca2f1e134cd510">is_subword_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a3ad07d9aeeadfb2491d61448d35ffc15" name="a3ad07d9aeeadfb2491d61448d35ffc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad07d9aeeadfb2491d61448d35ffc15">&#9670;&#160;</a></span>is_subword_no_checks() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_subword_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a449f7176c9f4d4f461ca2f1e134cd510">is_subword_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>. </p>

</div>
</div>
<a id="a449f7176c9f4d4f461ca2f1e134cd510" name="a449f7176c9f4d4f461ca2f1e134cd510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449f7176c9f4d4f461ca2f1e134cd510">&#9670;&#160;</a></span>is_subword_no_checks() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_subword_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the word corresponding to <code class="param">first</code> and <code class="param">last</code> is a subword of one of the words in the suffix tree represented by the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> instance <code class="param">u</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the 2nd and 3rd parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the distance between <code>first</code> and <code>last</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>if the <code>value_type</code> of <code class="param">Iterator</code> is a signed integer, then this is converted to an unsigned integer using <a class="elRef" href="http://en.cppreference.com/w/cpp/types/make_signed.html">std::make_signed</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="ad96b6178e7e265808756fb0ab0f9940e" name="ad96b6178e7e265808756fb0ab0f9940e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96b6178e7e265808756fb0ab0f9940e">&#9670;&#160;</a></span>is_subword_no_checks() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_subword_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a449f7176c9f4d4f461ca2f1e134cd510">is_subword_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>. </p>

</div>
</div>
<a id="a4993bcb34a16c49313a66b38867060e2" name="a4993bcb34a16c49313a66b38867060e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4993bcb34a16c49313a66b38867060e2">&#9670;&#160;</a></span>is_subword_no_checks() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_subword_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a449f7176c9f4d4f461ca2f1e134cd510">is_subword_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>. </p>

</div>
</div>
<a id="acb332392726f49bfbbcb4e35cc46e021" name="acb332392726f49bfbbcb4e35cc46e021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb332392726f49bfbbcb4e35cc46e021">&#9670;&#160;</a></span>is_suffix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#ab614c02c5b9bb27d4c61fb3aafea7fb6">is_suffix_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w, w + std::strlen(w))</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="af4f087948c82aed77cf185aefbb4b77b" name="af4f087948c82aed77cf185aefbb4b77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f087948c82aed77cf185aefbb4b77b">&#9670;&#160;</a></span>is_suffix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#ab614c02c5b9bb27d4c61fb3aafea7fb6">is_suffix_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(first, last)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a27e7c905fe8656afcff4d533e24c80cc" name="a27e7c905fe8656afcff4d533e24c80cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e7c905fe8656afcff4d533e24c80cc">&#9670;&#160;</a></span>is_suffix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#ab614c02c5b9bb27d4c61fb3aafea7fb6">is_suffix_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w.begin(), w.end())</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a2cf6a0db48f6863c5aac2530cf6b670a" name="a2cf6a0db48f6863c5aac2530cf6b670a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf6a0db48f6863c5aac2530cf6b670a">&#9670;&#160;</a></span>is_suffix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#ab614c02c5b9bb27d4c61fb3aafea7fb6">is_suffix_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a79ba59a47378a6198bf441ad8fb1877b" name="a79ba59a47378a6198bf441ad8fb1877b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ba59a47378a6198bf441ad8fb1877b">&#9670;&#160;</a></span>is_suffix_no_checks() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_suffix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#ab614c02c5b9bb27d4c61fb3aafea7fb6">is_suffix_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>. </p>

</div>
</div>
<a id="ab614c02c5b9bb27d4c61fb3aafea7fb6" name="ab614c02c5b9bb27d4c61fb3aafea7fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab614c02c5b9bb27d4c61fb3aafea7fb6">&#9670;&#160;</a></span>is_suffix_no_checks() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_suffix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the word corresponding to <code class="param">first</code> and <code class="param">last</code> is a suffix of one of the words in the suffix tree represented by the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> instance <code class="param">u</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the 2nd and 3rd parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the distance between <code>first</code> and <code>last</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="a1ace245bad5f14192c8902b6c926d35a" name="a1ace245bad5f14192c8902b6c926d35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ace245bad5f14192c8902b6c926d35a">&#9670;&#160;</a></span>is_suffix_no_checks() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_suffix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#ab614c02c5b9bb27d4c61fb3aafea7fb6">is_suffix_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>. </p>

</div>
</div>
<a id="ae70e7f1d42104f84eea9bd583bd0372c" name="ae70e7f1d42104f84eea9bd583bd0372c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70e7f1d42104f84eea9bd583bd0372c">&#9670;&#160;</a></span>is_suffix_no_checks() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_suffix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#ab614c02c5b9bb27d4c61fb3aafea7fb6">is_suffix_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>. </p>

</div>
</div>
<a id="a061a537b88a50dcdda951284d13fc614" name="a061a537b88a50dcdda951284d13fc614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061a537b88a50dcdda951284d13fc614">&#9670;&#160;</a></span>length_maximal_piece_prefix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#aeb6fb119912edd43442d944f4e206e76">length_maximal_piece_prefix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w, w + std::strlen(w))</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="aab1270ad49329edb54ff64e69df987c2" name="aab1270ad49329edb54ff64e69df987c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1270ad49329edb54ff64e69df987c2">&#9670;&#160;</a></span>length_maximal_piece_prefix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#aeb6fb119912edd43442d944f4e206e76">length_maximal_piece_prefix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(first, last)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a78f3d8862a8e78efeff4267ad0e73c24" name="a78f3d8862a8e78efeff4267ad0e73c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f3d8862a8e78efeff4267ad0e73c24">&#9670;&#160;</a></span>length_maximal_piece_prefix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#aeb6fb119912edd43442d944f4e206e76">length_maximal_piece_prefix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w.cbegin(), w.cend())</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a64f56b70ff5dbe5510c1eca12f0042ba" name="a64f56b70ff5dbe5510c1eca12f0042ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f56b70ff5dbe5510c1eca12f0042ba">&#9670;&#160;</a></span>length_maximal_piece_prefix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#aeb6fb119912edd43442d944f4e206e76">length_maximal_piece_prefix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a4a6482be504c3b1829d0861b4bb0ef94" name="a4a6482be504c3b1829d0861b4bb0ef94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6482be504c3b1829d0861b4bb0ef94">&#9670;&#160;</a></span>length_maximal_piece_prefix_no_checks() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_prefix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#aeb6fb119912edd43442d944f4e206e76">length_maximal_piece_prefix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="aeb6fb119912edd43442d944f4e206e76" name="aeb6fb119912edd43442d944f4e206e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6fb119912edd43442d944f4e206e76">&#9670;&#160;</a></span>length_maximal_piece_prefix_no_checks() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_prefix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of the maximal length prefix of the word corresponding to <code class="param">first</code> and <code class="param">last</code> that occurs in at least \(2\) different (possibly overlapping) places in the words contained in <code class="param">u</code>. If no such prefix exists, then <code>0</code> is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the 2nd and 3rd parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Iterator</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the distance between <code>first</code> and <code>last</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="aaceb8ff90a8b5fc07ec244c3c9961bd8" name="aaceb8ff90a8b5fc07ec244c3c9961bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaceb8ff90a8b5fc07ec244c3c9961bd8">&#9670;&#160;</a></span>length_maximal_piece_prefix_no_checks() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_prefix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#aeb6fb119912edd43442d944f4e206e76">length_maximal_piece_prefix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="a8c3605d5cc6de83020f0e8b22e54c54b" name="a8c3605d5cc6de83020f0e8b22e54c54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3605d5cc6de83020f0e8b22e54c54b">&#9670;&#160;</a></span>length_maximal_piece_prefix_no_checks() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_prefix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#aeb6fb119912edd43442d944f4e206e76">length_maximal_piece_prefix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="a302fc6bd7a9fe1cc7ace273a79f29c3f" name="a302fc6bd7a9fe1cc7ace273a79f29c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302fc6bd7a9fe1cc7ace273a79f29c3f">&#9670;&#160;</a></span>length_maximal_piece_suffix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a57225ee5b878a7044413dcd4debe26d8">length_maximal_piece_suffix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w, w + std::strlen(w))</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="ab13113552f63b84fae81e46477e1a70f" name="ab13113552f63b84fae81e46477e1a70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13113552f63b84fae81e46477e1a70f">&#9670;&#160;</a></span>length_maximal_piece_suffix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a57225ee5b878a7044413dcd4debe26d8">length_maximal_piece_suffix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(first, last)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a90b3aa79045cb48befb850b691789b4e" name="a90b3aa79045cb48befb850b691789b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b3aa79045cb48befb850b691789b4e">&#9670;&#160;</a></span>length_maximal_piece_suffix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a57225ee5b878a7044413dcd4debe26d8">length_maximal_piece_suffix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w.cbegin(), w.cend())</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="af9cd1cc686117de2a70c7f5e24985299" name="af9cd1cc686117de2a70c7f5e24985299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cd1cc686117de2a70c7f5e24985299">&#9670;&#160;</a></span>length_maximal_piece_suffix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a57225ee5b878a7044413dcd4debe26d8">length_maximal_piece_suffix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a16bef1a3839d53cc4016427009169dfe" name="a16bef1a3839d53cc4016427009169dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bef1a3839d53cc4016427009169dfe">&#9670;&#160;</a></span>length_maximal_piece_suffix_no_checks() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_suffix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a57225ee5b878a7044413dcd4debe26d8">length_maximal_piece_suffix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="a57225ee5b878a7044413dcd4debe26d8" name="a57225ee5b878a7044413dcd4debe26d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57225ee5b878a7044413dcd4debe26d8">&#9670;&#160;</a></span>length_maximal_piece_suffix_no_checks() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_suffix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of the maximal length prefix of the word corresponding to <code class="param">first</code> and <code class="param">last</code> that occurs in at least \(2\) different (possibly overlapping) places in the words contained in <code class="param">u</code>. If no such prefix exists, then <code>0</code> is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the 2nd and 3rd parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Iterator</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the distance between <code>first</code> and <code>last</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="aae04cf8f63c39780ff923ad74432c6f6" name="aae04cf8f63c39780ff923ad74432c6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae04cf8f63c39780ff923ad74432c6f6">&#9670;&#160;</a></span>length_maximal_piece_suffix_no_checks() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_suffix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a57225ee5b878a7044413dcd4debe26d8">length_maximal_piece_suffix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="ad28a3668f3648a4bc7485858779a7516" name="ad28a3668f3648a4bc7485858779a7516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28a3668f3648a4bc7485858779a7516">&#9670;&#160;</a></span>length_maximal_piece_suffix_no_checks() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t length_maximal_piece_suffix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a57225ee5b878a7044413dcd4debe26d8">length_maximal_piece_suffix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="a530cccc05ab7a16101e14ec24beea34d" name="a530cccc05ab7a16101e14ec24beea34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530cccc05ab7a16101e14ec24beea34d">&#9670;&#160;</a></span>maximal_piece_prefix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char const  * maximal_piece_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#ac420d98d59ef03a29bb8d926f15f591a">maximal_piece_prefix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w, w + std::strlen(w))</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a7031dbe8c04571bf4bfac3edf6c9d0de" name="a7031dbe8c04571bf4bfac3edf6c9d0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7031dbe8c04571bf4bfac3edf6c9d0de">&#9670;&#160;</a></span>maximal_piece_prefix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator maximal_piece_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#ac420d98d59ef03a29bb8d926f15f591a">maximal_piece_prefix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(first, last)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="ae217f1bb5670f3a49da6ae7f6172a8ba" name="ae217f1bb5670f3a49da6ae7f6172a8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae217f1bb5670f3a49da6ae7f6172a8ba">&#9670;&#160;</a></span>maximal_piece_prefix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Word::const_iterator maximal_piece_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#ac420d98d59ef03a29bb8d926f15f591a">maximal_piece_prefix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w.cbegin(), w.cend())</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a6cf5f30049cdd24cd5e1d99dbc64622c" name="a6cf5f30049cdd24cd5e1d99dbc64622c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf5f30049cdd24cd5e1d99dbc64622c">&#9670;&#160;</a></span>maximal_piece_prefix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">word_type::const_iterator maximal_piece_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#ac420d98d59ef03a29bb8d926f15f591a">maximal_piece_prefix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a5c98336040c5eb60617db4362ae79937" name="a5c98336040c5eb60617db4362ae79937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c98336040c5eb60617db4362ae79937">&#9670;&#160;</a></span>maximal_piece_prefix_no_checks() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char const  * maximal_piece_prefix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#ac420d98d59ef03a29bb8d926f15f591a">maximal_piece_prefix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="ac420d98d59ef03a29bb8d926f15f591a" name="ac420d98d59ef03a29bb8d926f15f591a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac420d98d59ef03a29bb8d926f15f591a">&#9670;&#160;</a></span>maximal_piece_prefix_no_checks() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator maximal_piece_prefix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator pointing one past the last letter in the maximal length prefix of the word corresponding to <code class="param">first</code> and <code class="param">last</code> that occurs in at least \(2\) different (possibly overlapping) places in the words contained in <code class="param">u</code>. If no such prefix exists, then <code>first</code> is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the 2nd and 3rd parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Iterator</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the distance between <code>first</code> and <code>last</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="aff126c607d812b6e34033e9dd5530b58" name="aff126c607d812b6e34033e9dd5530b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff126c607d812b6e34033e9dd5530b58">&#9670;&#160;</a></span>maximal_piece_prefix_no_checks() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Word::const_iterator maximal_piece_prefix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#ac420d98d59ef03a29bb8d926f15f591a">maximal_piece_prefix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="a29542263815a149be75dfe951b80327e" name="a29542263815a149be75dfe951b80327e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29542263815a149be75dfe951b80327e">&#9670;&#160;</a></span>maximal_piece_prefix_no_checks() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">word_type::const_iterator maximal_piece_prefix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#ac420d98d59ef03a29bb8d926f15f591a">maximal_piece_prefix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="ab45cb9aaf7265d6f2fd6afb94af7ac7e" name="ab45cb9aaf7265d6f2fd6afb94af7ac7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45cb9aaf7265d6f2fd6afb94af7ac7e">&#9670;&#160;</a></span>maximal_piece_suffix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char const  * maximal_piece_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a57014d536cbd0d38d446255011a54337">maximal_piece_suffix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w, w + std::strlen(w))</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a10660b309f09686c06fb951a2a197bf9" name="a10660b309f09686c06fb951a2a197bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10660b309f09686c06fb951a2a197bf9">&#9670;&#160;</a></span>maximal_piece_suffix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator maximal_piece_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a57014d536cbd0d38d446255011a54337">maximal_piece_suffix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(first, last)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a65ffbf5555b31fd7cc763adb3c20a90a" name="a65ffbf5555b31fd7cc763adb3c20a90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ffbf5555b31fd7cc763adb3c20a90a">&#9670;&#160;</a></span>maximal_piece_suffix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Word::const_iterator maximal_piece_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a57014d536cbd0d38d446255011a54337">maximal_piece_suffix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w.cbegin(), w.cend())</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a4b5dd0124552e487751ec13c9977457f" name="a4b5dd0124552e487751ec13c9977457f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5dd0124552e487751ec13c9977457f">&#9670;&#160;</a></span>maximal_piece_suffix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">word_type::const_iterator maximal_piece_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a57014d536cbd0d38d446255011a54337">maximal_piece_suffix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="ae39b1e6966e7623ab1cc382a146c1169" name="ae39b1e6966e7623ab1cc382a146c1169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39b1e6966e7623ab1cc382a146c1169">&#9670;&#160;</a></span>maximal_piece_suffix_no_checks() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char const  * maximal_piece_suffix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a57014d536cbd0d38d446255011a54337">maximal_piece_suffix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="a57014d536cbd0d38d446255011a54337" name="a57014d536cbd0d38d446255011a54337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57014d536cbd0d38d446255011a54337">&#9670;&#160;</a></span>maximal_piece_suffix_no_checks() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator maximal_piece_suffix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator pointing at the first letter in the maximal length suffix of the word corresponding to <code class="param">first</code> and <code class="param">last</code> that occurs in at least \(2\) different (possibly overlapping) places in the words contained in <code class="param">u</code>. If no such suffix exists, then <code>first</code> is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the 2nd and 3rd parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Iterator</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>At worst \(O(m ^ 2)\) or \(O(n)\) where \(m\) is the distance between <code>first</code> and <code>last</code> and \(n\) is the return value of <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a97c948360b7cda900faf1177bb9cc9fe" title="Returns the sum of the lengths of the distinct words in the suffix tree.">Ukkonen::length_of_distinct_words</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="ab4dda5af639db82ec6ea74c91e3be2c4" name="ab4dda5af639db82ec6ea74c91e3be2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4dda5af639db82ec6ea74c91e3be2c4">&#9670;&#160;</a></span>maximal_piece_suffix_no_checks() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Word::const_iterator maximal_piece_suffix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a57014d536cbd0d38d446255011a54337">maximal_piece_suffix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="aa731b22f223133da475e7323566c079b" name="aa731b22f223133da475e7323566c079b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa731b22f223133da475e7323566c079b">&#9670;&#160;</a></span>maximal_piece_suffix_no_checks() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">word_type::const_iterator maximal_piece_suffix_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a57014d536cbd0d38d446255011a54337">maximal_piece_suffix_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="a6ade375bc20389fb2b90021326e52fb1" name="a6ade375bc20389fb2b90021326e52fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ade375bc20389fb2b90021326e52fb1">&#9670;&#160;</a></span>number_of_distinct_subwords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t number_of_distinct_subwords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the total number of distinct subwords of the words in the suffix tree <code class="param">u</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>size_t</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in <code><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a97c948360b7cda900faf1177bb9cc9fe" title="Returns the sum of the lengths of the distinct words in the suffix tree.">Ukkonen::length_of_distinct_words</a></code>. </dd></dl>

</div>
</div>
<a id="ac43b65c1fe81152dacdedb4c942d5319" name="ac43b65c1fe81152dacdedb4c942d5319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43b65c1fe81152dacdedb4c942d5319">&#9670;&#160;</a></span>number_of_pieces() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t number_of_pieces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a9d51097ab96a4718fab91c4391693be8">number_of_pieces_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w, w + std::strlen(w))</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="aef0064633035bd942a0c03fc731f5fe4" name="aef0064633035bd942a0c03fc731f5fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0064633035bd942a0c03fc731f5fe4">&#9670;&#160;</a></span>number_of_pieces() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t number_of_pieces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a9d51097ab96a4718fab91c4391693be8">number_of_pieces_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(first, last)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="ac21f6d4532b4bd636d15a6b073436098" name="ac21f6d4532b4bd636d15a6b073436098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21f6d4532b4bd636d15a6b073436098">&#9670;&#160;</a></span>number_of_pieces() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t number_of_pieces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a9d51097ab96a4718fab91c4391693be8">number_of_pieces_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w.cbegin(), w.cend())</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a9cf2c40149e3cfa0df005d0e070f8967" name="a9cf2c40149e3cfa0df005d0e070f8967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf2c40149e3cfa0df005d0e070f8967">&#9670;&#160;</a></span>number_of_pieces() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t number_of_pieces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a9d51097ab96a4718fab91c4391693be8">number_of_pieces_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a8f185424d85eb01488b89bb7f94fe7e3" name="a8f185424d85eb01488b89bb7f94fe7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f185424d85eb01488b89bb7f94fe7e3">&#9670;&#160;</a></span>number_of_pieces_no_checks() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t number_of_pieces_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a9d51097ab96a4718fab91c4391693be8">number_of_pieces_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="a9d51097ab96a4718fab91c4391693be8" name="a9d51097ab96a4718fab91c4391693be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d51097ab96a4718fab91c4391693be8">&#9670;&#160;</a></span>number_of_pieces_no_checks() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t number_of_pieces_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns minimum number of pieces whose product equals the word corresponding to <code class="param">first</code> and <code class="param">last</code> if such a product exists, and <code>0</code> if no such product exists. Recall that a <em>piece</em> is a word that occurs in two distinct positions (possibly overlapping) of the words in the suffix tree <code class="param">u</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the 2nd and 3rd parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>size_t</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the distance between <code>first</code> and <code>last</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="a7df2b455e9541a6a564e4fd702f158cf" name="a7df2b455e9541a6a564e4fd702f158cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df2b455e9541a6a564e4fd702f158cf">&#9670;&#160;</a></span>number_of_pieces_no_checks() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t number_of_pieces_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a9d51097ab96a4718fab91c4391693be8">number_of_pieces_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="aa16e1a35d22c8dfcae5a40bfe22bc1df" name="aa16e1a35d22c8dfcae5a40bfe22bc1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16e1a35d22c8dfcae5a40bfe22bc1df">&#9670;&#160;</a></span>number_of_pieces_no_checks() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t number_of_pieces_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#a9d51097ab96a4718fab91c4391693be8">number_of_pieces_no_checks(Ukkonen const&amp;, Iterator,
Iterator)</a>. </p>

</div>
</div>
<a id="a851aac35bdff2fa49481b11515d0c240" name="a851aac35bdff2fa49481b11515d0c240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851aac35bdff2fa49481b11515d0c240">&#9670;&#160;</a></span>pieces() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; pieces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#abc114eda5f519e9a0a6c8307255b26b0">pieces_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w, w + std::strlen(w))</code> throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5cf17876de23c60e798d72ed9b7e6e3" name="aa5cf17876de23c60e798d72ed9b7e6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cf17876de23c60e798d72ed9b7e6e3">&#9670;&#160;</a></span>pieces() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Iterator &gt; pieces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#abc114eda5f519e9a0a6c8307255b26b0">pieces_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(first, last)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="ab1d82f9bfd77d8f20304656af034339a" name="ab1d82f9bfd77d8f20304656af034339a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d82f9bfd77d8f20304656af034339a">&#9670;&#160;</a></span>pieces() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt; pieces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#abc114eda5f519e9a0a6c8307255b26b0">pieces_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w.cbegin(), w.cend())</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a13da717b7bf151bf8e299da14323ed90" name="a13da717b7bf151bf8e299da14323ed90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13da717b7bf151bf8e299da14323ed90">&#9670;&#160;</a></span>pieces() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> &gt; pieces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="#abc114eda5f519e9a0a6c8307255b26b0">pieces_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w)</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a692bd7ac03eefa6d5b51d5f1486849b4" name="a692bd7ac03eefa6d5b51d5f1486849b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692bd7ac03eefa6d5b51d5f1486849b4">&#9670;&#160;</a></span>pieces_no_checks() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; pieces_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#abc114eda5f519e9a0a6c8307255b26b0">pieces_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>. </p>

</div>
</div>
<a id="abc114eda5f519e9a0a6c8307255b26b0" name="abc114eda5f519e9a0a6c8307255b26b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc114eda5f519e9a0a6c8307255b26b0">&#9670;&#160;</a></span>pieces_no_checks() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Iterator &gt; pieces_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> of iterators pointing one past the last letter in the pieces whose product equals the word corresponding to <code class="param">first</code> and <code class="param">last</code> if such a product exists, and an empty <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> if no such product exists. Recall that a <em>piece</em> is a word that occurs in two distinct positions (possibly overlapping) of the words in the suffix tree <code class="param">u</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the 2nd and 3rd parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the <a class="el" href="classlibsemigroups_1_1_ukkonen.html" title="For an implementation of Ukkonen&#39;s algorithm.">Ukkonen</a> object. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing to the first letter of the word. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the last letter of the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;Iterator&gt;</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the distance between <code>first</code> and <code>last</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its arguments whatsoever. In particular, if the word corresponding to <code class="param">first</code> and <code class="param">last</code> contains any of the unique letters appended to the end of any existing word in the tree, then bad things will happen. </dd></dl>

</div>
</div>
<a id="a2b9fd74905c9b5f3c07b20e240ea63b4" name="a2b9fd74905c9b5f3c07b20e240ea63b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9fd74905c9b5f3c07b20e240ea63b4">&#9670;&#160;</a></span>pieces_no_checks() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt; pieces_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#abc114eda5f519e9a0a6c8307255b26b0">pieces_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>. </p>

</div>
</div>
<a id="a4a88e0d74704bb7a604836aa1f9099b0" name="a4a88e0d74704bb7a604836aa1f9099b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a88e0d74704bb7a604836aa1f9099b0">&#9670;&#160;</a></span>pieces_no_checks() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> &gt; pieces_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#abc114eda5f519e9a0a6c8307255b26b0">pieces_no_checks(Ukkonen const&amp;, Iterator, Iterator)</a>. </p>

</div>
</div>
<a id="a299a3895d2231e409d49c1bd6db9c1e5" name="a299a3895d2231e409d49c1bd6db9c1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299a3895d2231e409d49c1bd6db9c1e5">&#9670;&#160;</a></span>traverse() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a>, char const  * &gt; traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a3646f96b954d1496bdca1e7c2ea10d7d">traverse_no_checks(Iterator, Iterator) const</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w, w + std::strlen(w))</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a4844f5274a3c63278e8bc067ca4b6f97" name="a4844f5274a3c63278e8bc067ca4b6f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4844f5274a3c63278e8bc067ca4b6f97">&#9670;&#160;</a></span>traverse() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a3646f96b954d1496bdca1e7c2ea10d7d">traverse_no_checks(Iterator, Iterator) const</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w.cbegin(), w.cend())</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the values in <code class="param">w</code> are signed integers, then they are converted to unsigned integers using <a class="elRef" href="http://en.cppreference.com/w/cpp/types/make_signed.html">std::make_signed</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="ae3549c46a4471bbbed06849b91f09966" name="ae3549c46a4471bbbed06849b91f09966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3549c46a4471bbbed06849b91f09966">&#9670;&#160;</a></span>traverse() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a>, word_type::const_iterator &gt; traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a3646f96b954d1496bdca1e7c2ea10d7d">traverse_no_checks(Iterator, Iterator) const</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w.cbegin(), w.cend())</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a41589479aac3edad67ae8b8259b5b638" name="a41589479aac3edad67ae8b8259b5b638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41589479aac3edad67ae8b8259b5b638">&#9670;&#160;</a></span>traverse() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const  * traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>st</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a07982678a78153dd1de0d15f0479321f">State&amp;, Iterator, Iterator) const</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w, w + std::strlen(w))</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a4784868a02247789bb6fa68fe5274ad1" name="a4784868a02247789bb6fa68fe5274ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4784868a02247789bb6fa68fe5274ad1">&#9670;&#160;</a></span>traverse() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>st</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a07982678a78153dd1de0d15f0479321f">State&amp;, Iterator, Iterator) const</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w.cbegin(), w.cend())</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the values in <code class="param">w</code> are signed integers, then they are converted to unsigned integers using <a class="elRef" href="http://en.cppreference.com/w/cpp/types/make_signed.html">std::make_signed</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a0dc4c987b29a12cc9e70b4fa9230da78" name="a0dc4c987b29a12cc9e70b4fa9230da78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc4c987b29a12cc9e70b4fa9230da78">&#9670;&#160;</a></span>traverse() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">word_type::const_iterator traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>st</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a07982678a78153dd1de0d15f0479321f">State&amp;, Iterator, Iterator) const</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>u.throw_if_contains_unique_letter(w.cbegin(), w.cend())</code> throws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_ukkonen.html#a1d4c81a754be35e62b7055474756f517">throw_if_contains_unique_letter</a>. </dd></dl>

</div>
</div>
<a id="a1b496a364ab4fc95c062dd9d1e9f1d73" name="a1b496a364ab4fc95c062dd9d1e9f1d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b496a364ab4fc95c062dd9d1e9f1d73">&#9670;&#160;</a></span>traverse_no_checks() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a>, char const  * &gt; traverse_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a3646f96b954d1496bdca1e7c2ea10d7d">traverse_no_checks(Iterator, Iterator) const</a>. </p>

</div>
</div>
<a id="ab413a110accdb966387d9fbdfa19b919" name="ab413a110accdb966387d9fbdfa19b919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab413a110accdb966387d9fbdfa19b919">&#9670;&#160;</a></span>traverse_no_checks() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto traverse_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a3646f96b954d1496bdca1e7c2ea10d7d">traverse_no_checks(Iterator, Iterator) const</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If the values in <code class="param">w</code> are signed integers, then they are converted to unsigned integers using <a class="elRef" href="http://en.cppreference.com/w/cpp/types/make_signed.html">std::make_signed</a>. </dd></dl>

</div>
</div>
<a id="a8ccfa2d86e15d495d59fbe4989ad0f6c" name="a8ccfa2d86e15d495d59fbe4989ad0f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccfa2d86e15d495d59fbe4989ad0f6c">&#9670;&#160;</a></span>traverse_no_checks() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a>, word_type::const_iterator &gt; traverse_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a3646f96b954d1496bdca1e7c2ea10d7d">traverse_no_checks(Iterator, Iterator) const</a>. </p>

</div>
</div>
<a id="ad007286c43c4ab0214f764c0ba79ed40" name="ad007286c43c4ab0214f764c0ba79ed40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad007286c43c4ab0214f764c0ba79ed40">&#9670;&#160;</a></span>traverse_no_checks() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const  * traverse_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>st</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a07982678a78153dd1de0d15f0479321f">State&amp;, Iterator, Iterator) const</a>. </p>

</div>
</div>
<a id="a7b3a35eeb570b8d38a14c2b6b9763f9d" name="a7b3a35eeb570b8d38a14c2b6b9763f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3a35eeb570b8d38a14c2b6b9763f9d">&#9670;&#160;</a></span>traverse_no_checks() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto traverse_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>st</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a07982678a78153dd1de0d15f0479321f">State&amp;, Iterator, Iterator) const</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If the values in <code class="param">w</code> are signed integers, then they are converted to unsigned integers using <a class="elRef" href="http://en.cppreference.com/w/cpp/types/make_signed.html">std::make_signed</a>. </dd></dl>

</div>
</div>
<a id="ae9b865db29a12821d8a79056d3fe6567" name="ae9b865db29a12821d8a79056d3fe6567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b865db29a12821d8a79056d3fe6567">&#9670;&#160;</a></span>traverse_no_checks() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">word_type::const_iterator traverse_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibsemigroups_1_1_ukkonen_1_1_state.html">Ukkonen::State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>st</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_ukkonen.html">Ukkonen</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classlibsemigroups_1_1_ukkonen.html#a07982678a78153dd1de0d15f0479321f">State&amp;, Iterator, Iterator) const</a>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelibsemigroups.html">libsemigroups</a></li><li class="navelem"><a class="el" href="namespacelibsemigroups_1_1ukkonen.html">ukkonen</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
