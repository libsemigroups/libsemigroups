<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- BEGIN opengraph metadata -->
    <meta property="og:title" content="libsemigroups" />
    <meta property="og:image" content="libsemi_logo.jpeg" />
    <meta
      property="og:description"
      content="C++ library for semigroups and monoids."
    />
    <meta
      property="og:url"
      content="https://github.com/libsemigroups/libsemigroups"
    />
    <!-- END opengraph metadata -->
<title>libsemigroups: libsemigroups::presentation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/libsemigroups/libsemigroups" class="github-corner" title="View source on GitHub" target="_blank" rel="noopener noreferrer">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<a href="index.html">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="libsemi_logo.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsemigroups
   &#160;<span id="projectnumber">v3.2.0</span>
   </div>
   <div id="projectbrief">C++ library for semigroups and monoids</div>
  </td>
 </tr>
 </tbody>
</table>
</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="_HEADING_"><span>Library&#160;Info</span></a></li>
      <li><a href="md_authors.html"><span>Authors</span></a></li>
      <li><a href="citelist.html"><span>Bibliography</span></a></li>
      <li><a href="md_changelog-v3.html"><span>Changelog&#160;-&#160;version&#160;3</span></a></li>
      <li><a href="md_changelog-v2.html"><span>Changelog&#160;-&#160;version&#160;2</span></a></li>
      <li><a href="md_changelog-v1.html"><span>Changelog&#160;-&#160;version&#160;1</span></a></li>
      <li><a href="md_deprecate.html"><span>Deprecation</span></a></li>
      <li><a href="md_install.html"><span>Installation</span></a></li>
      <li><a href="_HEADING_"><span>Data&#160;structures</span></a></li>
      <li><a href="group__adapters__group.html"><span>Adapters</span></a></li>
      <li><a href="group__constants__group.html"><span>Constants</span></a></li>
      <li><a href="group__elements__group.html"><span>Elements</span></a></li>
      <li><a href="group__exception__group.html"><span>Exceptions</span></a></li>
      <li><a href="group__orders__group.html"><span>Orders</span></a></li>
      <li><a href="group__presentations__group.html"><span>Presentations</span></a></li>
      <li><a href="group__ranges__group.html"><span>Ranges</span></a></li>
      <li><a href="group__ukkonen__group.html"><span>Suffix&#160;trees</span></a></li>
      <li><a href="group__make__group.html"><span>The&#160;`make`&#160;function</span></a></li>
      <li><a href="group__to__group.html"><span>The&#160;`to`&#160;function</span></a></li>
      <li><a href="group__aho__corasick__group.html"><span>Tries</span></a></li>
      <li><a href="group__types__group.html"><span>Enums&#160;+&#160;Types</span></a></li>
      <li><a href="group__dot__group.html"><span>Visualisation</span></a></li>
      <li><a href="group__word__graph__group.html"><span>Word&#160;graphs</span></a></li>
      <li><a href="group__words__group.html"><span>Words</span></a></li>
      <li><a href="_HEADING_"><span>Main&#160;Algorithms</span></a></li>
      <li><a href="group__action__group.html"><span>Actions</span></a></li>
      <li><a href="group__cong__common__helpers__group.html"><span>Common&#160;congruence&#160;helper&#160;function</span></a></li>
      <li><a href="group__congruence__group.html"><span>Congruence</span></a></li>
      <li><a href="group__core__classes__group.html"><span>Core&#160;classes</span></a></li>
      <li><a href="group__froidure__pin__group.html"><span>Froidure-Pin</span></a></li>
      <li><a href="group__kambites__group.html"><span>Kambites</span></a></li>
      <li><a href="group__knuth__bendix__group.html"><span>Knuth-Bendix</span></a></li>
      <li><a href="group__konieczny__group.html"><span>Konieczny</span></a></li>
      <li><a href="group__sims__group.html"><span>Low&#160;Index&#160;Congruences</span></a></li>
      <li><a href="group__freeband__group.html"><span>Radoszewski-Rytter</span></a></li>
      <li><a href="group__schreier__sims__group.html"><span>Schreier-Sims</span></a></li>
      <li><a href="group__stephen__group.html"><span>Stephen</span></a></li>
      <li><a href="group__todd__coxeter__group.html"><span>Todd-Coxeter</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacelibsemigroups_1_1presentation.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">libsemigroups::presentation Namespace Reference<div class="ingroups"><a class="el" href="group__presentations__group.html">Presentations</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a>
<div class="textblock"><p>Defined in <code><a class="el" href="presentation_8hpp_source.html">presentation.hpp</a></code>.</p>
<p>This namespace contains various helper functions for the class <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>. These functions could be functions of <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a> but they only use public member functions of <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>, and so they are declared as free functions instead. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibsemigroups_1_1presentation_1_1examples.html">examples</a></td></tr>
<tr class="memdesc:namespacelibsemigroups_1_1presentation_1_1examples"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for presentations of some finitely presented semigroups. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aba4fd25074207d63e51e2c74b18ec05d" id="r_aba4fd25074207d63e51e2c74b18ec05d"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:aba4fd25074207d63e51e2c74b18ec05d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba4fd25074207d63e51e2c74b18ec05d">add_commutes_rules_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;letters)</td></tr>
<tr class="memdesc:aba4fd25074207d63e51e2c74b18ec05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules so specific letters commute.  <br /></td></tr>
<tr class="separator:aba4fd25074207d63e51e2c74b18ec05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd301c9aa6299cd6e9863934f3afb26" id="r_adcd301c9aa6299cd6e9863934f3afb26"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:adcd301c9aa6299cd6e9863934f3afb26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adcd301c9aa6299cd6e9863934f3afb26">add_commutes_rules_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;letters, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Word &gt; words)</td></tr>
<tr class="memdesc:adcd301c9aa6299cd6e9863934f3afb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules so specific letters commute with specific words.  <br /></td></tr>
<tr class="separator:adcd301c9aa6299cd6e9863934f3afb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d04d59da745faf2e6a1c981857c090e" id="r_a0d04d59da745faf2e6a1c981857c090e"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a0d04d59da745faf2e6a1c981857c090e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d04d59da745faf2e6a1c981857c090e">add_commutes_rules_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;letters1, Word const &amp;letters2)</td></tr>
<tr class="memdesc:a0d04d59da745faf2e6a1c981857c090e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules so specific letters commute.  <br /></td></tr>
<tr class="separator:a0d04d59da745faf2e6a1c981857c090e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4286297314617db5cdc69f89f848fe" id="r_abf4286297314617db5cdc69f89f848fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf4286297314617db5cdc69f89f848fe">add_cyclic_conjugates</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *relator)</td></tr>
<tr class="memdesc:abf4286297314617db5cdc69f89f848fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all cyclic permutations of a word as relators in a presentation.  <br /></td></tr>
<tr class="separator:abf4286297314617db5cdc69f89f848fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996e8653fc00c85b8e8ce2f115f6dff4" id="r_a996e8653fc00c85b8e8ce2f115f6dff4"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a996e8653fc00c85b8e8ce2f115f6dff4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a996e8653fc00c85b8e8ce2f115f6dff4">add_cyclic_conjugates</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;relator)</td></tr>
<tr class="memdesc:a996e8653fc00c85b8e8ce2f115f6dff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all cyclic permutations of a word as relators in a presentation.  <br /></td></tr>
<tr class="separator:a996e8653fc00c85b8e8ce2f115f6dff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6de2bb84f47841c5415b9f7d22a59b" id="r_abf6de2bb84f47841c5415b9f7d22a59b"><td class="memTemplParams" colspan="2">template&lt;typename Word1, typename Word2&gt; </td></tr>
<tr class="memitem:abf6de2bb84f47841c5415b9f7d22a59b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf6de2bb84f47841c5415b9f7d22a59b">add_cyclic_conjugates</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word1 &gt; &amp;p, Word2 const &amp;relator)</td></tr>
<tr class="memdesc:abf6de2bb84f47841c5415b9f7d22a59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all cyclic permutations of a word as relators in a presentation.  <br /></td></tr>
<tr class="separator:abf6de2bb84f47841c5415b9f7d22a59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688ae0627a79d88a722fde5cd2f336da" id="r_a688ae0627a79d88a722fde5cd2f336da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a688ae0627a79d88a722fde5cd2f336da">add_cyclic_conjugates_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *relator)</td></tr>
<tr class="memdesc:a688ae0627a79d88a722fde5cd2f336da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all cyclic permutations of a word as relators in a presentation.  <br /></td></tr>
<tr class="separator:a688ae0627a79d88a722fde5cd2f336da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb6965a1164ba55618258cf220a9e06" id="r_adcb6965a1164ba55618258cf220a9e06"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:adcb6965a1164ba55618258cf220a9e06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adcb6965a1164ba55618258cf220a9e06">add_cyclic_conjugates_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;relator)</td></tr>
<tr class="memdesc:adcb6965a1164ba55618258cf220a9e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all cyclic permutations of a word as relators in a presentation.  <br /></td></tr>
<tr class="separator:adcb6965a1164ba55618258cf220a9e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3e40ea4e3c09e12821fddce2b1e29a" id="r_ade3e40ea4e3c09e12821fddce2b1e29a"><td class="memTemplParams" colspan="2">template&lt;typename Word1, typename Word2&gt; </td></tr>
<tr class="memitem:ade3e40ea4e3c09e12821fddce2b1e29a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ade3e40ea4e3c09e12821fddce2b1e29a">add_cyclic_conjugates_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word1 &gt; &amp;p, Word2 const &amp;relator)</td></tr>
<tr class="memdesc:ade3e40ea4e3c09e12821fddce2b1e29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all cyclic permutations of a word as relators in a presentation.  <br /></td></tr>
<tr class="separator:ade3e40ea4e3c09e12821fddce2b1e29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204d70a297be8f67ca41b28d501b2746" id="r_a204d70a297be8f67ca41b28d501b2746"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a204d70a297be8f67ca41b28d501b2746"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a204d70a297be8f67ca41b28d501b2746">add_idempotent_rules_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;letters)</td></tr>
<tr class="memdesc:a204d70a297be8f67ca41b28d501b2746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules that define each letter as an idempotent.  <br /></td></tr>
<tr class="separator:a204d70a297be8f67ca41b28d501b2746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97116b13ea4b20d65dee405f311f42d0" id="r_a97116b13ea4b20d65dee405f311f42d0"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a97116b13ea4b20d65dee405f311f42d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97116b13ea4b20d65dee405f311f42d0">add_identity_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, typename <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> e)</td></tr>
<tr class="memdesc:a97116b13ea4b20d65dee405f311f42d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules for an identity element.  <br /></td></tr>
<tr class="separator:a97116b13ea4b20d65dee405f311f42d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ab32292d024ec04ad3abd9fd715fc3" id="r_ab8ab32292d024ec04ad3abd9fd715fc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8ab32292d024ec04ad3abd9fd715fc3">add_inverse_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *vals, char e=<a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a>)</td></tr>
<tr class="memdesc:ab8ab32292d024ec04ad3abd9fd715fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules for inverses.  <br /></td></tr>
<tr class="separator:ab8ab32292d024ec04ad3abd9fd715fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39a6ad8b9694fb7e1ea3dc518a8cde6" id="r_ad39a6ad8b9694fb7e1ea3dc518a8cde6"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ad39a6ad8b9694fb7e1ea3dc518a8cde6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad39a6ad8b9694fb7e1ea3dc518a8cde6">add_inverse_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;vals, typename <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> e=<a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a>)</td></tr>
<tr class="memdesc:ad39a6ad8b9694fb7e1ea3dc518a8cde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules for inverses.  <br /></td></tr>
<tr class="separator:ad39a6ad8b9694fb7e1ea3dc518a8cde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3549f72bc6f99a31439bb28c136262ef" id="r_a3549f72bc6f99a31439bb28c136262ef"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a3549f72bc6f99a31439bb28c136262ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3549f72bc6f99a31439bb28c136262ef">add_involution_rules_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;letters)</td></tr>
<tr class="memdesc:a3549f72bc6f99a31439bb28c136262ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules that define involution.  <br /></td></tr>
<tr class="separator:a3549f72bc6f99a31439bb28c136262ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47828c9c3a9a232a6e2716903f2202b" id="r_ab47828c9c3a9a232a6e2716903f2202b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab47828c9c3a9a232a6e2716903f2202b">add_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *lhop, char const *rhop)</td></tr>
<tr class="memdesc:ab47828c9c3a9a232a6e2716903f2202b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>char const*</code>.  <br /></td></tr>
<tr class="separator:ab47828c9c3a9a232a6e2716903f2202b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443507ef9ef8ffb631493b3a034db200" id="r_a443507ef9ef8ffb631493b3a034db200"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a443507ef9ef8ffb631493b3a034db200">add_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *lhop, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;rhop)</td></tr>
<tr class="memdesc:a443507ef9ef8ffb631493b3a034db200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>char const*</code> and <code>string const &amp;</code>.  <br /></td></tr>
<tr class="separator:a443507ef9ef8ffb631493b3a034db200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a321dd3335d2239b8e9b49efd83f18" id="r_a78a321dd3335d2239b8e9b49efd83f18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78a321dd3335d2239b8e9b49efd83f18">add_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;lhop, char const *rhop)</td></tr>
<tr class="memdesc:a78a321dd3335d2239b8e9b49efd83f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>string const &amp;</code> and <code>char const*</code>.  <br /></td></tr>
<tr class="separator:a78a321dd3335d2239b8e9b49efd83f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec13b8a8bd3e87b579d949f56900f356" id="r_aec13b8a8bd3e87b579d949f56900f356"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Letter&gt; </td></tr>
<tr class="memitem:aec13b8a8bd3e87b579d949f56900f356"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec13b8a8bd3e87b579d949f56900f356">add_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt; lhop, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt; rhop)</td></tr>
<tr class="memdesc:aec13b8a8bd3e87b579d949f56900f356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>initializer_list</code>.  <br /></td></tr>
<tr class="separator:aec13b8a8bd3e87b579d949f56900f356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec80128d3c2e4b7cbf276731e0edfe56" id="r_aec80128d3c2e4b7cbf276731e0edfe56"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:aec80128d3c2e4b7cbf276731e0edfe56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec80128d3c2e4b7cbf276731e0edfe56">add_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;lhop, Word const &amp;rhop)</td></tr>
<tr class="memdesc:aec80128d3c2e4b7cbf276731e0edfe56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by reference and check.  <br /></td></tr>
<tr class="separator:aec80128d3c2e4b7cbf276731e0edfe56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a95e25c9bd84f930b71a116861a8ef" id="r_a11a95e25c9bd84f930b71a116861a8ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11a95e25c9bd84f930b71a116861a8ef">add_rule_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *lhop, char const *rhop)</td></tr>
<tr class="memdesc:a11a95e25c9bd84f930b71a116861a8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>char const*</code>.  <br /></td></tr>
<tr class="separator:a11a95e25c9bd84f930b71a116861a8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e7525ceaf1c1f72f323716c69e405a" id="r_ac4e7525ceaf1c1f72f323716c69e405a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4e7525ceaf1c1f72f323716c69e405a">add_rule_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *lhop, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;rhop)</td></tr>
<tr class="memdesc:ac4e7525ceaf1c1f72f323716c69e405a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>char const*</code> and <code>string const&amp;</code>.  <br /></td></tr>
<tr class="separator:ac4e7525ceaf1c1f72f323716c69e405a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237fa07d38a2a86ee30ccb661fd29d8c" id="r_a237fa07d38a2a86ee30ccb661fd29d8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a237fa07d38a2a86ee30ccb661fd29d8c">add_rule_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;lhop, char const *rhop)</td></tr>
<tr class="memdesc:a237fa07d38a2a86ee30ccb661fd29d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>string const&amp;</code> and <code>char const*</code>.  <br /></td></tr>
<tr class="separator:a237fa07d38a2a86ee30ccb661fd29d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b810cd98d27ace7d93fb9571431b5d" id="r_a54b810cd98d27ace7d93fb9571431b5d"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Letter&gt; </td></tr>
<tr class="memitem:a54b810cd98d27ace7d93fb9571431b5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a54b810cd98d27ace7d93fb9571431b5d">add_rule_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt; lhop, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt; rhop)</td></tr>
<tr class="memdesc:a54b810cd98d27ace7d93fb9571431b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>initializer_list</code>.  <br /></td></tr>
<tr class="separator:a54b810cd98d27ace7d93fb9571431b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa8feb639d28dbe9a7af0fce7b93c43" id="r_a8aa8feb639d28dbe9a7af0fce7b93c43"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a8aa8feb639d28dbe9a7af0fce7b93c43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8aa8feb639d28dbe9a7af0fce7b93c43">add_rule_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;lhop, Word const &amp;rhop)</td></tr>
<tr class="memdesc:a8aa8feb639d28dbe9a7af0fce7b93c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by reference.  <br /></td></tr>
<tr class="separator:a8aa8feb639d28dbe9a7af0fce7b93c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6180b7c4223506b956425c494bda6b07" id="r_a6180b7c4223506b956425c494bda6b07"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Iterator&gt; </td></tr>
<tr class="memitem:a6180b7c4223506b956425c494bda6b07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6180b7c4223506b956425c494bda6b07">add_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a6180b7c4223506b956425c494bda6b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the rules stored in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:a6180b7c4223506b956425c494bda6b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c792235574835a04dec1420123c781" id="r_ae8c792235574835a04dec1420123c781"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ae8c792235574835a04dec1420123c781"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae8c792235574835a04dec1420123c781">add_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;q)</td></tr>
<tr class="memdesc:ae8c792235574835a04dec1420123c781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the rules of <code class="param">q</code> to <code class="param">p</code>.  <br /></td></tr>
<tr class="separator:ae8c792235574835a04dec1420123c781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8c165b843fa198a52f7b19339debee" id="r_a7a8c165b843fa198a52f7b19339debee"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Iterator&gt; </td></tr>
<tr class="memitem:a7a8c165b843fa198a52f7b19339debee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a8c165b843fa198a52f7b19339debee">add_rules_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a7a8c165b843fa198a52f7b19339debee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the rules stored in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:a7a8c165b843fa198a52f7b19339debee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7cbdc2c5554c454d22008a531abf11" id="r_ace7cbdc2c5554c454d22008a531abf11"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ace7cbdc2c5554c454d22008a531abf11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ace7cbdc2c5554c454d22008a531abf11">add_rules_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;q)</td></tr>
<tr class="memdesc:ace7cbdc2c5554c454d22008a531abf11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the rules of <code class="param">q</code> to <code class="param">p</code>.  <br /></td></tr>
<tr class="separator:ace7cbdc2c5554c454d22008a531abf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3c9d8cb00a2d2c2f723743e41ad4fd" id="r_afa3c9d8cb00a2d2c2f723743e41ad4fd"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:afa3c9d8cb00a2d2c2f723743e41ad4fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afa3c9d8cb00a2d2c2f723743e41ad4fd">add_zero_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, typename <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> z)</td></tr>
<tr class="memdesc:afa3c9d8cb00a2d2c2f723743e41ad4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules for a zero element.  <br /></td></tr>
<tr class="separator:afa3c9d8cb00a2d2c2f723743e41ad4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326ce3f4e0df610dd6864b08e9a596dc" id="r_a326ce3f4e0df610dd6864b08e9a596dc"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a326ce3f4e0df610dd6864b08e9a596dc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a326ce3f4e0df610dd6864b08e9a596dc">are_rules_sorted</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:a326ce3f4e0df610dd6864b08e9a596dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the rules are sorted relative to shortlex.  <br /></td></tr>
<tr class="separator:a326ce3f4e0df610dd6864b08e9a596dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6126865fec0ff1b3e2706244a2579142" id="r_a6126865fec0ff1b3e2706244a2579142"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Compare&gt; </td></tr>
<tr class="memitem:a6126865fec0ff1b3e2706244a2579142"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6126865fec0ff1b3e2706244a2579142">are_rules_sorted</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p, Compare cmp)</td></tr>
<tr class="memdesc:a6126865fec0ff1b3e2706244a2579142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the rules are sorted relative to <code class="param">cmp</code> .  <br /></td></tr>
<tr class="separator:a6126865fec0ff1b3e2706244a2579142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b344185adebb3e25d83448205f4aab" id="r_a19b344185adebb3e25d83448205f4aab"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a19b344185adebb3e25d83448205f4aab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a19b344185adebb3e25d83448205f4aab">balance</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a19b344185adebb3e25d83448205f4aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect inverses and balance the length of the left-hand and right-hand sides.  <br /></td></tr>
<tr class="separator:a19b344185adebb3e25d83448205f4aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aea3d7c44b49cc967a5848d675fb937" id="r_a8aea3d7c44b49cc967a5848d675fb937"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a8aea3d7c44b49cc967a5848d675fb937"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8aea3d7c44b49cc967a5848d675fb937">balance</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;inverses)</td></tr>
<tr class="memdesc:a8aea3d7c44b49cc967a5848d675fb937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the length of the left-hand and right-hand sides.  <br /></td></tr>
<tr class="separator:a8aea3d7c44b49cc967a5848d675fb937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a88d8ae5e68fd09a65cf10a8a5d5473" id="r_a8a88d8ae5e68fd09a65cf10a8a5d5473"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a8a88d8ae5e68fd09a65cf10a8a5d5473"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a88d8ae5e68fd09a65cf10a8a5d5473">balance</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;letters, Word const &amp;inverses)</td></tr>
<tr class="memdesc:a8a88d8ae5e68fd09a65cf10a8a5d5473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the length of the left-hand and right-hand sides.  <br /></td></tr>
<tr class="separator:a8a88d8ae5e68fd09a65cf10a8a5d5473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7777b62f0c9e34551030c07cd16875ce" id="r_a7777b62f0c9e34551030c07cd16875ce"><td class="memTemplParams" colspan="2">template&lt;typename Word1, typename Word2&gt; </td></tr>
<tr class="memitem:a7777b62f0c9e34551030c07cd16875ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7777b62f0c9e34551030c07cd16875ce">balance</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word1 &gt; &amp;p, Word2 const &amp;letters, Word2 const &amp;inverses)</td></tr>
<tr class="memdesc:a7777b62f0c9e34551030c07cd16875ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the length of the left-hand and right-hand sides.  <br /></td></tr>
<tr class="separator:a7777b62f0c9e34551030c07cd16875ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94f24fa85486d3f6db5d1ac0c02fad5" id="r_ab94f24fa85486d3f6db5d1ac0c02fad5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab94f24fa85486d3f6db5d1ac0c02fad5">balance_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *letters, char const *inverses)</td></tr>
<tr class="memdesc:ab94f24fa85486d3f6db5d1ac0c02fad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the length of the left-hand and right-hand sides.  <br /></td></tr>
<tr class="separator:ab94f24fa85486d3f6db5d1ac0c02fad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13c039a5d607f003ac8273a8b1722c2" id="r_aa13c039a5d607f003ac8273a8b1722c2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa13c039a5d607f003ac8273a8b1722c2">balance_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, std::string_view letters, std::string_view inverses)</td></tr>
<tr class="memdesc:aa13c039a5d607f003ac8273a8b1722c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the length of the left-hand and right-hand sides.  <br /></td></tr>
<tr class="separator:aa13c039a5d607f003ac8273a8b1722c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ad642457b89dc87e88e03c890715e7" id="r_a15ad642457b89dc87e88e03c890715e7"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a15ad642457b89dc87e88e03c890715e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a15ad642457b89dc87e88e03c890715e7">balance_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;inverses)</td></tr>
<tr class="memdesc:a15ad642457b89dc87e88e03c890715e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the length of the left-hand and right-hand sides.  <br /></td></tr>
<tr class="separator:a15ad642457b89dc87e88e03c890715e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d92a4c5b3b46959e67b7fc656a6a32f" id="r_a6d92a4c5b3b46959e67b7fc656a6a32f"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a6d92a4c5b3b46959e67b7fc656a6a32f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d92a4c5b3b46959e67b7fc656a6a32f">balance_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;letters, Word const &amp;inverses)</td></tr>
<tr class="memdesc:a6d92a4c5b3b46959e67b7fc656a6a32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the length of the left-hand and right-hand sides.  <br /></td></tr>
<tr class="separator:a6d92a4c5b3b46959e67b7fc656a6a32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a284c3587eaec3aa4d51c7716f16c1" id="r_a72a284c3587eaec3aa4d51c7716f16c1"><td class="memTemplParams" colspan="2">template&lt;typename Word1, typename Word2&gt; </td></tr>
<tr class="memitem:a72a284c3587eaec3aa4d51c7716f16c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72a284c3587eaec3aa4d51c7716f16c1">balance_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word1 &gt; &amp;p, Word2 const &amp;letters, Word2 const &amp;inverses)</td></tr>
<tr class="memdesc:a72a284c3587eaec3aa4d51c7716f16c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the length of the left-hand and right-hand sides.  <br /></td></tr>
<tr class="separator:a72a284c3587eaec3aa4d51c7716f16c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222c4489fa22dfe970147e7e6a29fa02" id="r_a222c4489fa22dfe970147e7e6a29fa02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a222c4489fa22dfe970147e7e6a29fa02">change_alphabet</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *new_alphabet)</td></tr>
<tr class="memdesc:a222c4489fa22dfe970147e7e6a29fa02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change or re-order the alphabet.  <br /></td></tr>
<tr class="separator:a222c4489fa22dfe970147e7e6a29fa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2edd3f1ec1d0724aa27a33a47f0b0e3" id="r_ad2edd3f1ec1d0724aa27a33a47f0b0e3"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ad2edd3f1ec1d0724aa27a33a47f0b0e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2edd3f1ec1d0724aa27a33a47f0b0e3">change_alphabet</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const  &amp;new_alphabet)</td></tr>
<tr class="memdesc:ad2edd3f1ec1d0724aa27a33a47f0b0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change or re-order the alphabet.  <br /></td></tr>
<tr class="separator:ad2edd3f1ec1d0724aa27a33a47f0b0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49562e8f86600c1b0fcbde6df5ebdbf5" id="r_a49562e8f86600c1b0fcbde6df5ebdbf5"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a49562e8f86600c1b0fcbde6df5ebdbf5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49562e8f86600c1b0fcbde6df5ebdbf5">contains_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;lhs, Word const &amp;rhs)</td></tr>
<tr class="memdesc:a49562e8f86600c1b0fcbde6df5ebdbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a presentation contains a rule.  <br /></td></tr>
<tr class="separator:a49562e8f86600c1b0fcbde6df5ebdbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a75c93f9dd281c0962f8985855b628" id="r_a03a75c93f9dd281c0962f8985855b628"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a03a75c93f9dd281c0962f8985855b628"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a03a75c93f9dd281c0962f8985855b628">find_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;lhs, Word const &amp;rhs)</td></tr>
<tr class="memdesc:a03a75c93f9dd281c0962f8985855b628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a rule.  <br /></td></tr>
<tr class="separator:a03a75c93f9dd281c0962f8985855b628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c9f487714188e3ee4ef24ca0b76ba0" id="r_a41c9f487714188e3ee4ef24ca0b76ba0"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a41c9f487714188e3ee4ef24ca0b76ba0"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a41c9f487714188e3ee4ef24ca0b76ba0">find_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p, Word const &amp;lhs, Word const &amp;rhs)</td></tr>
<tr class="memdesc:a41c9f487714188e3ee4ef24ca0b76ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a rule.  <br /></td></tr>
<tr class="separator:a41c9f487714188e3ee4ef24ca0b76ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17a0f522b0999ec1ee43b1d941b4cae" id="r_ad17a0f522b0999ec1ee43b1d941b4cae"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ad17a0f522b0999ec1ee43b1d941b4cae"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad17a0f522b0999ec1ee43b1d941b4cae">find_rule_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;lhs, Word const &amp;rhs)</td></tr>
<tr class="memdesc:ad17a0f522b0999ec1ee43b1d941b4cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a rule.  <br /></td></tr>
<tr class="separator:ad17a0f522b0999ec1ee43b1d941b4cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aec81161d5d64f34ebe5cf57f857476" id="r_a3aec81161d5d64f34ebe5cf57f857476"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a3aec81161d5d64f34ebe5cf57f857476"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3aec81161d5d64f34ebe5cf57f857476">find_rule_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p, Word const &amp;lhs, Word const &amp;rhs)</td></tr>
<tr class="memdesc:a3aec81161d5d64f34ebe5cf57f857476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a rule.  <br /></td></tr>
<tr class="separator:a3aec81161d5d64f34ebe5cf57f857476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2fb0325c17b4b25d53babe3454f9d9" id="r_add2fb0325c17b4b25d53babe3454f9d9"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:add2fb0325c17b4b25d53babe3454f9d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#add2fb0325c17b4b25d53babe3454f9d9">first_unused_letter</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:add2fb0325c17b4b25d53babe3454f9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first letter <b>not</b> in the alphabet of a presentation.  <br /></td></tr>
<tr class="separator:add2fb0325c17b4b25d53babe3454f9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bedb3cafce55ab3e5d55fd081a8849" id="r_ad1bedb3cafce55ab3e5d55fd081a8849"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ad1bedb3cafce55ab3e5d55fd081a8849"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad1bedb3cafce55ab3e5d55fd081a8849">greedy_reduce_length</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:ad1bedb3cafce55ab3e5d55fd081a8849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greedily reduce the length of the presentation using <code>longest_subword_reducing_length</code>.  <br /></td></tr>
<tr class="separator:ad1bedb3cafce55ab3e5d55fd081a8849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ab46eec3f588f8cf0df768ec71ac20" id="r_a51ab46eec3f588f8cf0df768ec71ac20"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a51ab46eec3f588f8cf0df768ec71ac20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a51ab46eec3f588f8cf0df768ec71ac20">greedy_reduce_length_and_number_of_gens</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a51ab46eec3f588f8cf0df768ec71ac20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greedily reduce the length and number of generators of the presentation.  <br /></td></tr>
<tr class="separator:a51ab46eec3f588f8cf0df768ec71ac20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34ef79c6d3e7e9f8a10a828238ab837" id="r_af34ef79c6d3e7e9f8a10a828238ab837"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:af34ef79c6d3e7e9f8a10a828238ab837"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af34ef79c6d3e7e9f8a10a828238ab837">index_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p, Word const &amp;lhs, Word const &amp;rhs)</td></tr>
<tr class="memdesc:af34ef79c6d3e7e9f8a10a828238ab837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of a rule or <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a>.  <br /></td></tr>
<tr class="separator:af34ef79c6d3e7e9f8a10a828238ab837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0e4e68ed68fb95365c11d42262b4a4" id="r_a3c0e4e68ed68fb95365c11d42262b4a4"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a3c0e4e68ed68fb95365c11d42262b4a4"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c0e4e68ed68fb95365c11d42262b4a4">index_rule_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p, Word const &amp;lhs, Word const &amp;rhs)</td></tr>
<tr class="memdesc:a3c0e4e68ed68fb95365c11d42262b4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of a rule or <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a>.  <br /></td></tr>
<tr class="separator:a3c0e4e68ed68fb95365c11d42262b4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea86d4fd7797f11bc5f2d403b93d9715" id="r_aea86d4fd7797f11bc5f2d403b93d9715"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:aea86d4fd7797f11bc5f2d403b93d9715"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea86d4fd7797f11bc5f2d403b93d9715">is_normalized</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:aea86d4fd7797f11bc5f2d403b93d9715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the presentation is normalized.  <br /></td></tr>
<tr class="separator:aea86d4fd7797f11bc5f2d403b93d9715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac7aa06b21ac9b745d6f6d307ffbab1" id="r_a5ac7aa06b21ac9b745d6f6d307ffbab1"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a5ac7aa06b21ac9b745d6f6d307ffbab1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5ac7aa06b21ac9b745d6f6d307ffbab1">is_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p, Word const &amp;lhs, Word const &amp;rhs)</td></tr>
<tr class="memdesc:a5ac7aa06b21ac9b745d6f6d307ffbab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a rule belongs to a presentation.  <br /></td></tr>
<tr class="separator:a5ac7aa06b21ac9b745d6f6d307ffbab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de5951def57124c2c4972d026c19da" id="r_ab0de5951def57124c2c4972d026c19da"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ab0de5951def57124c2c4972d026c19da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab0de5951def57124c2c4972d026c19da">is_rule_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p, Word const &amp;lhs, Word const &amp;rhs)</td></tr>
<tr class="memdesc:ab0de5951def57124c2c4972d026c19da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a rule belongs to a presentation.  <br /></td></tr>
<tr class="separator:ab0de5951def57124c2c4972d026c19da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad503a8cc1838501f3b2b26bbb3fe78ee" id="r_ad503a8cc1838501f3b2b26bbb3fe78ee"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ad503a8cc1838501f3b2b26bbb3fe78ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad503a8cc1838501f3b2b26bbb3fe78ee">is_strongly_compressible</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:ad503a8cc1838501f3b2b26bbb3fe78ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the \(1\)-relation presentation can be strongly compressed.  <br /></td></tr>
<tr class="separator:ad503a8cc1838501f3b2b26bbb3fe78ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4f0c313d39e8062e1efd4c23be2c48" id="r_adc4f0c313d39e8062e1efd4c23be2c48"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:adc4f0c313d39e8062e1efd4c23be2c48"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc4f0c313d39e8062e1efd4c23be2c48">length</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:adc4f0c313d39e8062e1efd4c23be2c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the lengths of all values in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:adc4f0c313d39e8062e1efd4c23be2c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab497e1912b31da8d098193daff8d05c7" id="r_ab497e1912b31da8d098193daff8d05c7"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ab497e1912b31da8d098193daff8d05c7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab497e1912b31da8d098193daff8d05c7">length</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:ab497e1912b31da8d098193daff8d05c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the lengths of the rules of <code class="param">p</code>.  <br /></td></tr>
<tr class="separator:ab497e1912b31da8d098193daff8d05c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d1cde375c344f2883be80622cdab80" id="r_a22d1cde375c344f2883be80622cdab80"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a22d1cde375c344f2883be80622cdab80"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22d1cde375c344f2883be80622cdab80">longest_rule</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a22d1cde375c344f2883be80622cdab80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing at the left-hand side of the first rule of maximal length in the given range.  <br /></td></tr>
<tr class="separator:a22d1cde375c344f2883be80622cdab80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905af2e4e6bc2d4e0d565fecb167060f" id="r_a905af2e4e6bc2d4e0d565fecb167060f"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a905af2e4e6bc2d4e0d565fecb167060f"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a905af2e4e6bc2d4e0d565fecb167060f">longest_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:a905af2e4e6bc2d4e0d565fecb167060f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing at the left-hand side of the first rule in the presentation with maximal length.  <br /></td></tr>
<tr class="separator:a905af2e4e6bc2d4e0d565fecb167060f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af54c090bb9f81f86d1e834fbdbc842" id="r_a0af54c090bb9f81f86d1e834fbdbc842"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a0af54c090bb9f81f86d1e834fbdbc842"><td class="memTemplItemLeft" align="right" valign="top">Iterator::value_type::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0af54c090bb9f81f86d1e834fbdbc842">longest_rule_length</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a0af54c090bb9f81f86d1e834fbdbc842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum length of a rule in the given range.  <br /></td></tr>
<tr class="separator:a0af54c090bb9f81f86d1e834fbdbc842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd9114b812112f4ef7900267aace604" id="r_a7dd9114b812112f4ef7900267aace604"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a7dd9114b812112f4ef7900267aace604"><td class="memTemplItemLeft" align="right" valign="top">Word::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7dd9114b812112f4ef7900267aace604">longest_rule_length</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:a7dd9114b812112f4ef7900267aace604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum length of a rule in the presentation.  <br /></td></tr>
<tr class="separator:a7dd9114b812112f4ef7900267aace604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bd3357ca0f50a429df940ee4cdaa95" id="r_a57bd3357ca0f50a429df940ee4cdaa95"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a57bd3357ca0f50a429df940ee4cdaa95"><td class="memTemplItemLeft" align="right" valign="top">Word&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57bd3357ca0f50a429df940ee4cdaa95">longest_subword_reducing_length</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a57bd3357ca0f50a429df940ee4cdaa95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the longest common subword of the rules.  <br /></td></tr>
<tr class="separator:a57bd3357ca0f50a429df940ee4cdaa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f71687ecca9e2782cf17f8d0dc9f439" id="r_a9f71687ecca9e2782cf17f8d0dc9f439"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a9f71687ecca9e2782cf17f8d0dc9f439"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9f71687ecca9e2782cf17f8d0dc9f439">make_semigroup</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a9f71687ecca9e2782cf17f8d0dc9f439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a monoid presentation to a semigroup presentation.  <br /></td></tr>
<tr class="separator:a9f71687ecca9e2782cf17f8d0dc9f439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad88ee5f4b8c87466fb33283787fc98d" id="r_aad88ee5f4b8c87466fb33283787fc98d"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:aad88ee5f4b8c87466fb33283787fc98d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aad88ee5f4b8c87466fb33283787fc98d">normalize_alphabet</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:aad88ee5f4b8c87466fb33283787fc98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the alphabet to \(\{0, \ldots, n - 1\}\).  <br /></td></tr>
<tr class="separator:aad88ee5f4b8c87466fb33283787fc98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f82a21af1e0e278e66fd1aea2949faf" id="r_a9f82a21af1e0e278e66fd1aea2949faf"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a9f82a21af1e0e278e66fd1aea2949faf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9f82a21af1e0e278e66fd1aea2949faf">reduce_complements</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a9f82a21af1e0e278e66fd1aea2949faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there are rules \(u = v\) and \(v = w\) where  \(|w| &lt;
|v|\), then replace \(u = v\) by \(u = w\).  <br /></td></tr>
<tr class="separator:a9f82a21af1e0e278e66fd1aea2949faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12eee0cff7880777dbc3bbba74de7bdf" id="r_a12eee0cff7880777dbc3bbba74de7bdf"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a12eee0cff7880777dbc3bbba74de7bdf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a12eee0cff7880777dbc3bbba74de7bdf">reduce_to_2_generators</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, size_t index=0)</td></tr>
<tr class="memdesc:a12eee0cff7880777dbc3bbba74de7bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the number of generators in a \(1\)-relation presentation to <code>2</code>.  <br /></td></tr>
<tr class="separator:a12eee0cff7880777dbc3bbba74de7bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf820f4a3a95bb86f65ad2988e4ebe3" id="r_adaf820f4a3a95bb86f65ad2988e4ebe3"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:adaf820f4a3a95bb86f65ad2988e4ebe3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adaf820f4a3a95bb86f65ad2988e4ebe3">remove_duplicate_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:adaf820f4a3a95bb86f65ad2988e4ebe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicate rules.  <br /></td></tr>
<tr class="separator:adaf820f4a3a95bb86f65ad2988e4ebe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0eda9b2399fafdc35cf13a8abf71c76" id="r_ac0eda9b2399fafdc35cf13a8abf71c76"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ac0eda9b2399fafdc35cf13a8abf71c76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0eda9b2399fafdc35cf13a8abf71c76">remove_redundant_generators</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:ac0eda9b2399fafdc35cf13a8abf71c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any trivially redundant generators.  <br /></td></tr>
<tr class="separator:ac0eda9b2399fafdc35cf13a8abf71c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784fe4c484d3c4fa97d9856f4d9363ec" id="r_a784fe4c484d3c4fa97d9856f4d9363ec"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a784fe4c484d3c4fa97d9856f4d9363ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a784fe4c484d3c4fa97d9856f4d9363ec">remove_trivial_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a784fe4c484d3c4fa97d9856f4d9363ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove rules consisting of identical words.  <br /></td></tr>
<tr class="separator:a784fe4c484d3c4fa97d9856f4d9363ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9446d7e75e55059446137dc90a5d85" id="r_a0c9446d7e75e55059446137dc90a5d85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c9446d7e75e55059446137dc90a5d85">replace_subword</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *existing, char const *replacement)</td></tr>
<tr class="memdesc:a0c9446d7e75e55059446137dc90a5d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace non-overlapping instances of a subword by another word by <code>const chat*</code>.  <br /></td></tr>
<tr class="separator:a0c9446d7e75e55059446137dc90a5d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e339b2779d8b2d1d40fafa4428e9513" id="r_a5e339b2779d8b2d1d40fafa4428e9513"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Iterator1, typename Iterator2&gt; </td></tr>
<tr class="memitem:a5e339b2779d8b2d1d40fafa4428e9513"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5e339b2779d8b2d1d40fafa4428e9513">replace_subword</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Iterator1 first_existing, Iterator1 last_existing, Iterator2 first_replacement, Iterator2 last_replacement)</td></tr>
<tr class="memdesc:a5e339b2779d8b2d1d40fafa4428e9513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace non-overlapping instances of a subword by another word.  <br /></td></tr>
<tr class="separator:a5e339b2779d8b2d1d40fafa4428e9513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bd68d064a46c7b477e11bc4c1f8667" id="r_a92bd68d064a46c7b477e11bc4c1f8667"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a92bd68d064a46c7b477e11bc4c1f8667"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92bd68d064a46c7b477e11bc4c1f8667">replace_subword</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;existing, Word const &amp;replacement)</td></tr>
<tr class="memdesc:a92bd68d064a46c7b477e11bc4c1f8667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace non-overlapping instances of a subword by another word.  <br /></td></tr>
<tr class="separator:a92bd68d064a46c7b477e11bc4c1f8667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a28e29e9dcad2b9d48e1558cc1bb920" id="r_a8a28e29e9dcad2b9d48e1558cc1bb920"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a8a28e29e9dcad2b9d48e1558cc1bb920"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a28e29e9dcad2b9d48e1558cc1bb920">replace_word</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;existing, Word const &amp;replacement)</td></tr>
<tr class="memdesc:a8a28e29e9dcad2b9d48e1558cc1bb920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace instances of a word on either side of a rule by another word.  <br /></td></tr>
<tr class="separator:a8a28e29e9dcad2b9d48e1558cc1bb920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265744c7f98fbbd671d496386bbc8e98" id="r_a265744c7f98fbbd671d496386bbc8e98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a265744c7f98fbbd671d496386bbc8e98">replace_word_with_new_generator</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *w)</td></tr>
<tr class="memdesc:a265744c7f98fbbd671d496386bbc8e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace non-overlapping instances of a subword via <code>char const*</code>.  <br /></td></tr>
<tr class="separator:a265744c7f98fbbd671d496386bbc8e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed818a30289cea069ce8196809a8675" id="r_a0ed818a30289cea069ce8196809a8675"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Iterator&gt; </td></tr>
<tr class="memitem:a0ed818a30289cea069ce8196809a8675"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ed818a30289cea069ce8196809a8675">replace_word_with_new_generator</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a0ed818a30289cea069ce8196809a8675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace non-overlapping instances of a subword via iterators.  <br /></td></tr>
<tr class="separator:a0ed818a30289cea069ce8196809a8675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada89238bda7b8f989fdf2fffcb86418e" id="r_ada89238bda7b8f989fdf2fffcb86418e"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ada89238bda7b8f989fdf2fffcb86418e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada89238bda7b8f989fdf2fffcb86418e">replace_word_with_new_generator</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;w)</td></tr>
<tr class="memdesc:ada89238bda7b8f989fdf2fffcb86418e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace non-overlapping instances of a word with a new generator via const reference.  <br /></td></tr>
<tr class="separator:ada89238bda7b8f989fdf2fffcb86418e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09297ced05d3a33849423c06d9285624" id="r_a09297ced05d3a33849423c06d9285624"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a09297ced05d3a33849423c06d9285624"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09297ced05d3a33849423c06d9285624">reverse</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;&amp;p)</td></tr>
<tr class="memdesc:a09297ced05d3a33849423c06d9285624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse every rule.  <br /></td></tr>
<tr class="separator:a09297ced05d3a33849423c06d9285624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4273c14477b26904fa81aebb11f33ec9" id="r_a4273c14477b26904fa81aebb11f33ec9"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a4273c14477b26904fa81aebb11f33ec9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4273c14477b26904fa81aebb11f33ec9">reverse</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a4273c14477b26904fa81aebb11f33ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse every rule.  <br /></td></tr>
<tr class="separator:a4273c14477b26904fa81aebb11f33ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65069c045453edf6cc59c6c2fbe65343" id="r_a65069c045453edf6cc59c6c2fbe65343"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a65069c045453edf6cc59c6c2fbe65343"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a65069c045453edf6cc59c6c2fbe65343">shortest_rule</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a65069c045453edf6cc59c6c2fbe65343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing at the left-hand side of the first rule of minimal length in the given range.  <br /></td></tr>
<tr class="separator:a65069c045453edf6cc59c6c2fbe65343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0923abe23bd54ef423419b7f11933903" id="r_a0923abe23bd54ef423419b7f11933903"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a0923abe23bd54ef423419b7f11933903"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0923abe23bd54ef423419b7f11933903">shortest_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:a0923abe23bd54ef423419b7f11933903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing at the left-hand side of the first rule in the presentation with minimal length.  <br /></td></tr>
<tr class="separator:a0923abe23bd54ef423419b7f11933903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74635d388ce178f7b69d5c851bc8b93f" id="r_a74635d388ce178f7b69d5c851bc8b93f"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a74635d388ce178f7b69d5c851bc8b93f"><td class="memTemplItemLeft" align="right" valign="top">Iterator::value_type::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a74635d388ce178f7b69d5c851bc8b93f">shortest_rule_length</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a74635d388ce178f7b69d5c851bc8b93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum length of a rule in the given range.  <br /></td></tr>
<tr class="separator:a74635d388ce178f7b69d5c851bc8b93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482393ea90410b720e40969ea90f70ad" id="r_a482393ea90410b720e40969ea90f70ad"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a482393ea90410b720e40969ea90f70ad"><td class="memTemplItemLeft" align="right" valign="top">Word::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a482393ea90410b720e40969ea90f70ad">shortest_rule_length</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:a482393ea90410b720e40969ea90f70ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum length of a rule in the presentation.  <br /></td></tr>
<tr class="separator:a482393ea90410b720e40969ea90f70ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59966c2bf07eb98721dfe506e3c03e4e" id="r_a59966c2bf07eb98721dfe506e3c03e4e"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a59966c2bf07eb98721dfe506e3c03e4e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a59966c2bf07eb98721dfe506e3c03e4e">sort_each_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a59966c2bf07eb98721dfe506e3c03e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the left-hand and right-hand side of each rule by shortlex.  <br /></td></tr>
<tr class="separator:a59966c2bf07eb98721dfe506e3c03e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a74fc9f1cf7a0fbc165106c1b3931a1" id="r_a2a74fc9f1cf7a0fbc165106c1b3931a1"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Compare&gt; </td></tr>
<tr class="memitem:a2a74fc9f1cf7a0fbc165106c1b3931a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2a74fc9f1cf7a0fbc165106c1b3931a1">sort_each_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Compare cmp)</td></tr>
<tr class="memdesc:a2a74fc9f1cf7a0fbc165106c1b3931a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the left-hand and right-hand side of each rule relative to <code class="param">cmp</code>.  <br /></td></tr>
<tr class="separator:a2a74fc9f1cf7a0fbc165106c1b3931a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2524c6337ced966c9b1001c768c7d5" id="r_ada2524c6337ced966c9b1001c768c7d5"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ada2524c6337ced966c9b1001c768c7d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada2524c6337ced966c9b1001c768c7d5">sort_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:ada2524c6337ced966c9b1001c768c7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all of the rules by shortlex.  <br /></td></tr>
<tr class="separator:ada2524c6337ced966c9b1001c768c7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91480c6d87296d5586c1e17df0d0d437" id="r_a91480c6d87296d5586c1e17df0d0d437"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Compare&gt; </td></tr>
<tr class="memitem:a91480c6d87296d5586c1e17df0d0d437"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a91480c6d87296d5586c1e17df0d0d437">sort_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Compare cmp)</td></tr>
<tr class="memdesc:a91480c6d87296d5586c1e17df0d0d437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all of the rules by <code class="param">cmp</code>.  <br /></td></tr>
<tr class="separator:a91480c6d87296d5586c1e17df0d0d437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe7deda5b5f239dfca3054c32de9da3" id="r_aafe7deda5b5f239dfca3054c32de9da3"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:aafe7deda5b5f239dfca3054c32de9da3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aafe7deda5b5f239dfca3054c32de9da3">strongly_compress</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:aafe7deda5b5f239dfca3054c32de9da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strongly compress a \(1\)-relation presentation.  <br /></td></tr>
<tr class="separator:aafe7deda5b5f239dfca3054c32de9da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dca3de75b7b21cef075378282bc980" id="r_a56dca3de75b7b21cef075378282bc980"><td class="memTemplParams" colspan="2">template&lt;typename Word1, typename Word2&gt; </td></tr>
<tr class="memitem:a56dca3de75b7b21cef075378282bc980"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a56dca3de75b7b21cef075378282bc980">throw_if_bad_inverses</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word1 &gt; const &amp;p, Word2 const &amp;inverses)</td></tr>
<tr class="memdesc:a56dca3de75b7b21cef075378282bc980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an exception if <code class="param">vals</code> do not define valid inverses.  <br /></td></tr>
<tr class="separator:a56dca3de75b7b21cef075378282bc980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bc3c09c460643fd40c6fdb89574950" id="r_a13bc3c09c460643fd40c6fdb89574950"><td class="memTemplParams" colspan="2">template&lt;typename Word1, typename Word2&gt; </td></tr>
<tr class="memitem:a13bc3c09c460643fd40c6fdb89574950"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13bc3c09c460643fd40c6fdb89574950">throw_if_bad_inverses</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word1 &gt; const &amp;p, Word2 const &amp;letters, Word2 const &amp;inverses)</td></tr>
<tr class="memdesc:a13bc3c09c460643fd40c6fdb89574950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an exception if the argument <code class="param">inverses</code> does not define valid inverses for <code class="param">letters</code>.  <br /></td></tr>
<tr class="separator:a13bc3c09c460643fd40c6fdb89574950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be80ecb20d06625ecc638dc103bd5dd" id="r_a8be80ecb20d06625ecc638dc103bd5dd"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Iterator&gt; </td></tr>
<tr class="memitem:a8be80ecb20d06625ecc638dc103bd5dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8be80ecb20d06625ecc638dc103bd5dd">throw_if_bad_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a8be80ecb20d06625ecc638dc103bd5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check rules against the alphabet of <code class="param">p</code>.  <br /></td></tr>
<tr class="separator:a8be80ecb20d06625ecc638dc103bd5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9bdbe4253a0acb561e92260d733b43" id="r_aec9bdbe4253a0acb561e92260d733b43"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:aec9bdbe4253a0acb561e92260d733b43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec9bdbe4253a0acb561e92260d733b43">throw_if_not_normalized</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p, std::string_view arg=&quot;1st&quot;)</td></tr>
<tr class="memdesc:aec9bdbe4253a0acb561e92260d733b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws if the presentation isn't normalized.  <br /></td></tr>
<tr class="separator:aec9bdbe4253a0acb561e92260d733b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371053f8f212083c6af099cabdf33b68" id="r_a371053f8f212083c6af099cabdf33b68"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a371053f8f212083c6af099cabdf33b68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a371053f8f212083c6af099cabdf33b68">throw_if_odd_number_of_rules</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a371053f8f212083c6af099cabdf33b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw if the distance between iterators is not even.  <br /></td></tr>
<tr class="separator:a371053f8f212083c6af099cabdf33b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191d5ec2c8a3d1e819818e273149151f" id="r_a191d5ec2c8a3d1e819818e273149151f"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a191d5ec2c8a3d1e819818e273149151f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a191d5ec2c8a3d1e819818e273149151f">throw_if_odd_number_of_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:a191d5ec2c8a3d1e819818e273149151f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw if the number of words in a presentation is odd.  <br /></td></tr>
<tr class="separator:a191d5ec2c8a3d1e819818e273149151f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1569bd727eb77cb388ea564b0da00a84" id="r_a1569bd727eb77cb388ea564b0da00a84"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1569bd727eb77cb388ea564b0da00a84">to_gap_string</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; const &amp;p, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;var_name)</td></tr>
<tr class="memdesc:a1569bd727eb77cb388ea564b0da00a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the code that would create <code class="param">p</code> in GAP.  <br /></td></tr>
<tr class="separator:a1569bd727eb77cb388ea564b0da00a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa78f3583eccd084393f466b5615a7e" id="r_afaa78f3583eccd084393f466b5615a7e"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaa78f3583eccd084393f466b5615a7e">to_gap_string</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> &gt; const &amp;p, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;var_name)</td></tr>
<tr class="memdesc:afaa78f3583eccd084393f466b5615a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the code that would create <code class="param">p</code> in GAP.  <br /></td></tr>
<tr class="separator:afaa78f3583eccd084393f466b5615a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb72dbbefb9e5d5c7b33d7faeb19420" id="r_adcb72dbbefb9e5d5c7b33d7faeb19420"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:adcb72dbbefb9e5d5c7b33d7faeb19420"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adcb72dbbefb9e5d5c7b33d7faeb19420">to_report_string</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:adcb72dbbefb9e5d5c7b33d7faeb19420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a representation of a presentation to appear in the reporting output.  <br /></td></tr>
<tr class="separator:adcb72dbbefb9e5d5c7b33d7faeb19420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cb8e99df6d12b0b299f07df4bd692e" id="r_a39cb8e99df6d12b0b299f07df4bd692e"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a39cb8e99df6d12b0b299f07df4bd692e"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; Word, Word &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a39cb8e99df6d12b0b299f07df4bd692e">try_detect_inverses</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a39cb8e99df6d12b0b299f07df4bd692e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to detect group inverses.  <br /></td></tr>
<tr class="separator:a39cb8e99df6d12b0b299f07df4bd692e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acdedd5ef354d2aea6316d2762b2592" id="r_a1acdedd5ef354d2aea6316d2762b2592"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a1acdedd5ef354d2aea6316d2762b2592"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1acdedd5ef354d2aea6316d2762b2592">try_detect_inverses</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word &amp;letters, Word &amp;inverses)</td></tr>
<tr class="memdesc:a1acdedd5ef354d2aea6316d2762b2592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to detect group inverses.  <br /></td></tr>
<tr class="separator:a1acdedd5ef354d2aea6316d2762b2592"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aba4fd25074207d63e51e2c74b18ec05d" name="aba4fd25074207d63e51e2c74b18ec05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4fd25074207d63e51e2c74b18ec05d">&#9670;&#160;</a></span>add_commutes_rules_no_checks() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_commutes_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rules to <code class="param">p</code> of the form \(uv = vu\) for every pair of letters \(u, v\) in <code class="param">letters</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">letters</td><td>the collection of letters to add rules for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of <code class="param">p</code> are performed. </dd></dl>

</div>
</div>
<a id="adcd301c9aa6299cd6e9863934f3afb26" name="adcd301c9aa6299cd6e9863934f3afb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd301c9aa6299cd6e9863934f3afb26">&#9670;&#160;</a></span>add_commutes_rules_no_checks() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_commutes_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Word &gt;</td>          <td class="paramname"><span class="paramname"><em>words</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rules to <code class="param">p</code> of the form \(uv = vu\) for every letter \(u\) in <code class="param">letters</code> and \(v\) in <code class="param">words</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">letters</td><td>the collection of letters to add rules for. </td></tr>
    <tr><td class="paramname">words</td><td>the collection of words to add rules for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of <code class="param">p</code> are performed. </dd></dl>

</div>
</div>
<a id="a0d04d59da745faf2e6a1c981857c090e" name="a0d04d59da745faf2e6a1c981857c090e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d04d59da745faf2e6a1c981857c090e">&#9670;&#160;</a></span>add_commutes_rules_no_checks() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_commutes_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rules to <code class="param">p</code> of the form \(uv = vu\) for every letter \(u\) in <code class="param">letters1</code> and \(v\) in <code class="param">letters2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">letters1</td><td>the first collection of letters to add rules for. </td></tr>
    <tr><td class="paramname">letters2</td><td>the second collection of letters to add rules for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of <code class="param">p</code> are performed. </dd></dl>

</div>
</div>
<a id="abf4286297314617db5cdc69f89f848fe" name="abf4286297314617db5cdc69f89f848fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4286297314617db5cdc69f89f848fe">&#9670;&#160;</a></span>add_cyclic_conjugates() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void add_cyclic_conjugates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>relator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overload for <a class="el" href="#abf6de2bb84f47841c5415b9f7d22a59b">add_cyclic_conjugates(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;)</a> to allow string literals to be used for the parameters <code class="param">relator</code>. </p>

</div>
</div>
<a id="a996e8653fc00c85b8e8ce2f115f6dff4" name="a996e8653fc00c85b8e8ce2f115f6dff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996e8653fc00c85b8e8ce2f115f6dff4">&#9670;&#160;</a></span>add_cyclic_conjugates() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_cyclic_conjugates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>relator</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overload for <a class="el" href="#abf6de2bb84f47841c5415b9f7d22a59b">add_cyclic_conjugates(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;)</a> to allow, for example, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a> to be used for the parameters <code class="param">relator</code>. </p>

</div>
</div>
<a id="abf6de2bb84f47841c5415b9f7d22a59b" name="abf6de2bb84f47841c5415b9f7d22a59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6de2bb84f47841c5415b9f7d22a59b">&#9670;&#160;</a></span>add_cyclic_conjugates() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word1, typename Word2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_cyclic_conjugates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word2 const &amp;</td>          <td class="paramname"><span class="paramname"><em>relator</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds one rule with left-hand side <code>w</code> and right-hand side the empty word to the presentation <code class="param">p</code>, for every cyclic permutation <code>w</code> of <code class="param">relator</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word1</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Word2</td><td>the type of the word <code class="param">relator</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">relator</td><td>the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">relator</code> contains any letters not belonging to <code>p.alphabet()</code>.</td></tr>
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">p</code> does not contain the empty word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If multiple cyclic permutations of <code class="param">relator</code> are equal, then there will be duplicate rules added to the presentation <code class="param">p</code>. You can remove these by calling <a class="el" href="#adaf820f4a3a95bb86f65ad2988e4ebe3">remove_duplicate_rules</a>. </dd></dl>

</div>
</div>
<a id="a688ae0627a79d88a722fde5cd2f336da" name="a688ae0627a79d88a722fde5cd2f336da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688ae0627a79d88a722fde5cd2f336da">&#9670;&#160;</a></span>add_cyclic_conjugates_no_checks() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void add_cyclic_conjugates_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>relator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overload for <a class="el" href="#ade3e40ea4e3c09e12821fddce2b1e29a">add_cyclic_conjugates_no_checks(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;)</a> to allow, string literals to be used for the parameters <code class="param">relator</code>. </p>

</div>
</div>
<a id="adcb6965a1164ba55618258cf220a9e06" name="adcb6965a1164ba55618258cf220a9e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb6965a1164ba55618258cf220a9e06">&#9670;&#160;</a></span>add_cyclic_conjugates_no_checks() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_cyclic_conjugates_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>relator</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overload for <a class="el" href="#ade3e40ea4e3c09e12821fddce2b1e29a">add_cyclic_conjugates_no_checks(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;)</a> to allow, for example, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a> to be used for the parameters <code class="param">relator</code>. </p>

</div>
</div>
<a id="ade3e40ea4e3c09e12821fddce2b1e29a" name="ade3e40ea4e3c09e12821fddce2b1e29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3e40ea4e3c09e12821fddce2b1e29a">&#9670;&#160;</a></span>add_cyclic_conjugates_no_checks() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word1, typename Word2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_cyclic_conjugates_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word2 const &amp;</td>          <td class="paramname"><span class="paramname"><em>relator</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds one rule with left-hand side <code>w</code> and right-hand side the empty word to the presentation <code class="param">p</code>, for every cyclic permutation <code>w</code> of <code class="param">relator</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word1</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Word2</td><td>the type of the word <code class="param">relator</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">relator</td><td>the word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If multiple cyclic permutations of <code class="param">relator</code> are equal, then there will be duplicate rules added to the presentation <code class="param">p</code>. You can remove these by calling <a class="el" href="#adaf820f4a3a95bb86f65ad2988e4ebe3">remove_duplicate_rules</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs no checks that the letters in <code class="param">relator</code> belong to the alphabet of <code class="param">p</code> or that <code class="param">p</code> contains the empty word. </dd></dl>

</div>
</div>
<a id="a204d70a297be8f67ca41b28d501b2746" name="a204d70a297be8f67ca41b28d501b2746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204d70a297be8f67ca41b28d501b2746">&#9670;&#160;</a></span>add_idempotent_rules_no_checks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_idempotent_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rules to <code class="param">p</code> of the form \(a^2 = a\) for every letter \(a\) in <code class="param">letters</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">letters</td><td>the letters to make idempotent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of <code class="param">p</code> are performed. </dd></dl>

</div>
</div>
<a id="a97116b13ea4b20d65dee405f311f42d0" name="a97116b13ea4b20d65dee405f311f42d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97116b13ea4b20d65dee405f311f42d0">&#9670;&#160;</a></span>add_identity_rules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_identity_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rules of the form \(ae = ea = a\) for every letter \(a\) in the alphabet of <code class="param">p</code>, and where \(e\) is the second parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">e</td><td>the identity element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">e</code> is not a letter in <code>p.alphabet()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the number of rules. </dd></dl>

</div>
</div>
<a id="ab8ab32292d024ec04ad3abd9fd715fc3" name="ab8ab32292d024ec04ad3abd9fd715fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ab32292d024ec04ad3abd9fd715fc3">&#9670;&#160;</a></span>add_inverse_rules() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_inverse_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>vals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>e</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The letter <code>a</code> with index <code>i</code> in <code class="param">vals</code> is the inverse of the letter in <code>alphabet()</code> with index <code>i</code>. The rules added are  \(a_ib_i
= e\) where the alphabet is \(\{a_1, \ldots, a_n\}\); the 2nd parameter <code class="param">vals</code> is \(\{b_1, \ldots, b_n\}\); and \(e\) is the 3rd parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">vals</td><td>the inverses. </td></tr>
    <tr><td class="paramname">e</td><td>the identity element (defaults to <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a>, meaning use the empty word).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if any of the following apply:<ul>
<li>the length of <code class="param">vals</code> is not equal to <code>alphabet().size()</code>;</li>
<li>the letters in <code class="param">vals</code> are not exactly those in <code>alphabet()</code> (perhaps in a different order);</li>
<li>\((a_i ^ {-1}) ^ {-1} = a_i\) does not hold for some \(i\);</li>
<li>\(e ^ {-1} = e\) does not hold</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>\(O(n)\) where \(n\) is <code>p.alphabet().size()</code>. </dd></dl>

</div>
</div>
<a id="ad39a6ad8b9694fb7e1ea3dc518a8cde6" name="ad39a6ad8b9694fb7e1ea3dc518a8cde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39a6ad8b9694fb7e1ea3dc518a8cde6">&#9670;&#160;</a></span>add_inverse_rules() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_inverse_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>vals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The letter <code>a</code> with index <code>i</code> in <code class="param">vals</code> is the inverse of the letter in <code>alphabet()</code> with index <code>i</code>. The rules added are  \(a_ib_i
= e\) where the alphabet is \(\{a_1, \ldots, a_n\}\); the 2nd parameter <code class="param">vals</code> is \(\{b_1, \ldots, b_n\}\); and \(e\) is the 3rd parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">vals</td><td>the inverses. </td></tr>
    <tr><td class="paramname">e</td><td>the identity element (defaults to <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a>, meaning use the empty word).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if any of the following apply:<ul>
<li>the length of <code class="param">vals</code> is not equal to <code>alphabet().size()</code>;</li>
<li>the letters in <code class="param">vals</code> are not exactly those in <code>alphabet()</code> (perhaps in a different order);</li>
<li>\((a_i ^ {-1}) ^ {-1} = a_i\) does not hold for some \(i\);</li>
<li>\(e ^ {-1} = e\) does not hold</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>\(O(n)\) where \(n\) is <code>p.alphabet().size()</code>. </dd></dl>

</div>
</div>
<a id="a3549f72bc6f99a31439bb28c136262ef" name="a3549f72bc6f99a31439bb28c136262ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3549f72bc6f99a31439bb28c136262ef">&#9670;&#160;</a></span>add_involution_rules_no_checks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_involution_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rules to <code class="param">p</code> of the form \(a^2 = \varepsilon\) for every letter \(a\) in <code class="param">letters</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">letters</td><td>the letters to add involution rules for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of <code class="param">p</code> are performed. </dd></dl>

</div>
</div>
<a id="ab47828c9c3a9a232a6e2716903f2202b" name="ab47828c9c3a9a232a6e2716903f2202b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47828c9c3a9a232a6e2716903f2202b">&#9670;&#160;</a></span>add_rule() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">lhop</code> or <code class="param">rhop</code> contains any letters not belonging to <code>p.alphabet()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a443507ef9ef8ffb631493b3a034db200" name="a443507ef9ef8ffb631493b3a034db200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443507ef9ef8ffb631493b3a034db200">&#9670;&#160;</a></span>add_rule() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">lhop</code> or <code class="param">rhop</code> contains any letters not belonging to <code>p.alphabet()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78a321dd3335d2239b8e9b49efd83f18" name="a78a321dd3335d2239b8e9b49efd83f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a321dd3335d2239b8e9b49efd83f18">&#9670;&#160;</a></span>add_rule() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">lhop</code> or <code class="param">rhop</code> contains any letters not belonging to <code>p.alphabet()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec13b8a8bd3e87b579d949f56900f356" name="aec13b8a8bd3e87b579d949f56900f356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec13b8a8bd3e87b579d949f56900f356">&#9670;&#160;</a></span>add_rule() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Letter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt;</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt;</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Letter</td><td>the type of the values in the <code>initializer_list</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">lhop</code> or <code class="param">rhop</code> contains any letters not belonging to <code>p.alphabet()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec80128d3c2e4b7cbf276731e0edfe56" name="aec80128d3c2e4b7cbf276731e0edfe56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec80128d3c2e4b7cbf276731e0edfe56">&#9670;&#160;</a></span>add_rule() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules, after checking that <code class="param">lhop</code> and <code class="param">rhop</code> consist entirely of letters in the alphabet of <code class="param">p</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">lhop</code> or <code class="param">rhop</code> contains any letters not belonging to <code>p.alphabet()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11a95e25c9bd84f930b71a116861a8ef" name="a11a95e25c9bd84f930b71a116861a8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a95e25c9bd84f930b71a116861a8ef">&#9670;&#160;</a></span>add_rule_no_checks() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_rule_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of the presentation are performed. </dd></dl>

</div>
</div>
<a id="ac4e7525ceaf1c1f72f323716c69e405a" name="ac4e7525ceaf1c1f72f323716c69e405a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e7525ceaf1c1f72f323716c69e405a">&#9670;&#160;</a></span>add_rule_no_checks() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_rule_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of the presentation are performed. </dd></dl>

</div>
</div>
<a id="a237fa07d38a2a86ee30ccb661fd29d8c" name="a237fa07d38a2a86ee30ccb661fd29d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237fa07d38a2a86ee30ccb661fd29d8c">&#9670;&#160;</a></span>add_rule_no_checks() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_rule_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of the presentation are performed. </dd></dl>

</div>
</div>
<a id="a54b810cd98d27ace7d93fb9571431b5d" name="a54b810cd98d27ace7d93fb9571431b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b810cd98d27ace7d93fb9571431b5d">&#9670;&#160;</a></span>add_rule_no_checks() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Letter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rule_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt;</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt;</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Letter</td><td>the type of the values in the <code>initializer_list</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of the presentation are performed. </dd></dl>

</div>
</div>
<a id="a8aa8feb639d28dbe9a7af0fce7b93c43" name="a8aa8feb639d28dbe9a7af0fce7b93c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa8feb639d28dbe9a7af0fce7b93c43">&#9670;&#160;</a></span>add_rule_no_checks() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rule_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of the presentation are performed. </dd></dl>

</div>
</div>
<a id="a6180b7c4223506b956425c494bda6b07" name="a6180b7c4223506b956425c494bda6b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6180b7c4223506b956425c494bda6b07">&#9670;&#160;</a></span>add_rules() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds the rules stored in the range <code>[first, last)</code> to <code class="param">p</code>.</p>
<p>Before it is added, each rule is checked to check it contains only letters of the alphabet of <code class="param">p</code>. If the \(n\)th rule causes this function to throw, the first \(n-1\) rules will still be added to <code class="param">p</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Iterator</td><td>the type of the second and third arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing at the first rule to add. </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing one beyond the last rule to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if any rule contains any letters not belonging to <code>p.alphabet()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8c792235574835a04dec1420123c781" name="ae8c792235574835a04dec1420123c781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c792235574835a04dec1420123c781">&#9670;&#160;</a></span>add_rules() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds all the rules of the second argument <code class="param">q</code> to the first argument <code class="param">p</code> which is modified in-place.</p>
<p>Before it is added, each rule is checked to check it contains only letters of the alphabet of <code class="param">p</code>. If the \(n\)th rule causes this function to throw, the first \(n-1\) rules will still be added to <code class="param">p</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">q</td><td>the presentation with the rules to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if any rule contains any letters not belonging to <code>p.alphabet()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a8c165b843fa198a52f7b19339debee" name="a7a8c165b843fa198a52f7b19339debee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8c165b843fa198a52f7b19339debee">&#9670;&#160;</a></span>add_rules_no_checks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds the rules stored in the range <code>[first, last)</code> to the presentation <code class="param">p</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Iterator</td><td>the type of the second and third arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing at the first rule to add. </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing one beyond the last rule to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of the presentation are performed. </dd></dl>

</div>
</div>
<a id="ace7cbdc2c5554c454d22008a531abf11" name="ace7cbdc2c5554c454d22008a531abf11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7cbdc2c5554c454d22008a531abf11">&#9670;&#160;</a></span>add_rules_no_checks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds all the rules of the second argument <code class="param">q</code> to the first argument <code class="param">p</code> which is modified in-place.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">q</td><td>the presentation with the rules to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of the presentation are performed. </dd></dl>

</div>
</div>
<a id="afa3c9d8cb00a2d2c2f723743e41ad4fd" name="afa3c9d8cb00a2d2c2f723743e41ad4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3c9d8cb00a2d2c2f723743e41ad4fd">&#9670;&#160;</a></span>add_zero_rules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_zero_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rules of the form \(az = za = z\) for every letter \(a\) in the alphabet of <code class="param">p</code>, and where \(z\) is the second parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">z</td><td>the zero element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">z</code> is not a letter in <code>p.alphabet()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the number of rules. </dd></dl>

</div>
</div>
<a id="a326ce3f4e0df610dd6864b08e9a596dc" name="a326ce3f4e0df610dd6864b08e9a596dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326ce3f4e0df610dd6864b08e9a596dc">&#9670;&#160;</a></span>are_rules_sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool are_rules_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the rules \(u_1 = v_1, \ldots, u_n = v_n\) satisfy \(u_1v_1 &lt; \cdots &lt; u_nv_n\) where \(&lt;\) is shortlex order.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="#ada2524c6337ced966c9b1001c768c7d5">sort_rules(Presentation&lt;Word&gt;&amp; p)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6126865fec0ff1b3e2706244a2579142" name="a6126865fec0ff1b3e2706244a2579142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6126865fec0ff1b3e2706244a2579142">&#9670;&#160;</a></span>are_rules_sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool are_rules_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>cmp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the rules \(u_1 = v_1, \ldots, u_n = v_n\) satisfy \(u_1v_1 &lt; \cdots &lt; u_nv_n\) where \(&lt;\) is the order described by <code class="param">cmp</code> .</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Compare</td><td>the type of the compare function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to check. </td></tr>
    <tr><td class="paramname">cmp</td><td>the comparison function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="#a91480c6d87296d5586c1e17df0d0d437">sort_rules(Presentation&lt;Word&gt;&amp; p, Compare cmp)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a19b344185adebb3e25d83448205f4aab" name="a19b344185adebb3e25d83448205f4aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b344185adebb3e25d83448205f4aab">&#9670;&#160;</a></span>balance() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void balance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function calls <a class="el" href="#a72a284c3587eaec3aa4d51c7716f16c1">balance_no_checks(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;, Word2 const&amp;)</a> where the 2nd and 3rd arguments are deduced from the rules in the using <a class="el" href="#a1acdedd5ef354d2aea6316d2762b2592">try_detect_inverses</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <a class="el" href="classlibsemigroups_1_1_presentation.html#a198d5db68cd73451d94cb58d8f7603e6">throw_if_bad_alphabet_or_rules</a> throws. </td></tr>
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if conflicting inverses for any letter are detected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8aea3d7c44b49cc967a5848d675fb937" name="a8aea3d7c44b49cc967a5848d675fb937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aea3d7c44b49cc967a5848d675fb937">&#9670;&#160;</a></span>balance() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void balance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function just calls <a class="el" href="#a72a284c3587eaec3aa4d51c7716f16c1">balance_no_checks(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;, Word2 const&amp;)</a> where the 2nd parameter is defined to be <code>p.alphabet()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">inverses</td><td>the inverses of the letters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <a class="el" href="classlibsemigroups_1_1_presentation.html#a198d5db68cd73451d94cb58d8f7603e6">throw_if_bad_alphabet_or_rules</a> throws. </td></tr>
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <a class="el" href="#a56dca3de75b7b21cef075378282bc980">throw_if_bad_inverses</a> throws when called with <code>p.alphabet()</code> and <code class="param">inverses</code>. This function does not check that the values in <code class="param">inverses</code> are actually inverses for the values in <code>p.alphabet()</code>, and balances the relations as described in <a class="el" href="#a72a284c3587eaec3aa4d51c7716f16c1">balance_no_checks(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;, Word2 const&amp;)</a> assuming that this is the case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a88d8ae5e68fd09a65cf10a8a5d5473" name="a8a88d8ae5e68fd09a65cf10a8a5d5473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a88d8ae5e68fd09a65cf10a8a5d5473">&#9670;&#160;</a></span>balance() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void balance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overload for <a class="el" href="#a7777b62f0c9e34551030c07cd16875ce">balance(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;, Word2 const&amp;)</a> to allow, for example, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a> to be used for the parameters <code class="param">letters</code> and <code class="param">inverses</code>. </p>

</div>
</div>
<a id="a7777b62f0c9e34551030c07cd16875ce" name="a7777b62f0c9e34551030c07cd16875ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7777b62f0c9e34551030c07cd16875ce">&#9670;&#160;</a></span>balance() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word1, typename Word2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void balance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word2 const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word2 const &amp;</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="#a72a284c3587eaec3aa4d51c7716f16c1">balance_no_checks(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;, Word2 const&amp;)</a> for details about this function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word1</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Word2</td><td>the type of the words <code class="param">letters</code> and <code class="param">inverses</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">letters</td><td>the letters that can be replaced in the left-hand side. </td></tr>
    <tr><td class="paramname">inverses</td><td>the inverses of the letters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <a class="el" href="classlibsemigroups_1_1_presentation.html#a198d5db68cd73451d94cb58d8f7603e6">throw_if_bad_alphabet_or_rules</a> throws. </td></tr>
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <a class="el" href="#a56dca3de75b7b21cef075378282bc980">throw_if_bad_inverses</a> throws when called with <code class="param">letters</code> and <code class="param">inverses</code>. This does not check that the values in <code class="param">inverses</code> are actually inverses for the values in <code class="param">letters</code>, and balances the relations as described in <a class="el" href="#a72a284c3587eaec3aa4d51c7716f16c1">balance_no_checks(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;, Word2 const&amp;)</a> assuming that this is the case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab94f24fa85486d3f6db5d1ac0c02fad5" name="ab94f24fa85486d3f6db5d1ac0c02fad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94f24fa85486d3f6db5d1ac0c02fad5">&#9670;&#160;</a></span>balance_no_checks() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void balance_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overload for <a class="el" href="#a72a284c3587eaec3aa4d51c7716f16c1">balance_no_checks(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;, Word2 const&amp;)</a> to allow string literals to be used for the parameters <code class="param">letters</code> and <code class="param">inverses</code>. </p><dl class="section warning"><dt>Warning</dt><dd>This alias is deprecated and will be removed from <code>libsemigroups</code> in v4, please use <code>balance_no_checks(<a class="el" href="classlibsemigroups_1_1_presentation.html" title="For an implementation of presentations for semigroups or monoids.">Presentation</a>&lt;Word&gt;&amp;, Word const&amp;, Word const&amp;)</code> instead. </dd></dl>

</div>
</div>
<a id="aa13c039a5d607f003ac8273a8b1722c2" name="aa13c039a5d607f003ac8273a8b1722c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13c039a5d607f003ac8273a8b1722c2">&#9670;&#160;</a></span>balance_no_checks() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void balance_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overload for <a class="el" href="#a72a284c3587eaec3aa4d51c7716f16c1">balance_no_checks(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;, Word2 const&amp;)</a> to allow std::string_view to be used for the parameters <code class="param">letters</code> and <code class="param">inverses</code>. </p><dl class="section warning"><dt>Warning</dt><dd>This alias is deprecated and will be removed from <code>libsemigroups</code> in v4, please use <code>balance_no_checks(<a class="el" href="classlibsemigroups_1_1_presentation.html" title="For an implementation of presentations for semigroups or monoids.">Presentation</a>&lt;Word&gt;&amp;, Word const&amp;, Word const&amp;)</code> instead. </dd></dl>

</div>
</div>
<a id="a15ad642457b89dc87e88e03c890715e7" name="a15ad642457b89dc87e88e03c890715e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ad642457b89dc87e88e03c890715e7">&#9670;&#160;</a></span>balance_no_checks() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void balance_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function just calls <a class="el" href="#a72a284c3587eaec3aa4d51c7716f16c1">balance_no_checks(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;, Word2 const&amp;)</a> where the 2nd parameter is defined to be <code>p.alphabet()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">inverses</td><td>the inverses of the letters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that the semigroup defined by <code class="param">p</code> is isomorphic to a group, and that <code class="param">inverses</code> are valid. However, this function does no checks on its arguments. If the previous assumptions do not hold, there is no guarantee the the semigroup \(S\) defined by <code class="param">p</code> before this function is called will be isomorphic to the semigroup \(S&#39;\) defined by <code class="param">p</code> after this function is called. </dd></dl>

</div>
</div>
<a id="a6d92a4c5b3b46959e67b7fc656a6a32f" name="a6d92a4c5b3b46959e67b7fc656a6a32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d92a4c5b3b46959e67b7fc656a6a32f">&#9670;&#160;</a></span>balance_no_checks() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void balance_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overload for <a class="el" href="#a72a284c3587eaec3aa4d51c7716f16c1">balance_no_checks(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;, Word2 const&amp;)</a> to allow, for example, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a> to be used for the parameters <code class="param">letters</code> and <code class="param">inverses</code>. </p>

</div>
</div>
<a id="a72a284c3587eaec3aa4d51c7716f16c1" name="a72a284c3587eaec3aa4d51c7716f16c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a284c3587eaec3aa4d51c7716f16c1">&#9670;&#160;</a></span>balance_no_checks() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word1, typename Word2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void balance_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word2 const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word2 const &amp;</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function first sorts the sides of each rules so that the larger side of the rule is on the left. Then for each rule, while the last letter of the left-hand side is in <code class="param">letters</code>, the last letter of the left-hand side is removed and the corresponding value in <code class="param">inverses</code> is appended to the end of the right-hand side. Next, while the first letter of the left-hand side is in <code class="param">letters</code>, the first letter of the left-hand side is removed and the corresponding value in <code class="param">inverses</code> is appended to the front of the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word1</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Word2</td><td>the type of the words <code class="param">letters</code> and <code class="param">inverses</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">letters</td><td>the letters that can be replaced in the left-hand side. </td></tr>
    <tr><td class="paramname">inverses</td><td>the inverses of the letters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that the semigroup defined by <code class="param">p</code> is isomorphic to a group, and that <code class="param">inverses</code> are valid. However, this function does no checks on its arguments. If the previous assumptions do not hold, there is no guarantee the the semigroup \(S\) defined by <code class="param">p</code> before this function is called will be isomorphic to the semigroup \(S&#39;\) defined by <code class="param">p</code> after this function is called. </dd></dl>

</div>
</div>
<a id="a222c4489fa22dfe970147e7e6a29fa02" name="a222c4489fa22dfe970147e7e6a29fa02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222c4489fa22dfe970147e7e6a29fa02">&#9670;&#160;</a></span>change_alphabet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void change_alphabet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>new_alphabet</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function replaces <code>p.alphabet()</code> with <code class="param">new_alphabet</code> where possible, and re-writes the rules in the presentation using the new alphabet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">new_alphabet</td><td>the replacement alphabet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the size of <code>p.alphabet()</code> and <code class="param">new_alphabet</code> do not agree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2edd3f1ec1d0724aa27a33a47f0b0e3" name="ad2edd3f1ec1d0724aa27a33a47f0b0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2edd3f1ec1d0724aa27a33a47f0b0e3">&#9670;&#160;</a></span>change_alphabet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void change_alphabet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>new_alphabet</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function replaces <code>p.alphabet()</code> with <code class="param">new_alphabet</code>, where possible, and re-writes the rules in the presentation using the new alphabet.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">new_alphabet</td><td>the replacement alphabet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the size of <code>p.alphabet()</code> and <code class="param">new_alphabet</code> do not agree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49562e8f86600c1b0fcbde6df5ebdbf5" name="a49562e8f86600c1b0fcbde6df5ebdbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49562e8f86600c1b0fcbde6df5ebdbf5">&#9670;&#160;</a></span>contains_rule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool contains_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the rule with left-hand side <code class="param">lhs</code> and right-hand side <code class="param">rhs</code> is contained in <code class="param">p</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhs</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhs</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the number of rules. </dd></dl>

</div>
</div>
<a id="a03a75c93f9dd281c0962f8985855b628" name="a03a75c93f9dd281c0962f8985855b628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a75c93f9dd281c0962f8985855b628">&#9670;&#160;</a></span>find_rule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::iterator find_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns an iterator <code>it</code> pointing at the first occurrence of <code class="param">lhs</code> in an even index position of <code>p.rules</code> such that <code>it + 1</code> points at <code class="param">rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhs</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhs</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.throw_if_bad_alphabet_or_rules()</code> throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41c9f487714188e3ee4ef24ca0b76ba0" name="a41c9f487714188e3ee4ef24ca0b76ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c9f487714188e3ee4ef24ca0b76ba0">&#9670;&#160;</a></span>find_rule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::const_iterator find_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns an iterator <code>it</code> pointing at the first occurrence of <code class="param">lhs</code> in an even index position of <code>p.rules</code> such that <code>it + 1</code> points at <code class="param">rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhs</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhs</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.throw_if_bad_alphabet_or_rules()</code> throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad17a0f522b0999ec1ee43b1d941b4cae" name="ad17a0f522b0999ec1ee43b1d941b4cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17a0f522b0999ec1ee43b1d941b4cae">&#9670;&#160;</a></span>find_rule_no_checks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::iterator find_rule_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns an iterator <code>it</code> pointing at the first occurrence of <code class="param">lhs</code> in an even index position of <code>p.rules</code> such that <code>it + 1</code> points at <code class="param">rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhs</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhs</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its argument. In particular, it does not check that <code class="param">p</code> is properly defined, namely that the length of <code>p.rules</code> is even. If the rule we are trying to find is not in <code>p.rules</code>, then bad things might happen. </dd></dl>

</div>
</div>
<a id="a3aec81161d5d64f34ebe5cf57f857476" name="a3aec81161d5d64f34ebe5cf57f857476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aec81161d5d64f34ebe5cf57f857476">&#9670;&#160;</a></span>find_rule_no_checks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::const_iterator find_rule_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns an iterator <code>it</code> pointing at the first occurrence of <code class="param">lhs</code> in an even index position of <code>p.rules</code> such that <code>it + 1</code> points at <code class="param">rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhs</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhs</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its argument. In particular, it does not check that <code class="param">p</code> is properly defined, namely that the length of <code>p.rules</code> is even. If the rule we are trying to find is not in <code>p.rules</code>, then bad things might happen. </dd></dl>

</div>
</div>
<a id="add2fb0325c17b4b25d53babe3454f9d9" name="add2fb0325c17b4b25d53babe3454f9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2fb0325c17b4b25d53babe3454f9d9">&#9670;&#160;</a></span>first_unused_letter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> first_unused_letter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns <code>letter(p, i)</code> when <code>i</code> is the least possible value such that <code>!p.in_alphabet(letter(p, i))</code> if such a letter exists.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1" title="Type for the index of a generator of a semigroup.">letter_type</a></code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">p</code> already has an alphabet of the maximum possible size supported by <code><a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1" title="Type for the index of a generator of a semigroup.">letter_type</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1bedb3cafce55ab3e5d55fd081a8849" name="ad1bedb3cafce55ab3e5d55fd081a8849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bedb3cafce55ab3e5d55fd081a8849">&#9670;&#160;</a></span>greedy_reduce_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void greedy_reduce_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function repeatedly calls <code><a class="el" href="#a57bd3357ca0f50a429df940ee4cdaa95" title="Return the longest common subword of the rules.">presentation::longest_subword_reducing_length</a></code> and <code><a class="el" href="#a92bd68d064a46c7b477e11bc4c1f8667" title="Replace non-overlapping instances of a subword by another word.">presentation::replace_subword</a></code> to introduce a new generator and reduce the length of the presentation <code class="param">p</code> until <code><a class="el" href="#a57bd3357ca0f50a429df940ee4cdaa95" title="Return the longest common subword of the rules.">presentation::longest_subword_reducing_length</a></code> returns the empty word.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code><a class="el" href="#a57bd3357ca0f50a429df940ee4cdaa95" title="Return the longest common subword of the rules.">presentation::longest_subword_reducing_length</a></code> or <code><a class="el" href="#a8a28e29e9dcad2b9d48e1558cc1bb920" title="Replace instances of a word on either side of a rule by another word.">presentation::replace_word</a></code> does. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51ab46eec3f588f8cf0df768ec71ac20" name="a51ab46eec3f588f8cf0df768ec71ac20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ab46eec3f588f8cf0df768ec71ac20">&#9670;&#160;</a></span>greedy_reduce_length_and_number_of_gens()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void greedy_reduce_length_and_number_of_gens </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function repeatedly calls <code><a class="el" href="#a57bd3357ca0f50a429df940ee4cdaa95" title="Return the longest common subword of the rules.">presentation::longest_subword_reducing_length</a></code> and <code><a class="el" href="#a92bd68d064a46c7b477e11bc4c1f8667" title="Replace non-overlapping instances of a subword by another word.">presentation::replace_subword</a></code> to introduce a new generator to try to reduce the length of the presentation <code class="param">p</code> and the number of generators. This is done until either <code><a class="el" href="#a57bd3357ca0f50a429df940ee4cdaa95" title="Return the longest common subword of the rules.">presentation::longest_subword_reducing_length</a></code> returns the empty word, or the new length and number of generators is greater than or equal to that of the presentation in the previous iteration.</p>
<p>In the latter case, the presentation <code class="param">p</code> gets restored to the state it was in after the previous iteration.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>presentations::longest_subword_reducing_length</code> or <code>presentations::replace_word</code> does. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af34ef79c6d3e7e9f8a10a828238ab837" name="af34ef79c6d3e7e9f8a10a828238ab837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34ef79c6d3e7e9f8a10a828238ab837">&#9670;&#160;</a></span>index_rule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t index_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the minimum index <code>i</code> of <code class="param">lhs</code> such that <code>p.rules[i + 1]</code> equals <code class="param">rhs</code>; or <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a> if there is not such rule</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhs</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhs</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the rule or <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.throw_if_bad_alphabet_or_rules()</code> throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c0e4e68ed68fb95365c11d42262b4a4" name="a3c0e4e68ed68fb95365c11d42262b4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0e4e68ed68fb95365c11d42262b4a4">&#9670;&#160;</a></span>index_rule_no_checks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t index_rule_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the minimum index <code>i</code> of <code class="param">lhs</code> such that <code>p.rules[i + 1]</code> equals <code class="param">rhs</code>; or <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a> if there is not such rule</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhs</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhs</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the rule or <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its argument. In particular, it does not check that <code class="param">p</code> is properly defined, namely that the length of <code>p.rules</code> is even. If the rule we are trying to find is not in <code>p.rules</code>, then bad things might happen. </dd></dl>

</div>
</div>
<a id="aea86d4fd7797f11bc5f2d403b93d9715" name="aea86d4fd7797f11bc5f2d403b93d9715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea86d4fd7797f11bc5f2d403b93d9715">&#9670;&#160;</a></span>is_normalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_normalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns <code>true</code> if the <a class="el" href="classlibsemigroups_1_1_presentation.html#ac21a91e92a664a0ac48d99643f62fd6a">alphabet</a> of <code class="param">p</code> is <code>0</code> to <code>p.alphabet().size() - 1</code> and <code>false</code> otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the presentation <code class="param">p</code> is normalized.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aec9bdbe4253a0acb561e92260d733b43">throw_if_not_normalized</a>. </dd></dl>

</div>
</div>
<a id="a5ac7aa06b21ac9b745d6f6d307ffbab1" name="a5ac7aa06b21ac9b745d6f6d307ffbab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac7aa06b21ac9b745d6f6d307ffbab1">&#9670;&#160;</a></span>is_rule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns <code>true</code> if <code class="param">lhs</code> and <code class="param">rhs</code> form a rule in <code class="param">p</code>. That is if <code class="param">lhs</code> occurs in an even index position in <code>p.rules</code> and <code class="param">rhs</code> is the next item in <code>p.rules</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhs</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhs</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not <code class="param">lhs</code> and <code class="param">rhs</code> form a rule in <code class="param">p</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.throw_if_bad_alphabet_or_rules()</code> throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0de5951def57124c2c4972d026c19da" name="ab0de5951def57124c2c4972d026c19da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0de5951def57124c2c4972d026c19da">&#9670;&#160;</a></span>is_rule_no_checks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_rule_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns <code>true</code> if <code class="param">lhs</code> and <code class="param">rhs</code> form a rule in <code class="param">p</code>. That is if <code class="param">lhs</code> occurs in an even index position in <code>p.rules</code> and <code class="param">rhs</code> is the next item in <code>p.rules</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhs</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhs</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not <code class="param">lhs</code> and <code class="param">rhs</code> form a rule in <code class="param">p</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does no checks on its argument. In particular, it does not check that <code class="param">p</code> is properly defined, namely that the length of <code>p.rules</code> is even. If the rule we are trying to find is not in <code>p.rules</code>, then bad things might happen. </dd></dl>

</div>
</div>
<a id="ad503a8cc1838501f3b2b26bbb3fe78ee" name="ad503a8cc1838501f3b2b26bbb3fe78ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad503a8cc1838501f3b2b26bbb3fe78ee">&#9670;&#160;</a></span>is_strongly_compressible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_strongly_compressible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A \(1\)-relation presentation is <em>strongly compressible</em> if both relation words start with the same letter and end with the same letter. In other words, if the alphabet of the presentation <code class="param">p</code> is \(A\) and the relation words are of the form \(aub = avb\) where \(a, b\in A\) (possibly \( a = b\)) and \(u, v\in A ^ *\), then <code class="param">p</code> is strongly compressible. See section 3.2 of <a class="el" href="citelist.html#CITEREF_nybergbrodda2021aa">[52]</a> for details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="#aafe7deda5b5f239dfca3054c32de9da3">strongly_compress</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adc4f0c313d39e8062e1efd4c23be2c48" name="adc4f0c313d39e8062e1efd4c23be2c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4f0c313d39e8062e1efd4c23be2c48">&#9670;&#160;</a></span>length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t length </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the sum of the lengths of all values in the range <code>[first, last)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the first and second arguments (iterators). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing at the first value to calculate the length of. </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing one beyond the last value to calculate the length of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>size_t</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="ab497e1912b31da8d098193daff8d05c7" name="ab497e1912b31da8d098193daff8d05c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab497e1912b31da8d098193daff8d05c7">&#9670;&#160;</a></span>length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the sum of the lengths of the rules of <code class="param">p</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>size_t</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="a22d1cde375c344f2883be80622cdab80" name="a22d1cde375c344f2883be80622cdab80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d1cde375c344f2883be80622cdab80">&#9670;&#160;</a></span>longest_rule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator longest_rule </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator pointing at the left-hand side of the first rule of maximal length in the given range.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>left-hand side of the first rule. </td></tr>
    <tr><td class="paramname">last</td><td>one past the right-hand side of the last rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Iterator</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the distance between <code class="param">first</code> and <code class="param">last</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a905af2e4e6bc2d4e0d565fecb167060f" name="a905af2e4e6bc2d4e0d565fecb167060f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905af2e4e6bc2d4e0d565fecb167060f">&#9670;&#160;</a></span>longest_rule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::const_iterator longest_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator pointing at the left-hand side of the first rule in the presentation with maximal length.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;Word&gt;::const_iterator</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the length of <code class="param">p.rules</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0af54c090bb9f81f86d1e834fbdbc842" name="a0af54c090bb9f81f86d1e834fbdbc842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af54c090bb9f81f86d1e834fbdbc842">&#9670;&#160;</a></span>longest_rule_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator::value_type::size_type longest_rule_length </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum length of a rule in the given range.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>left-hand side of the first rule. </td></tr>
    <tr><td class="paramname">last</td><td>one past the right-hand side of the last rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Iterator::value_type::size_type</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the length of <code class="param">p.rules</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dd9114b812112f4ef7900267aace604" name="a7dd9114b812112f4ef7900267aace604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd9114b812112f4ef7900267aace604">&#9670;&#160;</a></span>longest_rule_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Word::size_type longest_rule_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum length of a rule in the presentation.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Word::size_type</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the length of <code class="param">p.rules</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57bd3357ca0f50a429df940ee4cdaa95" name="a57bd3357ca0f50a429df940ee4cdaa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bd3357ca0f50a429df940ee4cdaa95">&#9670;&#160;</a></span>longest_subword_reducing_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Word longest_subword_reducing_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If it is possible to find a subword \(w\) of the rules  \(u_1 = v_1,
\ldots, u_n = v_n\) such that the introduction of a new generator \(z\) and the relation \(z = w\) reduces the <code><a class="el" href="#adc4f0c313d39e8062e1efd4c23be2c48" title="Return the sum of the lengths of all values in the range [first, last).">presentation::length</a></code> of the presentation, then this function returns the longest such word \(w\). If no such word can be found, then a word of length \(0\) is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code class="param">Word</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="a9f71687ecca9e2782cf17f8d0dc9f439" name="a9f71687ecca9e2782cf17f8d0dc9f439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f71687ecca9e2782cf17f8d0dc9f439">&#9670;&#160;</a></span>make_semigroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> make_semigroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function modifies its argument in-place by replacing the empty word in all relations by a new generator, and the identity rules for that new generator. If <code>p.contains_empty_word()</code> is <code>false</code>, then the presentation is not modified and <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a> is returned. If a new generator is added as the identity, then this generator is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new generator added, if any, and <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a> if not.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>replace_word</code> or <code>add_identity_rules</code> does. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad88ee5f4b8c87466fb33283787fc98d" name="aad88ee5f4b8c87466fb33283787fc98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad88ee5f4b8c87466fb33283787fc98d">&#9670;&#160;</a></span>normalize_alphabet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void normalize_alphabet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modify the presentation in-place so that the alphabet is  \(\{0, \ldots,
n - 1\}\) (or equivalent) and rewrites the rules to use this alphabet.</p>
<p>If the alphabet is already normalized, then no changes are made to the presentation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <a class="el" href="classlibsemigroups_1_1_presentation.html#a198d5db68cd73451d94cb58d8f7603e6">throw_if_bad_alphabet_or_rules</a> throws on the initial presentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f82a21af1e0e278e66fd1aea2949faf" name="a9f82a21af1e0e278e66fd1aea2949faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f82a21af1e0e278e66fd1aea2949faf">&#9670;&#160;</a></span>reduce_complements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void reduce_complements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to reduce the length of the words by finding the equivalence relation on the relation words generated by the pairs of identical relation words. If \(\{u_1, u_2, \ldots, u_n\}\) are the distinct words in an equivalence class and \(u_1\) is the short-lex minimum word in the class, then the relation words are replaced by  \(u_1 =
u_2, u_1 = u_3, \cdots, u_1 = u_n\).</p>
<p>The rules may be reordered by this function even if there are no reductions found.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-deterministic; different results may be obtained when compiling with clang vs gcc </dd></dl>

</div>
</div>
<a id="a12eee0cff7880777dbc3bbba74de7bdf" name="a12eee0cff7880777dbc3bbba74de7bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12eee0cff7880777dbc3bbba74de7bdf">&#9670;&#160;</a></span>reduce_to_2_generators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool reduce_to_2_generators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reduce the number of generators in a \(1\)-relation presentation to <code>2</code>.</p>
<p>Returns <code>true</code> if the \(1\)-relation presentation <code class="param">p</code> has been modified and <code>false</code> if not.</p>
<p>A \(1\)-relation presentation is <em>left cycle-free</em> if the relation words start with distinct letters. In other words, if the alphabet of the presentation <code class="param">p</code> is \(A\) and the relation words are of the form \(au = bv\) where \(a, b\in A\) with \(a \neq b\) and \(u, v \in A ^ *\), then <code class="param">p</code> is left cycle-free. The word problem for a left cycle-free \(1\)-relation monoid is solvable if the word problem for the modified version obtained from this function is solvable.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">index</td><td>determines the choice of letter to use, <code>0</code> uses <code>p.rules[0].front()</code> and <code>1</code> uses <code>p.rules[1].front()</code> (defaults to: <code>0</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">index</code> is not <code>0</code> or <code>1</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaf820f4a3a95bb86f65ad2988e4ebe3" name="adaf820f4a3a95bb86f65ad2988e4ebe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf820f4a3a95bb86f65ad2988e4ebe3">&#9670;&#160;</a></span>remove_duplicate_rules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void remove_duplicate_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all but one instance of any duplicate rules (if any). Note that rules of the form \(u = v\) and \(v = u\) (if any) are considered duplicates. Also note that the rules may be reordered by this function even if there are no duplicate rules.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the number of rules. </dd></dl>

</div>
</div>
<a id="ac0eda9b2399fafdc35cf13a8abf71c76" name="ac0eda9b2399fafdc35cf13a8abf71c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0eda9b2399fafdc35cf13a8abf71c76">&#9670;&#160;</a></span>remove_redundant_generators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void remove_redundant_generators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If one side of any of the rules in the presentation <code class="param">p</code> is a letter <code>a</code> and the other side of the rule does not contain <code>a</code>, then this function replaces every occurrence of <code>a</code> in every rule by the other side of the rule. This substitution is performed for every such rule in the presentation; and the trivial rules (with both sides being identical) are removed. If both sides of a rule are letters, then the greater letter is replaced by the lesser one.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a784fe4c484d3c4fa97d9856f4d9363ec" name="a784fe4c484d3c4fa97d9856f4d9363ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784fe4c484d3c4fa97d9856f4d9363ec">&#9670;&#160;</a></span>remove_trivial_rules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void remove_trivial_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all instance of rules (if any) where the left-hand side and the right-hand side are identical.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the number of rules. </dd></dl>

</div>
</div>
<a id="a0c9446d7e75e55059446137dc90a5d85" name="a0c9446d7e75e55059446137dc90a5d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9446d7e75e55059446137dc90a5d85">&#9670;&#160;</a></span>replace_subword() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void replace_subword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>existing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function replaces every non-overlapping instance of <code class="param">existing</code> in every rule by <code class="param">replacement</code>. The presentation <code class="param">p</code> is changed in-place.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">existing</td><td>the word to be replaced. </td></tr>
    <tr><td class="paramname">replacement</td><td>the replacement word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>existing</code> is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e339b2779d8b2d1d40fafa4428e9513" name="a5e339b2779d8b2d1d40fafa4428e9513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e339b2779d8b2d1d40fafa4428e9513">&#9670;&#160;</a></span>replace_subword() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Iterator1, typename Iterator2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void replace_subword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1</td>          <td class="paramname"><span class="paramname"><em>first_existing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1</td>          <td class="paramname"><span class="paramname"><em>last_existing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator2</td>          <td class="paramname"><span class="paramname"><em>first_replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator2</td>          <td class="paramname"><span class="paramname"><em>last_replacement</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces every non-overlapping instance of <code>[first_existing, last_existing)</code> in every rule by <code>[first_replacement, last_replacement)</code>. The presentation <code class="param">p</code> is changed in-place</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator1</td><td>the type of the first two parameters (iterators, or pointers). </td></tr>
    <tr><td class="paramname">Iterator2</td><td>the type of the second two parameters (iterators, or pointers).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">first_existing</td><td>an iterator pointing to the first letter of the existing subword to be replaced. </td></tr>
    <tr><td class="paramname">last_existing</td><td>an iterator pointing one past the last letter of the existing subword to be replaced. </td></tr>
    <tr><td class="paramname">first_replacement</td><td>an iterator pointing to the first letter of the replacement word. </td></tr>
    <tr><td class="paramname">last_replacement</td><td>an iterator pointing one past the last letter of the replacement word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>first_existing == last_existing</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92bd68d064a46c7b477e11bc4c1f8667" name="a92bd68d064a46c7b477e11bc4c1f8667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bd68d064a46c7b477e11bc4c1f8667">&#9670;&#160;</a></span>replace_subword() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void replace_subword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>existing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code class="param">existing</code> and <code class="param">replacement</code> are words, then this function replaces every non-overlapping instance of <code class="param">existing</code> in every rule by <code class="param">replacement</code>. The presentation <code class="param">p</code> is changed in-place.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">existing</td><td>the word to be replaced. </td></tr>
    <tr><td class="paramname">replacement</td><td>the replacement word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>existing</code> is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a28e29e9dcad2b9d48e1558cc1bb920" name="a8a28e29e9dcad2b9d48e1558cc1bb920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a28e29e9dcad2b9d48e1558cc1bb920">&#9670;&#160;</a></span>replace_word()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void replace_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>existing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code class="param">existing</code> and <code class="param">replacement</code> are words, then this function replaces every instance of <code class="param">existing</code> in every rule of the form <code class="param">existing</code> \(= w\) or \(w = \) <code class="param">existing</code>, with the word <code class="param">replacement</code>. The presentation <code class="param">p</code> is changed in-place.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">existing</td><td>the word to be replaced. </td></tr>
    <tr><td class="paramname">replacement</td><td>the replacement word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="a265744c7f98fbbd671d496386bbc8e98" name="a265744c7f98fbbd671d496386bbc8e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265744c7f98fbbd671d496386bbc8e98">&#9670;&#160;</a></span>replace_word_with_new_generator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> replace_word_with_new_generator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If \(w=\)<code>[first, last)</code> is a word, then replaces every non-overlapping instance (from left to right) of \(w\) in every rule, adds a new generator \(z\), and the rule \(w = z\). The new generator and rule are added even if \(w\) is not a subword of any rule.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">w</td><td>the subword to replace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new generator added.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">w</code> is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ed818a30289cea069ce8196809a8675" name="a0ed818a30289cea069ce8196809a8675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed818a30289cea069ce8196809a8675">&#9670;&#160;</a></span>replace_word_with_new_generator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> replace_word_with_new_generator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If \(w=\)<code>[first, last)</code> is a word, then this function replaces every non-overlapping instance of \(w\) in every rule, adds a new generator \(z\), and the rule \(w = z\). The new generator and rule are added even if \(w\) is not a subword of any rule.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Iterator</td><td>the type of the 2nd and 3rd parameters (iterators). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">first</td><td>the start of the subword to replace. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the end of the subword to replace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>first == last</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada89238bda7b8f989fdf2fffcb86418e" name="ada89238bda7b8f989fdf2fffcb86418e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada89238bda7b8f989fdf2fffcb86418e">&#9670;&#160;</a></span>replace_word_with_new_generator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> replace_word_with_new_generator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function replaces every non-overlapping instance (from left to right) of <code class="param">w</code> in every rule, adds a new generator \(z\), and the rule \(w = z\). The new generator and rule are added even if <code class="param">w</code> is not a subword of any rule.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">w</td><td>the subword to replace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new generator added.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">w</code> is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09297ced05d3a33849423c06d9285624" name="a09297ced05d3a33849423c06d9285624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09297ced05d3a33849423c06d9285624">&#9670;&#160;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;&amp; reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverse every rule.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>an rvalue reference for a presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An rvalue reference to the reversed presentation.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="a4273c14477b26904fa81aebb11f33ec9" name="a4273c14477b26904fa81aebb11f33ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4273c14477b26904fa81aebb11f33ec9">&#9670;&#160;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverse every rule.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="a65069c045453edf6cc59c6c2fbe65343" name="a65069c045453edf6cc59c6c2fbe65343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65069c045453edf6cc59c6c2fbe65343">&#9670;&#160;</a></span>shortest_rule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator shortest_rule </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator pointing at the left-hand side of the first rule of minimal length in the given range.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>left-hand side of the first rule. </td></tr>
    <tr><td class="paramname">last</td><td>one past the right-hand side of the last rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Iterator</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the distance between <code class="param">first</code> and <code class="param">last</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0923abe23bd54ef423419b7f11933903" name="a0923abe23bd54ef423419b7f11933903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0923abe23bd54ef423419b7f11933903">&#9670;&#160;</a></span>shortest_rule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::const_iterator shortest_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator pointing at the left-hand side of the first rule in the presentation with minimal length.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;Word&gt;::const_iterator</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the length of <code class="param">p.rules</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74635d388ce178f7b69d5c851bc8b93f" name="a74635d388ce178f7b69d5c851bc8b93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74635d388ce178f7b69d5c851bc8b93f">&#9670;&#160;</a></span>shortest_rule_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator::value_type::size_type shortest_rule_length </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minimum length of a rule in the given range.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>left-hand side of the first rule. </td></tr>
    <tr><td class="paramname">last</td><td>one past the right-hand side of the last rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Iterator::value_type::size_type</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the length of <code class="param">p.rules</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a482393ea90410b720e40969ea90f70ad" name="a482393ea90410b720e40969ea90f70ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482393ea90410b720e40969ea90f70ad">&#9670;&#160;</a></span>shortest_rule_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Word::size_type shortest_rule_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minimum length of a rule in the presentation.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Word::size_type</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the length of <code class="param">p.rules</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59966c2bf07eb98721dfe506e3c03e4e" name="a59966c2bf07eb98721dfe506e3c03e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59966c2bf07eb98721dfe506e3c03e4e">&#9670;&#160;</a></span>sort_each_rule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sort_each_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort each rule \(u = v\) so that the left-hand side is shortlex greater than the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation whose rules should be sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the number of rules. </dd></dl>

</div>
</div>
<a id="a2a74fc9f1cf7a0fbc165106c1b3931a1" name="a2a74fc9f1cf7a0fbc165106c1b3931a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a74fc9f1cf7a0fbc165106c1b3931a1">&#9670;&#160;</a></span>sort_each_rule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sort_each_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>cmp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort each rule \(u = v\) so that the left-hand side is greater than the right-hand side with respect to <code class="param">cmp</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Compare</td><td>the type of the compare function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation whose rules should be sorted. </td></tr>
    <tr><td class="paramname">cmp</td><td>the comparison function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the number of rules. </dd></dl>

</div>
</div>
<a id="ada2524c6337ced966c9b1001c768c7d5" name="ada2524c6337ced966c9b1001c768c7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2524c6337ced966c9b1001c768c7d5">&#9670;&#160;</a></span>sort_rules() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sort_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the rules \(u_1 = v_1, \ldots, u_n = v_n\) so that \(u_1v_1 &lt; \cdots &lt; u_nv_n\) where \(&lt;\) is the shortlex order.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to sort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91480c6d87296d5586c1e17df0d0d437" name="a91480c6d87296d5586c1e17df0d0d437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91480c6d87296d5586c1e17df0d0d437">&#9670;&#160;</a></span>sort_rules() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sort_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>cmp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the rules \(u_1 = v_1, \ldots, u_n = v_n\) so that \(u_1v_1 &lt; \cdots &lt; u_nv_n\) where \(&lt;\) is the order defined by <code class="param">cmp</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Compare</td><td>the type of the compare function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to sort. </td></tr>
    <tr><td class="paramname">cmp</td><td>the comparison function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafe7deda5b5f239dfca3054c32de9da3" name="aafe7deda5b5f239dfca3054c32de9da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe7deda5b5f239dfca3054c32de9da3">&#9670;&#160;</a></span>strongly_compress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool strongly_compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Strongly compress a \(1\)-relation presentation.</p>
<p>Returns <code>true</code> if the \(1\)-relation presentation <code class="param">p</code> has been modified and <code>false</code> if not. The word problem is solvable for the input presentation if it is solvable for the modified version.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="#ad503a8cc1838501f3b2b26bbb3fe78ee">is_strongly_compressible</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a56dca3de75b7b21cef075378282bc980" name="a56dca3de75b7b21cef075378282bc980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56dca3de75b7b21cef075378282bc980">&#9670;&#160;</a></span>throw_if_bad_inverses() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word1, typename Word2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throw_if_bad_inverses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word1 &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word2 const &amp;</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks if the values in <code class="param">inverses</code> are valid semigroup inverses for <code>p.alphabet()</code>. Specifically, it checks that the \(i\)th value in <code class="param">inverses</code> is an inverse for the \(i\)th value in <code>p.alphabet()</code>.</p>
<p>Let \(x_i\) be the \(i\)th letter in <code>p.alphabet()</code>, and let \(y_i\) be the \(i\)th letter in <code class="param">inverses</code>. Then this function checks that:</p><ul>
<li><code>p.alphabet()</code> and <code class="param">inverses</code> contain the same letters;</li>
<li><code class="param">inverses</code> are duplicate-free;</li>
<li>if \(x_i = y_j\), then \(x_j = y_i\) and therefore that \((x_i^{-1})^{-1} = x_i\).</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word1</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Word2</td><td>the type of the arguments <code class="param">letters</code> and <code class="param">inverses</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">inverses</td><td>the proposed inverses for <code class="param">letters</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Libsemigroups_Exception</td><td>if any of the conditions listed above do not hold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13bc3c09c460643fd40c6fdb89574950" name="a13bc3c09c460643fd40c6fdb89574950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bc3c09c460643fd40c6fdb89574950">&#9670;&#160;</a></span>throw_if_bad_inverses() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word1, typename Word2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throw_if_bad_inverses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word1 &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word2 const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word2 const &amp;</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks if the values in <code class="param">inverses</code> are valid semigroup inverses for <code class="param">letters</code>. Specifically, it checks that the \(i\)th value in <code class="param">inverses</code> is an inverse for the \(i\)th value in <code>letters</code>.</p>
<p>Let \(x_i\) be the \(i\)th letter in <code class="param">letters</code>, and let \(y_i\) be the \(i\)th letter in <code class="param">inverses</code>. Then this function checks that:</p><ul>
<li><code class="param">letters</code> and <code class="param">inverses</code> contain the same letters;</li>
<li><code class="param">letters</code> and <code class="param">inverses</code> are duplicate-free;</li>
<li>if \(x_i = y_j\), then \(x_j = y_i\) and therefore that \((x_i^{-1})^{-1} = x_i\).</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word1</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Word2</td><td>the type of the arguments <code class="param">letters</code> and <code class="param">inverses</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">letters</td><td>the letters in the alphabet. </td></tr>
    <tr><td class="paramname">inverses</td><td>the proposed inverses for <code class="param">letters</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Libsemigroups_Exception</td><td>if any of the conditions listed above do not hold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8be80ecb20d06625ecc638dc103bd5dd" name="a8be80ecb20d06625ecc638dc103bd5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be80ecb20d06625ecc638dc103bd5dd">&#9670;&#160;</a></span>throw_if_bad_rules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throw_if_bad_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if every rule of in <code>[first, last)</code> consists of letters belonging to the alphabet of <code class="param">p</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Iterator</td><td>the type of the second and third arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation whose alphabet is being checked against. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing at the first rule to check. </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing one beyond the last rule to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if any word contains a letter not in <code>p.alphabet()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Worst case \(O(mnt)\) where \(m\) is the length of the longest word, \(n\) is the size of the <code class="param">p</code> 's alphabet and \(t\) is the distance between <code class="param">first</code> and <code class="param">last</code>. </dd></dl>

</div>
</div>
<a id="aec9bdbe4253a0acb561e92260d733b43" name="aec9bdbe4253a0acb561e92260d733b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9bdbe4253a0acb561e92260d733b43">&#9670;&#160;</a></span>throw_if_not_normalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throw_if_not_normalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>arg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;1st&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function throws a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a> if the <a class="el" href="classlibsemigroups_1_1_presentation.html#ac21a91e92a664a0ac48d99643f62fd6a">alphabet</a> of <code class="param">p</code> is not <code>0</code> to <code>p.alphabet().size() - 1</code>.</p>
<p>The second parameter <code class="param">arg</code> is used in the formatting of the exception message to specify which parameter the presentation <code class="param">p</code> corresponds to in the calling function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to check. </td></tr>
    <tr><td class="paramname">arg</td><td>the position of <code class="param">p</code> in calling function's argument list (defaults to <code>"1st"</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the alphabet of <code class="param">p</code> is not <code>0</code> to <code>p.alphabet.size()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea86d4fd7797f11bc5f2d403b93d9715">is_normalized</a>. </dd></dl>

</div>
</div>
<a id="a371053f8f212083c6af099cabdf33b68" name="a371053f8f212083c6af099cabdf33b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371053f8f212083c6af099cabdf33b68">&#9670;&#160;</a></span>throw_if_odd_number_of_rules() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throw_if_odd_number_of_rules </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function throws an exception if the distance between <code class="param">first</code> and <code class="param">last</code> is not an even number.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing at the first words. </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing one beyond the last word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the distance from <code class="param">first</code> to <code class="param">last</code> is not even. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a191d5ec2c8a3d1e819818e273149151f" name="a191d5ec2c8a3d1e819818e273149151f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191d5ec2c8a3d1e819818e273149151f">&#9670;&#160;</a></span>throw_if_odd_number_of_rules() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throw_if_odd_number_of_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function throws an exception if number of words in <code>p.rules</code> is odd.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the <a class="el" href="classlibsemigroups_1_1_presentation.html" title="For an implementation of presentations for semigroups or monoids.">Presentation</a> <code class="param">p</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the number of words in <code>p.rules</code> is not even. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1569bd727eb77cb388ea564b0da00a84" name="a1569bd727eb77cb388ea564b0da00a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1569bd727eb77cb388ea564b0da00a84">&#9670;&#160;</a></span>to_gap_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> to_gap_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>var_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the string of GAP code that could be used to create an object with the same alphabet and rules as <code class="param">p</code> in GAP. Presentations in GAP are created by taking quotients of free semigroups or monoids.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">var_name</td><td>the name of the variable to be used in GAP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">has</code> more than 49 generators. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaa78f3583eccd084393f466b5615a7e" name="afaa78f3583eccd084393f466b5615a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa78f3583eccd084393f466b5615a7e">&#9670;&#160;</a></span>to_gap_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> to_gap_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>var_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the string of GAP code that could be used to create an object with the same alphabet and rules as <code class="param">p</code> in GAP. Presentations in GAP are created by taking quotients of free semigroups or monoids.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">var_name</td><td>the name of the variable to be used in GAP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">has</code> more than 49 generators. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcb72dbbefb9e5d5c7b33d7faeb19420" name="adcb72dbbefb9e5d5c7b33d7faeb19420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb72dbbefb9e5d5c7b33d7faeb19420">&#9670;&#160;</a></span>to_report_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> to_report_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a representation of a presentation that will appear in the reporting output. The information that is provided is:</p><ul>
<li>the size of the alphabet (<code>|A|</code>);</li>
<li>the number of rules (<code>|R|</code>);</li>
<li>the range of values of the lengths of the rules (<code>|u| + |v|</code>); and</li>
<li>the sum of the lengths of the rules (<code>∑(|u| + |v|)</code>).</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code hl_class" href="classlibsemigroups_1_1_presentation.html">Presentation&lt;std::string&gt;</a> p;</div>
<div class="line"><a class="code hl_function" href="#adcb72dbbefb9e5d5c7b33d7faeb19420">presentation::to_report_string</a>(p)</div>
<div class="line"><span class="comment">// &quot;|A| = 0, |R| = 0, |u| + |v| ∈ [0, 0], ∑(|u| + |v|) = 0&quot;</span></div>
<div class="ttc" id="aclasslibsemigroups_1_1_presentation_html"><div class="ttname"><a href="classlibsemigroups_1_1_presentation.html">libsemigroups::Presentation</a></div><div class="ttdoc">For an implementation of presentations for semigroups or monoids.</div><div class="ttdef"><b>Definition</b> presentation.hpp:103</div></div>
<div class="ttc" id="anamespacelibsemigroups_1_1presentation_html_adcb72dbbefb9e5d5c7b33d7faeb19420"><div class="ttname"><a href="#adcb72dbbefb9e5d5c7b33d7faeb19420">libsemigroups::presentation::to_report_string</a></div><div class="ttdeci">std::string to_report_string(Presentation&lt; Word &gt; const &amp;p)</div><div class="ttdoc">Return a representation of a presentation to appear in the reporting output.</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a39cb8e99df6d12b0b299f07df4bd692e" name="a39cb8e99df6d12b0b299f07df4bd692e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cb8e99df6d12b0b299f07df4bd692e">&#9670;&#160;</a></span>try_detect_inverses() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; Word, Word &gt; try_detect_inverses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function constructs two <code>Word</code> objects to store the letters and inverses, performs <a class="el" href="#a1acdedd5ef354d2aea6316d2762b2592">try_detect_inverses(Presentation&lt;Word&gt;&amp;, Word&amp;, Word&amp;)</a> and then returns the result <code>pair</code> as a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a> where:</p>
<ul>
<li><code>pair.first</code> is the list of letters such that an inverse was detected;</li>
<li><code>pair.second</code> is the list of inverses of the letters in <code>pair.first</code> (where the letter in position <code>i</code> is the inverse of <code>pair.first[i]</code>, and vice versa).</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <a class="el" href="classlibsemigroups_1_1_presentation.html#a198d5db68cd73451d94cb58d8f7603e6">throw_if_bad_alphabet_or_rules</a> throws. </td></tr>
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if conflicting inverses for any letter are detected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1acdedd5ef354d2aea6316d2762b2592" name="a1acdedd5ef354d2aea6316d2762b2592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acdedd5ef354d2aea6316d2762b2592">&#9670;&#160;</a></span>try_detect_inverses() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void try_detect_inverses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word &amp;</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function tries to deduce group theoretic inverses defined by the rules of the presentation <code class="param">p</code> as following: the rules of the presentation where one side has length 2 and the other has length 0 are detected. For any such rule we remember that the first letter is a possible inverse of the second. If rules of the form <code>ab=1</code> and <code>ba=1</code> are detected, then <code>a</code> has inverse <code>b</code> and vice versa. If there are multiple different such rules and we deduce conflicting values for the inverse of a letter, then an exception is thrown.</p>
<p>Those letters where an inverse is detected are pushed into the back of the parameter <code class="param">letters</code>, and the detected inverse is pushed into <code class="param">inverses</code>. The parameters <code class="param">letters</code> and <code class="param">inverses</code> are modified in-place, and are not cleared before adding letters or their inverses.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">letters</td><td>the word to contain the letters with inverses. </td></tr>
    <tr><td class="paramname">inverses</td><td>the word to contain the inverses found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <a class="el" href="classlibsemigroups_1_1_presentation.html#a198d5db68cd73451d94cb58d8f7603e6">throw_if_bad_alphabet_or_rules</a> throws. </td></tr>
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if conflicting inverses for any letter are detected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelibsemigroups.html">libsemigroups</a></li><li class="navelem"><a class="el" href="namespacelibsemigroups_1_1presentation.html">presentation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
