<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- BEGIN opengraph metadata -->
    <meta property="og:title" content="libsemigroups" />
    <meta property="og:image" content="libsemi_logo.jpeg" />
    <meta
      property="og:description"
      content="C++ library for semigroups and monoids."
    />
    <meta
      property="og:url"
      content="https://github.com/libsemigroups/libsemigroups"
    />
    <!-- END opengraph metadata -->
<title>libsemigroups: libsemigroups::presentation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="libsemi_logo.jpeg"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/libsemigroups/libsemigroups" class="github-corner" title="View source on GitHub" target="_blank" rel="noopener noreferrer">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libsemi_logo.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsemigroups
   &#160;<span id="projectnumber">v3.0.0</span>
   </div>
   <div id="projectbrief">C++ library for semigroups and monoids</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="_HEADING_"><span>Installation&#160;and&#160;Changelog</span></a></li>
      <li><a href="md_install.html"><span>Install</span></a></li>
      <li><a href="_HEADING_"><span>Data&#160;structures</span></a></li>
      <li><a href="group__adapters__group.html"><span>Adapters</span></a></li>
      <li><a href="group__elements__group.html"><span>Elements</span></a></li>
      <li><a href="group__misc__group.html"><span>Miscellaneous</span></a></li>
      <li><a href="group__orders__group.html"><span>Orders</span></a></li>
      <li><a href="group__presentations__group.html"><span>Presentations</span></a></li>
      <li><a href="group__ranges__group.html"><span>Ranges</span></a></li>
      <li><a href="group__ukkonen__group.html"><span>Suffix&#160;trees</span></a></li>
      <li><a href="group__aho__corasick__group.html"><span>Tries</span></a></li>
      <li><a href="group__make__group.html"><span>The&#160;`make`&#160;function</span></a></li>
      <li><a href="group__to__group.html"><span>The&#160;`to`&#160;function</span></a></li>
      <li><a href="group__dot__group.html"><span>Visualisation</span></a></li>
      <li><a href="group__word__graph__group.html"><span>Word&#160;graphs</span></a></li>
      <li><a href="group__words__group.html"><span>Words</span></a></li>
      <li><a href="_HEADING_"><span>Main&#160;Algorithms</span></a></li>
      <li><a href="group__action__group.html"><span>Actions</span></a></li>
      <li><a href="group__cong__common__helpers__group.html"><span>Common&#160;congruence&#160;helper&#160;function</span></a></li>
      <li><a href="group__congruence__group.html"><span>Congruence</span></a></li>
      <li><a href="group__froidure__pin__group.html"><span>Froidure-Pin</span></a></li>
      <li><a href="group__kambites__group.html"><span>Kambites</span></a></li>
      <li><a href="group__knuth__bendix__group.html"><span>Knuth-Bendix</span></a></li>
      <li><a href="group__freeband__group.html"><span>Radoszewski-Rytter</span></a></li>
      <li><a href="group__schreier__sims__group.html"><span>Schreier-Sims</span></a></li>
      <li><a href="group__sims__group.html"><span>Low&#160;Index&#160;Congruences</span></a></li>
      <li><a href="group__stephen__group.html"><span>Stephen</span></a></li>
      <li><a href="group__todd__coxeter__group.html"><span>Todd-Coxeter</span></a></li>
      <li><a href="_HEADING_"><span>Bibliography</span></a></li>
      <li><a href="citelist.html"><span>Bibliography</span></a></li>
      <li><a href="_HEADING_"><span>Further&#160;info</span></a></li>
      <li><a href="https://github.com/libsemigroups/libsemigroups"><span>GitHub</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacelibsemigroups_1_1presentation.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">libsemigroups::presentation Namespace Reference<div class="ingroups"><a class="el" href="group__presentations__group.html">Presentations</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a>
<div class="textblock"><p>Defined in <code><a class="el" href="presentation_8hpp_source.html">presentation.hpp</a></code>.</p>
<p>This namespace contains various helper functions for the class <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>. These functions could be functions of <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a> but they only use public member functions of <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>, and so they are declared as free functions instead. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibsemigroups_1_1presentation_1_1examples.html">examples</a></td></tr>
<tr class="memdesc:namespacelibsemigroups_1_1presentation_1_1examples"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for presentations of some finitely presented semigroups. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aba4fd25074207d63e51e2c74b18ec05d" id="r_aba4fd25074207d63e51e2c74b18ec05d"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:aba4fd25074207d63e51e2c74b18ec05d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba4fd25074207d63e51e2c74b18ec05d">add_commutes_rules_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;letters)</td></tr>
<tr class="memdesc:aba4fd25074207d63e51e2c74b18ec05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules so specific letters commute.  <br /></td></tr>
<tr class="separator:aba4fd25074207d63e51e2c74b18ec05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd301c9aa6299cd6e9863934f3afb26" id="r_adcd301c9aa6299cd6e9863934f3afb26"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:adcd301c9aa6299cd6e9863934f3afb26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adcd301c9aa6299cd6e9863934f3afb26">add_commutes_rules_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;letters, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Word &gt; words)</td></tr>
<tr class="memdesc:adcd301c9aa6299cd6e9863934f3afb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules so specific letters commute with specific words.  <br /></td></tr>
<tr class="separator:adcd301c9aa6299cd6e9863934f3afb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d04d59da745faf2e6a1c981857c090e" id="r_a0d04d59da745faf2e6a1c981857c090e"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a0d04d59da745faf2e6a1c981857c090e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d04d59da745faf2e6a1c981857c090e">add_commutes_rules_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;letters1, Word const &amp;letters2)</td></tr>
<tr class="memdesc:a0d04d59da745faf2e6a1c981857c090e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules so specific letters commute.  <br /></td></tr>
<tr class="separator:a0d04d59da745faf2e6a1c981857c090e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204d70a297be8f67ca41b28d501b2746" id="r_a204d70a297be8f67ca41b28d501b2746"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a204d70a297be8f67ca41b28d501b2746"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a204d70a297be8f67ca41b28d501b2746">add_idempotent_rules_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;letters)</td></tr>
<tr class="memdesc:a204d70a297be8f67ca41b28d501b2746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules that define each letter as an idempotent.  <br /></td></tr>
<tr class="separator:a204d70a297be8f67ca41b28d501b2746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97116b13ea4b20d65dee405f311f42d0" id="r_a97116b13ea4b20d65dee405f311f42d0"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a97116b13ea4b20d65dee405f311f42d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97116b13ea4b20d65dee405f311f42d0">add_identity_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, typename <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> e)</td></tr>
<tr class="memdesc:a97116b13ea4b20d65dee405f311f42d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules for an identity element.  <br /></td></tr>
<tr class="separator:a97116b13ea4b20d65dee405f311f42d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ab32292d024ec04ad3abd9fd715fc3" id="r_ab8ab32292d024ec04ad3abd9fd715fc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8ab32292d024ec04ad3abd9fd715fc3">add_inverse_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *vals, char e=<a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a>)</td></tr>
<tr class="memdesc:ab8ab32292d024ec04ad3abd9fd715fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules for inverses.  <br /></td></tr>
<tr class="separator:ab8ab32292d024ec04ad3abd9fd715fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39a6ad8b9694fb7e1ea3dc518a8cde6" id="r_ad39a6ad8b9694fb7e1ea3dc518a8cde6"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ad39a6ad8b9694fb7e1ea3dc518a8cde6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad39a6ad8b9694fb7e1ea3dc518a8cde6">add_inverse_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;vals, typename <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> e=<a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a>)</td></tr>
<tr class="memdesc:ad39a6ad8b9694fb7e1ea3dc518a8cde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules for inverses.  <br /></td></tr>
<tr class="separator:ad39a6ad8b9694fb7e1ea3dc518a8cde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3549f72bc6f99a31439bb28c136262ef" id="r_a3549f72bc6f99a31439bb28c136262ef"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a3549f72bc6f99a31439bb28c136262ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3549f72bc6f99a31439bb28c136262ef">add_involution_rules_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;letters)</td></tr>
<tr class="memdesc:a3549f72bc6f99a31439bb28c136262ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules that define involution.  <br /></td></tr>
<tr class="separator:a3549f72bc6f99a31439bb28c136262ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47828c9c3a9a232a6e2716903f2202b" id="r_ab47828c9c3a9a232a6e2716903f2202b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab47828c9c3a9a232a6e2716903f2202b">add_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *lhop, char const *rhop)</td></tr>
<tr class="memdesc:ab47828c9c3a9a232a6e2716903f2202b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>char const*</code>.  <br /></td></tr>
<tr class="separator:ab47828c9c3a9a232a6e2716903f2202b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443507ef9ef8ffb631493b3a034db200" id="r_a443507ef9ef8ffb631493b3a034db200"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a443507ef9ef8ffb631493b3a034db200">add_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *lhop, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;rhop)</td></tr>
<tr class="memdesc:a443507ef9ef8ffb631493b3a034db200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>char const*</code> and <code>string const ! &amp;</code>.  <br /></td></tr>
<tr class="separator:a443507ef9ef8ffb631493b3a034db200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a321dd3335d2239b8e9b49efd83f18" id="r_a78a321dd3335d2239b8e9b49efd83f18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78a321dd3335d2239b8e9b49efd83f18">add_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;lhop, char const *rhop)</td></tr>
<tr class="memdesc:a78a321dd3335d2239b8e9b49efd83f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>string const &amp;</code> and <code>char ! const*</code>.  <br /></td></tr>
<tr class="separator:a78a321dd3335d2239b8e9b49efd83f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec13b8a8bd3e87b579d949f56900f356" id="r_aec13b8a8bd3e87b579d949f56900f356"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Letter&gt; </td></tr>
<tr class="memitem:aec13b8a8bd3e87b579d949f56900f356"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec13b8a8bd3e87b579d949f56900f356">add_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt; lhop, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt; rhop)</td></tr>
<tr class="memdesc:aec13b8a8bd3e87b579d949f56900f356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>initializer_list</code>.  <br /></td></tr>
<tr class="separator:aec13b8a8bd3e87b579d949f56900f356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec80128d3c2e4b7cbf276731e0edfe56" id="r_aec80128d3c2e4b7cbf276731e0edfe56"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:aec80128d3c2e4b7cbf276731e0edfe56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec80128d3c2e4b7cbf276731e0edfe56">add_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;lhop, Word const &amp;rhop)</td></tr>
<tr class="memdesc:aec80128d3c2e4b7cbf276731e0edfe56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by reference and check.  <br /></td></tr>
<tr class="separator:aec80128d3c2e4b7cbf276731e0edfe56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a95e25c9bd84f930b71a116861a8ef" id="r_a11a95e25c9bd84f930b71a116861a8ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11a95e25c9bd84f930b71a116861a8ef">add_rule_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *lhop, char const *rhop)</td></tr>
<tr class="memdesc:a11a95e25c9bd84f930b71a116861a8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>char const*</code>.  <br /></td></tr>
<tr class="separator:a11a95e25c9bd84f930b71a116861a8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e7525ceaf1c1f72f323716c69e405a" id="r_ac4e7525ceaf1c1f72f323716c69e405a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4e7525ceaf1c1f72f323716c69e405a">add_rule_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *lhop, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;rhop)</td></tr>
<tr class="memdesc:ac4e7525ceaf1c1f72f323716c69e405a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>char const*</code> and <code>string ! const&amp;</code>.  <br /></td></tr>
<tr class="separator:ac4e7525ceaf1c1f72f323716c69e405a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237fa07d38a2a86ee30ccb661fd29d8c" id="r_a237fa07d38a2a86ee30ccb661fd29d8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a237fa07d38a2a86ee30ccb661fd29d8c">add_rule_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;lhop, char const *rhop)</td></tr>
<tr class="memdesc:a237fa07d38a2a86ee30ccb661fd29d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>string const&amp;</code> and <code>char ! const*</code>.  <br /></td></tr>
<tr class="separator:a237fa07d38a2a86ee30ccb661fd29d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b810cd98d27ace7d93fb9571431b5d" id="r_a54b810cd98d27ace7d93fb9571431b5d"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Letter&gt; </td></tr>
<tr class="memitem:a54b810cd98d27ace7d93fb9571431b5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a54b810cd98d27ace7d93fb9571431b5d">add_rule_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt; lhop, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt; rhop)</td></tr>
<tr class="memdesc:a54b810cd98d27ace7d93fb9571431b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by <code>initializer_list</code>.  <br /></td></tr>
<tr class="separator:a54b810cd98d27ace7d93fb9571431b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa8feb639d28dbe9a7af0fce7b93c43" id="r_a8aa8feb639d28dbe9a7af0fce7b93c43"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a8aa8feb639d28dbe9a7af0fce7b93c43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8aa8feb639d28dbe9a7af0fce7b93c43">add_rule_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;lhop, Word const &amp;rhop)</td></tr>
<tr class="memdesc:a8aa8feb639d28dbe9a7af0fce7b93c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule to the presentation by reference.  <br /></td></tr>
<tr class="separator:a8aa8feb639d28dbe9a7af0fce7b93c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6180b7c4223506b956425c494bda6b07" id="r_a6180b7c4223506b956425c494bda6b07"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Iterator&gt; </td></tr>
<tr class="memitem:a6180b7c4223506b956425c494bda6b07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6180b7c4223506b956425c494bda6b07">add_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a6180b7c4223506b956425c494bda6b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the rules stored in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:a6180b7c4223506b956425c494bda6b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c792235574835a04dec1420123c781" id="r_ae8c792235574835a04dec1420123c781"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ae8c792235574835a04dec1420123c781"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae8c792235574835a04dec1420123c781">add_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;q)</td></tr>
<tr class="memdesc:ae8c792235574835a04dec1420123c781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the rules of <code class="param">q</code> to <code class="param">p</code>.  <br /></td></tr>
<tr class="separator:ae8c792235574835a04dec1420123c781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8c165b843fa198a52f7b19339debee" id="r_a7a8c165b843fa198a52f7b19339debee"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Iterator&gt; </td></tr>
<tr class="memitem:a7a8c165b843fa198a52f7b19339debee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a8c165b843fa198a52f7b19339debee">add_rules_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a7a8c165b843fa198a52f7b19339debee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the rules stored in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:a7a8c165b843fa198a52f7b19339debee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7cbdc2c5554c454d22008a531abf11" id="r_ace7cbdc2c5554c454d22008a531abf11"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ace7cbdc2c5554c454d22008a531abf11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ace7cbdc2c5554c454d22008a531abf11">add_rules_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;q)</td></tr>
<tr class="memdesc:ace7cbdc2c5554c454d22008a531abf11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the rules of <code class="param">q</code> to <code class="param">p</code>.  <br /></td></tr>
<tr class="separator:ace7cbdc2c5554c454d22008a531abf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3c9d8cb00a2d2c2f723743e41ad4fd" id="r_afa3c9d8cb00a2d2c2f723743e41ad4fd"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:afa3c9d8cb00a2d2c2f723743e41ad4fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afa3c9d8cb00a2d2c2f723743e41ad4fd">add_zero_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, typename <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> z)</td></tr>
<tr class="memdesc:afa3c9d8cb00a2d2c2f723743e41ad4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rules for a zero element.  <br /></td></tr>
<tr class="separator:afa3c9d8cb00a2d2c2f723743e41ad4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326ce3f4e0df610dd6864b08e9a596dc" id="r_a326ce3f4e0df610dd6864b08e9a596dc"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a326ce3f4e0df610dd6864b08e9a596dc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a326ce3f4e0df610dd6864b08e9a596dc">are_rules_sorted</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:a326ce3f4e0df610dd6864b08e9a596dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the rules are sorted relative to shortlex.  <br /></td></tr>
<tr class="separator:a326ce3f4e0df610dd6864b08e9a596dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6126865fec0ff1b3e2706244a2579142" id="r_a6126865fec0ff1b3e2706244a2579142"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Compare&gt; </td></tr>
<tr class="memitem:a6126865fec0ff1b3e2706244a2579142"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6126865fec0ff1b3e2706244a2579142">are_rules_sorted</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p, Compare cmp)</td></tr>
<tr class="memdesc:a6126865fec0ff1b3e2706244a2579142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the rules are sorted relative to <code class="param">cmp</code> .  <br /></td></tr>
<tr class="separator:a6126865fec0ff1b3e2706244a2579142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566be91ca21e81dc521f066007f19de0" id="r_a566be91ca21e81dc521f066007f19de0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a566be91ca21e81dc521f066007f19de0">balance_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *letters, char const *inverses)</td></tr>
<tr class="memdesc:a566be91ca21e81dc521f066007f19de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the length of the left-hand and right-hand sides.  <br /></td></tr>
<tr class="separator:a566be91ca21e81dc521f066007f19de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a71bedffcfd1cfe7fac17c2486e314" id="r_a66a71bedffcfd1cfe7fac17c2486e314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66a71bedffcfd1cfe7fac17c2486e314">balance_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, std::string_view letters, std::string_view inverses)</td></tr>
<tr class="memdesc:a66a71bedffcfd1cfe7fac17c2486e314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the length of the left-hand and right-hand sides.  <br /></td></tr>
<tr class="separator:a66a71bedffcfd1cfe7fac17c2486e314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d92a4c5b3b46959e67b7fc656a6a32f" id="r_a6d92a4c5b3b46959e67b7fc656a6a32f"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a6d92a4c5b3b46959e67b7fc656a6a32f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d92a4c5b3b46959e67b7fc656a6a32f">balance_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;letters, Word const &amp;inverses)</td></tr>
<tr class="memdesc:a6d92a4c5b3b46959e67b7fc656a6a32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the length of the left-hand and right-hand sides.  <br /></td></tr>
<tr class="separator:a6d92a4c5b3b46959e67b7fc656a6a32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a284c3587eaec3aa4d51c7716f16c1" id="r_a72a284c3587eaec3aa4d51c7716f16c1"><td class="memTemplParams" colspan="2">template&lt;typename Word1, typename Word2&gt; </td></tr>
<tr class="memitem:a72a284c3587eaec3aa4d51c7716f16c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72a284c3587eaec3aa4d51c7716f16c1">balance_no_checks</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word1 &gt; &amp;p, Word2 const &amp;letters, Word2 const &amp;inverses)</td></tr>
<tr class="memdesc:a72a284c3587eaec3aa4d51c7716f16c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the length of the left-hand and right-hand sides.  <br /></td></tr>
<tr class="separator:a72a284c3587eaec3aa4d51c7716f16c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222c4489fa22dfe970147e7e6a29fa02" id="r_a222c4489fa22dfe970147e7e6a29fa02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a222c4489fa22dfe970147e7e6a29fa02">change_alphabet</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *new_alphabet)</td></tr>
<tr class="memdesc:a222c4489fa22dfe970147e7e6a29fa02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change or re-order the alphabet.  <br /></td></tr>
<tr class="separator:a222c4489fa22dfe970147e7e6a29fa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2edd3f1ec1d0724aa27a33a47f0b0e3" id="r_ad2edd3f1ec1d0724aa27a33a47f0b0e3"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ad2edd3f1ec1d0724aa27a33a47f0b0e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2edd3f1ec1d0724aa27a33a47f0b0e3">change_alphabet</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const  &amp;new_alphabet)</td></tr>
<tr class="memdesc:ad2edd3f1ec1d0724aa27a33a47f0b0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change or re-order the alphabet.  <br /></td></tr>
<tr class="separator:ad2edd3f1ec1d0724aa27a33a47f0b0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49562e8f86600c1b0fcbde6df5ebdbf5" id="r_a49562e8f86600c1b0fcbde6df5ebdbf5"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a49562e8f86600c1b0fcbde6df5ebdbf5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49562e8f86600c1b0fcbde6df5ebdbf5">contains_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;lhs, Word const &amp;rhs)</td></tr>
<tr class="memdesc:a49562e8f86600c1b0fcbde6df5ebdbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a presentation contains a rule.  <br /></td></tr>
<tr class="separator:a49562e8f86600c1b0fcbde6df5ebdbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2fb0325c17b4b25d53babe3454f9d9" id="r_add2fb0325c17b4b25d53babe3454f9d9"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:add2fb0325c17b4b25d53babe3454f9d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#add2fb0325c17b4b25d53babe3454f9d9">first_unused_letter</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:add2fb0325c17b4b25d53babe3454f9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first letter <b>not</b> in the alphabet of a presentation.  <br /></td></tr>
<tr class="separator:add2fb0325c17b4b25d53babe3454f9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bedb3cafce55ab3e5d55fd081a8849" id="r_ad1bedb3cafce55ab3e5d55fd081a8849"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ad1bedb3cafce55ab3e5d55fd081a8849"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad1bedb3cafce55ab3e5d55fd081a8849">greedy_reduce_length</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:ad1bedb3cafce55ab3e5d55fd081a8849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greedily reduce the length of the presentation using <code>longest_subword_reducing_length</code>.  <br /></td></tr>
<tr class="separator:ad1bedb3cafce55ab3e5d55fd081a8849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ab46eec3f588f8cf0df768ec71ac20" id="r_a51ab46eec3f588f8cf0df768ec71ac20"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a51ab46eec3f588f8cf0df768ec71ac20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a51ab46eec3f588f8cf0df768ec71ac20">greedy_reduce_length_and_number_of_gens</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a51ab46eec3f588f8cf0df768ec71ac20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greedily reduce the length and number of generators of the presentation.  <br /></td></tr>
<tr class="separator:a51ab46eec3f588f8cf0df768ec71ac20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad503a8cc1838501f3b2b26bbb3fe78ee" id="r_ad503a8cc1838501f3b2b26bbb3fe78ee"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ad503a8cc1838501f3b2b26bbb3fe78ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad503a8cc1838501f3b2b26bbb3fe78ee">is_strongly_compressible</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:ad503a8cc1838501f3b2b26bbb3fe78ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the \(1\)-relation presentation can be strongly compressed.  <br /></td></tr>
<tr class="separator:ad503a8cc1838501f3b2b26bbb3fe78ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4f0c313d39e8062e1efd4c23be2c48" id="r_adc4f0c313d39e8062e1efd4c23be2c48"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:adc4f0c313d39e8062e1efd4c23be2c48"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc4f0c313d39e8062e1efd4c23be2c48">length</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:adc4f0c313d39e8062e1efd4c23be2c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the lengths of all values in the range <code>[first, ! last)</code>.  <br /></td></tr>
<tr class="separator:adc4f0c313d39e8062e1efd4c23be2c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab497e1912b31da8d098193daff8d05c7" id="r_ab497e1912b31da8d098193daff8d05c7"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ab497e1912b31da8d098193daff8d05c7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab497e1912b31da8d098193daff8d05c7">length</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:ab497e1912b31da8d098193daff8d05c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the lengths of the rules of <code class="param">p</code>.  <br /></td></tr>
<tr class="separator:ab497e1912b31da8d098193daff8d05c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d1cde375c344f2883be80622cdab80" id="r_a22d1cde375c344f2883be80622cdab80"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a22d1cde375c344f2883be80622cdab80"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22d1cde375c344f2883be80622cdab80">longest_rule</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a22d1cde375c344f2883be80622cdab80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing at the left-hand side of the first rule of maximal length in the given range.  <br /></td></tr>
<tr class="separator:a22d1cde375c344f2883be80622cdab80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905af2e4e6bc2d4e0d565fecb167060f" id="r_a905af2e4e6bc2d4e0d565fecb167060f"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a905af2e4e6bc2d4e0d565fecb167060f"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a905af2e4e6bc2d4e0d565fecb167060f">longest_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:a905af2e4e6bc2d4e0d565fecb167060f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing at the left-hand side of the first rule in the presentation with maximal length.  <br /></td></tr>
<tr class="separator:a905af2e4e6bc2d4e0d565fecb167060f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af54c090bb9f81f86d1e834fbdbc842" id="r_a0af54c090bb9f81f86d1e834fbdbc842"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a0af54c090bb9f81f86d1e834fbdbc842"><td class="memTemplItemLeft" align="right" valign="top">Iterator::value_type::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0af54c090bb9f81f86d1e834fbdbc842">longest_rule_length</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a0af54c090bb9f81f86d1e834fbdbc842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum length of a rule in the given range.  <br /></td></tr>
<tr class="separator:a0af54c090bb9f81f86d1e834fbdbc842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd9114b812112f4ef7900267aace604" id="r_a7dd9114b812112f4ef7900267aace604"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a7dd9114b812112f4ef7900267aace604"><td class="memTemplItemLeft" align="right" valign="top">Word::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7dd9114b812112f4ef7900267aace604">longest_rule_length</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:a7dd9114b812112f4ef7900267aace604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum length of a rule in the presentation.  <br /></td></tr>
<tr class="separator:a7dd9114b812112f4ef7900267aace604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bd3357ca0f50a429df940ee4cdaa95" id="r_a57bd3357ca0f50a429df940ee4cdaa95"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a57bd3357ca0f50a429df940ee4cdaa95"><td class="memTemplItemLeft" align="right" valign="top">Word&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57bd3357ca0f50a429df940ee4cdaa95">longest_subword_reducing_length</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a57bd3357ca0f50a429df940ee4cdaa95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the longest common subword of the rules.  <br /></td></tr>
<tr class="separator:a57bd3357ca0f50a429df940ee4cdaa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f71687ecca9e2782cf17f8d0dc9f439" id="r_a9f71687ecca9e2782cf17f8d0dc9f439"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a9f71687ecca9e2782cf17f8d0dc9f439"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9f71687ecca9e2782cf17f8d0dc9f439">make_semigroup</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a9f71687ecca9e2782cf17f8d0dc9f439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a monoid presentation to a semigroup presentation.  <br /></td></tr>
<tr class="separator:a9f71687ecca9e2782cf17f8d0dc9f439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad88ee5f4b8c87466fb33283787fc98d" id="r_aad88ee5f4b8c87466fb33283787fc98d"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:aad88ee5f4b8c87466fb33283787fc98d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aad88ee5f4b8c87466fb33283787fc98d">normalize_alphabet</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:aad88ee5f4b8c87466fb33283787fc98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the alphabet to \(\{0, \ldots, n - 1\}\).  <br /></td></tr>
<tr class="separator:aad88ee5f4b8c87466fb33283787fc98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f82a21af1e0e278e66fd1aea2949faf" id="r_a9f82a21af1e0e278e66fd1aea2949faf"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a9f82a21af1e0e278e66fd1aea2949faf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9f82a21af1e0e278e66fd1aea2949faf">reduce_complements</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a9f82a21af1e0e278e66fd1aea2949faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there are rules \(u = v\) and \(v = w\) where  \(|w| &lt;
|v|\), then replace \(u = v\) by \(u = w\).  <br /></td></tr>
<tr class="separator:a9f82a21af1e0e278e66fd1aea2949faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12eee0cff7880777dbc3bbba74de7bdf" id="r_a12eee0cff7880777dbc3bbba74de7bdf"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a12eee0cff7880777dbc3bbba74de7bdf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a12eee0cff7880777dbc3bbba74de7bdf">reduce_to_2_generators</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, size_t index=0)</td></tr>
<tr class="memdesc:a12eee0cff7880777dbc3bbba74de7bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the number of generators in a \(1\)-relation presentation to <code>2</code>.  <br /></td></tr>
<tr class="separator:a12eee0cff7880777dbc3bbba74de7bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf820f4a3a95bb86f65ad2988e4ebe3" id="r_adaf820f4a3a95bb86f65ad2988e4ebe3"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:adaf820f4a3a95bb86f65ad2988e4ebe3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adaf820f4a3a95bb86f65ad2988e4ebe3">remove_duplicate_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:adaf820f4a3a95bb86f65ad2988e4ebe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicate rules.  <br /></td></tr>
<tr class="separator:adaf820f4a3a95bb86f65ad2988e4ebe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0eda9b2399fafdc35cf13a8abf71c76" id="r_ac0eda9b2399fafdc35cf13a8abf71c76"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ac0eda9b2399fafdc35cf13a8abf71c76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0eda9b2399fafdc35cf13a8abf71c76">remove_redundant_generators</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:ac0eda9b2399fafdc35cf13a8abf71c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any trivially redundant generators.  <br /></td></tr>
<tr class="separator:ac0eda9b2399fafdc35cf13a8abf71c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784fe4c484d3c4fa97d9856f4d9363ec" id="r_a784fe4c484d3c4fa97d9856f4d9363ec"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a784fe4c484d3c4fa97d9856f4d9363ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a784fe4c484d3c4fa97d9856f4d9363ec">remove_trivial_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a784fe4c484d3c4fa97d9856f4d9363ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove rules consisting of identical words.  <br /></td></tr>
<tr class="separator:a784fe4c484d3c4fa97d9856f4d9363ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9446d7e75e55059446137dc90a5d85" id="r_a0c9446d7e75e55059446137dc90a5d85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c9446d7e75e55059446137dc90a5d85">replace_subword</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *existing, char const *replacement)</td></tr>
<tr class="memdesc:a0c9446d7e75e55059446137dc90a5d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace non-overlapping instances of a subword by another word by <code>const chat*</code>.  <br /></td></tr>
<tr class="separator:a0c9446d7e75e55059446137dc90a5d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e339b2779d8b2d1d40fafa4428e9513" id="r_a5e339b2779d8b2d1d40fafa4428e9513"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Iterator1, typename Iterator2&gt; </td></tr>
<tr class="memitem:a5e339b2779d8b2d1d40fafa4428e9513"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5e339b2779d8b2d1d40fafa4428e9513">replace_subword</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Iterator1 first_existing, Iterator1 last_existing, Iterator2 first_replacement, Iterator2 last_replacement)</td></tr>
<tr class="memdesc:a5e339b2779d8b2d1d40fafa4428e9513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace non-overlapping instances of a subword by another word.  <br /></td></tr>
<tr class="separator:a5e339b2779d8b2d1d40fafa4428e9513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bd68d064a46c7b477e11bc4c1f8667" id="r_a92bd68d064a46c7b477e11bc4c1f8667"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a92bd68d064a46c7b477e11bc4c1f8667"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92bd68d064a46c7b477e11bc4c1f8667">replace_subword</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;existing, Word const &amp;replacement)</td></tr>
<tr class="memdesc:a92bd68d064a46c7b477e11bc4c1f8667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace non-overlapping instances of a subword by another word.  <br /></td></tr>
<tr class="separator:a92bd68d064a46c7b477e11bc4c1f8667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a28e29e9dcad2b9d48e1558cc1bb920" id="r_a8a28e29e9dcad2b9d48e1558cc1bb920"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a8a28e29e9dcad2b9d48e1558cc1bb920"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a28e29e9dcad2b9d48e1558cc1bb920">replace_word</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;existing, Word const &amp;replacement)</td></tr>
<tr class="memdesc:a8a28e29e9dcad2b9d48e1558cc1bb920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace instances of a word on either side of a rule by another word.  <br /></td></tr>
<tr class="separator:a8a28e29e9dcad2b9d48e1558cc1bb920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265744c7f98fbbd671d496386bbc8e98" id="r_a265744c7f98fbbd671d496386bbc8e98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a265744c7f98fbbd671d496386bbc8e98">replace_word_with_new_generator</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;p, char const *w)</td></tr>
<tr class="memdesc:a265744c7f98fbbd671d496386bbc8e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace non-overlapping instances of a subword via <code>char const*</code>.  <br /></td></tr>
<tr class="separator:a265744c7f98fbbd671d496386bbc8e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed818a30289cea069ce8196809a8675" id="r_a0ed818a30289cea069ce8196809a8675"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Iterator&gt; </td></tr>
<tr class="memitem:a0ed818a30289cea069ce8196809a8675"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ed818a30289cea069ce8196809a8675">replace_word_with_new_generator</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a0ed818a30289cea069ce8196809a8675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace non-overlapping instances of a subword via iterators.  <br /></td></tr>
<tr class="separator:a0ed818a30289cea069ce8196809a8675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada89238bda7b8f989fdf2fffcb86418e" id="r_ada89238bda7b8f989fdf2fffcb86418e"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ada89238bda7b8f989fdf2fffcb86418e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada89238bda7b8f989fdf2fffcb86418e">replace_word_with_new_generator</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Word const &amp;w)</td></tr>
<tr class="memdesc:ada89238bda7b8f989fdf2fffcb86418e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace non-overlapping instances of a word with a new generator via const reference.  <br /></td></tr>
<tr class="separator:ada89238bda7b8f989fdf2fffcb86418e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09297ced05d3a33849423c06d9285624" id="r_a09297ced05d3a33849423c06d9285624"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a09297ced05d3a33849423c06d9285624"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09297ced05d3a33849423c06d9285624">reverse</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;&amp;p)</td></tr>
<tr class="memdesc:a09297ced05d3a33849423c06d9285624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse every rule.  <br /></td></tr>
<tr class="separator:a09297ced05d3a33849423c06d9285624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4273c14477b26904fa81aebb11f33ec9" id="r_a4273c14477b26904fa81aebb11f33ec9"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a4273c14477b26904fa81aebb11f33ec9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4273c14477b26904fa81aebb11f33ec9">reverse</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a4273c14477b26904fa81aebb11f33ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse every rule.  <br /></td></tr>
<tr class="separator:a4273c14477b26904fa81aebb11f33ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65069c045453edf6cc59c6c2fbe65343" id="r_a65069c045453edf6cc59c6c2fbe65343"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a65069c045453edf6cc59c6c2fbe65343"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a65069c045453edf6cc59c6c2fbe65343">shortest_rule</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a65069c045453edf6cc59c6c2fbe65343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing at the left-hand side of the first rule of minimal length in the given range.  <br /></td></tr>
<tr class="separator:a65069c045453edf6cc59c6c2fbe65343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0923abe23bd54ef423419b7f11933903" id="r_a0923abe23bd54ef423419b7f11933903"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a0923abe23bd54ef423419b7f11933903"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0923abe23bd54ef423419b7f11933903">shortest_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:a0923abe23bd54ef423419b7f11933903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing at the left-hand side of the first rule in the presentation with minimal length.  <br /></td></tr>
<tr class="separator:a0923abe23bd54ef423419b7f11933903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74635d388ce178f7b69d5c851bc8b93f" id="r_a74635d388ce178f7b69d5c851bc8b93f"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a74635d388ce178f7b69d5c851bc8b93f"><td class="memTemplItemLeft" align="right" valign="top">Iterator::value_type::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a74635d388ce178f7b69d5c851bc8b93f">shortest_rule_length</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a74635d388ce178f7b69d5c851bc8b93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum length of a rule in the given range.  <br /></td></tr>
<tr class="separator:a74635d388ce178f7b69d5c851bc8b93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482393ea90410b720e40969ea90f70ad" id="r_a482393ea90410b720e40969ea90f70ad"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a482393ea90410b720e40969ea90f70ad"><td class="memTemplItemLeft" align="right" valign="top">Word::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a482393ea90410b720e40969ea90f70ad">shortest_rule_length</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p)</td></tr>
<tr class="memdesc:a482393ea90410b720e40969ea90f70ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum length of a rule in the presentation.  <br /></td></tr>
<tr class="separator:a482393ea90410b720e40969ea90f70ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59966c2bf07eb98721dfe506e3c03e4e" id="r_a59966c2bf07eb98721dfe506e3c03e4e"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a59966c2bf07eb98721dfe506e3c03e4e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a59966c2bf07eb98721dfe506e3c03e4e">sort_each_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:a59966c2bf07eb98721dfe506e3c03e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the left-hand and right-hand side of each rule by shortlex.  <br /></td></tr>
<tr class="separator:a59966c2bf07eb98721dfe506e3c03e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a74fc9f1cf7a0fbc165106c1b3931a1" id="r_a2a74fc9f1cf7a0fbc165106c1b3931a1"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Compare&gt; </td></tr>
<tr class="memitem:a2a74fc9f1cf7a0fbc165106c1b3931a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2a74fc9f1cf7a0fbc165106c1b3931a1">sort_each_rule</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Compare cmp)</td></tr>
<tr class="memdesc:a2a74fc9f1cf7a0fbc165106c1b3931a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the left-hand and right-hand side of each rule relative to <code class="param">cmp</code>.  <br /></td></tr>
<tr class="separator:a2a74fc9f1cf7a0fbc165106c1b3931a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2524c6337ced966c9b1001c768c7d5" id="r_ada2524c6337ced966c9b1001c768c7d5"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:ada2524c6337ced966c9b1001c768c7d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada2524c6337ced966c9b1001c768c7d5">sort_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:ada2524c6337ced966c9b1001c768c7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all of the rules by shortlex.  <br /></td></tr>
<tr class="separator:ada2524c6337ced966c9b1001c768c7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91480c6d87296d5586c1e17df0d0d437" id="r_a91480c6d87296d5586c1e17df0d0d437"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Compare&gt; </td></tr>
<tr class="memitem:a91480c6d87296d5586c1e17df0d0d437"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a91480c6d87296d5586c1e17df0d0d437">sort_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p, Compare cmp)</td></tr>
<tr class="memdesc:a91480c6d87296d5586c1e17df0d0d437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all of the rules by <code class="param">cmp</code>.  <br /></td></tr>
<tr class="separator:a91480c6d87296d5586c1e17df0d0d437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe7deda5b5f239dfca3054c32de9da3" id="r_aafe7deda5b5f239dfca3054c32de9da3"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:aafe7deda5b5f239dfca3054c32de9da3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aafe7deda5b5f239dfca3054c32de9da3">strongly_compress</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;p)</td></tr>
<tr class="memdesc:aafe7deda5b5f239dfca3054c32de9da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strongly compress a \(1\)-relation presentation.  <br /></td></tr>
<tr class="separator:aafe7deda5b5f239dfca3054c32de9da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9bdbe4253a0acb561e92260d733b43" id="r_aec9bdbe4253a0acb561e92260d733b43"><td class="memTemplParams" colspan="2"><a id="aec9bdbe4253a0acb561e92260d733b43" name="aec9bdbe4253a0acb561e92260d733b43"></a>
template&lt;typename Word&gt; </td></tr>
<tr class="memitem:aec9bdbe4253a0acb561e92260d733b43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>throw_if_not_normalized</b> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p, std::string_view arg=&quot;1st&quot;)</td></tr>
<tr class="separator:aec9bdbe4253a0acb561e92260d733b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1569bd727eb77cb388ea564b0da00a84" id="r_a1569bd727eb77cb388ea564b0da00a84"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1569bd727eb77cb388ea564b0da00a84">to_gap_string</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; const &amp;p, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;var_name)</td></tr>
<tr class="memdesc:a1569bd727eb77cb388ea564b0da00a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the code that would create <code class="param">p</code> in GAP.  <br /></td></tr>
<tr class="separator:a1569bd727eb77cb388ea564b0da00a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa78f3583eccd084393f466b5615a7e" id="r_afaa78f3583eccd084393f466b5615a7e"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaa78f3583eccd084393f466b5615a7e">to_gap_string</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> &gt; const &amp;p, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;var_name)</td></tr>
<tr class="memdesc:afaa78f3583eccd084393f466b5615a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the code that would create <code class="param">p</code> in GAP.  <br /></td></tr>
<tr class="separator:afaa78f3583eccd084393f466b5615a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b4b6eb283afeb6c9d546c7c5988bd4" id="r_ae5b4b6eb283afeb6c9d546c7c5988bd4"><td class="memTemplParams" colspan="2">template&lt;typename Word, typename Iterator&gt; </td></tr>
<tr class="memitem:ae5b4b6eb283afeb6c9d546c7c5988bd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5b4b6eb283afeb6c9d546c7c5988bd4">validate_rules</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:ae5b4b6eb283afeb6c9d546c7c5988bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate rules against the alphabet of <code class="param">p</code>.  <br /></td></tr>
<tr class="separator:ae5b4b6eb283afeb6c9d546c7c5988bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756f5721e810bac90aca39df8f87c080" id="r_a756f5721e810bac90aca39df8f87c080"><td class="memTemplParams" colspan="2">template&lt;typename Word&gt; </td></tr>
<tr class="memitem:a756f5721e810bac90aca39df8f87c080"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a756f5721e810bac90aca39df8f87c080">validate_semigroup_inverses</a> (<a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;p, Word const &amp;vals)</td></tr>
<tr class="memdesc:a756f5721e810bac90aca39df8f87c080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate if <code class="param">vals</code> act as semigroup inverses in <code class="param">p</code>.  <br /></td></tr>
<tr class="separator:a756f5721e810bac90aca39df8f87c080"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aba4fd25074207d63e51e2c74b18ec05d" name="aba4fd25074207d63e51e2c74b18ec05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4fd25074207d63e51e2c74b18ec05d">&#9670;&#160;</a></span>add_commutes_rules_no_checks() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_commutes_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rules to <code class="param">p</code> of the form \(uv = vu\) for every pair of letters \(u, v\) in <code class="param">letters</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">letters</td><td>the collection of letters to add rules for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of <code class="param">p</code> are performed. </dd></dl>

</div>
</div>
<a id="adcd301c9aa6299cd6e9863934f3afb26" name="adcd301c9aa6299cd6e9863934f3afb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd301c9aa6299cd6e9863934f3afb26">&#9670;&#160;</a></span>add_commutes_rules_no_checks() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_commutes_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Word &gt;</td>          <td class="paramname"><span class="paramname"><em>words</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rules to <code class="param">p</code> of the form \(uv = vu\) for every letter \(u\) in <code class="param">letters</code> and \(v\) in <code class="param">words</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">letters</td><td>the collection of letters to add rules for. </td></tr>
    <tr><td class="paramname">words</td><td>the collection of words to add rules for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of <code class="param">p</code> are performed. </dd></dl>

</div>
</div>
<a id="a0d04d59da745faf2e6a1c981857c090e" name="a0d04d59da745faf2e6a1c981857c090e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d04d59da745faf2e6a1c981857c090e">&#9670;&#160;</a></span>add_commutes_rules_no_checks() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_commutes_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rules to <code class="param">p</code> of the form \(uv = vu\) for every letter \(u\) in <code class="param">letters1</code> and \(v\) in <code class="param">letters2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">letters1</td><td>the first collection of letters to add rules for. </td></tr>
    <tr><td class="paramname">letters2</td><td>the second collection of letters to add rules for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of <code class="param">p</code> are performed. </dd></dl>

</div>
</div>
<a id="a204d70a297be8f67ca41b28d501b2746" name="a204d70a297be8f67ca41b28d501b2746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204d70a297be8f67ca41b28d501b2746">&#9670;&#160;</a></span>add_idempotent_rules_no_checks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_idempotent_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rules to <code class="param">p</code> of the form \(a^2 = a\) for every letter \(a\) in <code class="param">letters</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">letters</td><td>the letters to make idempotent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of <code class="param">p</code> are performed. </dd></dl>

</div>
</div>
<a id="a97116b13ea4b20d65dee405f311f42d0" name="a97116b13ea4b20d65dee405f311f42d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97116b13ea4b20d65dee405f311f42d0">&#9670;&#160;</a></span>add_identity_rules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_identity_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rules of the form \(ae = ea = a\) for every letter \(a\) in the alphabet of <code class="param">p</code>, and where \(e\) is the second parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">e</td><td>the identity element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">e</code> is not a letter in <code>p.alphabet()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the number of rules. </dd></dl>

</div>
</div>
<a id="ab8ab32292d024ec04ad3abd9fd715fc3" name="ab8ab32292d024ec04ad3abd9fd715fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ab32292d024ec04ad3abd9fd715fc3">&#9670;&#160;</a></span>add_inverse_rules() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_inverse_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>vals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>e</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The letter <code>a</code> with index <code>i</code> in <code class="param">vals</code> is the inverse of the letter in <code>alphabet()</code> with index <code>i</code>. The rules added are  \(a_ib_i
= e\) where the alphabet is \(\{a_1, \ldots, a_n\}\); the 2nd parameter <code class="param">vals</code> is \(\{b_1, \ldots, b_n\}\); and \(e\) is the 3rd parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">vals</td><td>the inverses. </td></tr>
    <tr><td class="paramname">e</td><td>the identity element (defaults to <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a>, meaning use the empty word).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if any of the following apply:<ul>
<li>the length of <code class="param">vals</code> is not equal to <code>alphabet().size()</code>;</li>
<li>the letters in <code class="param">vals</code> are not exactly those in <code>alphabet()</code> (perhaps in a different order);</li>
<li>\((a_i ^ {-1}) ^ {-1} = a_i\) does not hold for some \(i\);</li>
<li>\(e ^ {-1} = e\) does not hold</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>\(O(n)\) where \(n\) is <code>p.alphabet().size()</code>. </dd></dl>

</div>
</div>
<a id="ad39a6ad8b9694fb7e1ea3dc518a8cde6" name="ad39a6ad8b9694fb7e1ea3dc518a8cde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39a6ad8b9694fb7e1ea3dc518a8cde6">&#9670;&#160;</a></span>add_inverse_rules() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_inverse_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>vals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The letter <code>a</code> with index <code>i</code> in <code class="param">vals</code> is the inverse of the letter in <code>alphabet()</code> with index <code>i</code>. The rules added are  \(a_ib_i
= e\) where the alphabet is \(\{a_1, \ldots, a_n\}\); the 2nd parameter <code class="param">vals</code> is \(\{b_1, \ldots, b_n\}\); and \(e\) is the 3rd parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">vals</td><td>the inverses. </td></tr>
    <tr><td class="paramname">e</td><td>the identity element (defaults to <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a>, meaning use the empty word).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if any of the following apply:<ul>
<li>the length of <code class="param">vals</code> is not equal to <code>alphabet().size()</code>;</li>
<li>the letters in <code class="param">vals</code> are not exactly those in <code>alphabet()</code> (perhaps in a different order);</li>
<li>\((a_i ^ {-1}) ^ {-1} = a_i\) does not hold for some \(i\);</li>
<li>\(e ^ {-1} = e\) does not hold</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>\(O(n)\) where \(n\) is <code>p.alphabet().size()</code>. </dd></dl>

</div>
</div>
<a id="a3549f72bc6f99a31439bb28c136262ef" name="a3549f72bc6f99a31439bb28c136262ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3549f72bc6f99a31439bb28c136262ef">&#9670;&#160;</a></span>add_involution_rules_no_checks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_involution_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rules to <code class="param">p</code> of the form \(a^2 = \varepsilon\) for every letter \(a\) in <code class="param">letters</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">letters</td><td>the letters to add involution rules for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of <code class="param">p</code> are performed. </dd></dl>

</div>
</div>
<a id="ab47828c9c3a9a232a6e2716903f2202b" name="ab47828c9c3a9a232a6e2716903f2202b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47828c9c3a9a232a6e2716903f2202b">&#9670;&#160;</a></span>add_rule() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">lhop</code> or <code class="param">rhop</code> contains any letters not belonging to <code>p.alphabet()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a443507ef9ef8ffb631493b3a034db200" name="a443507ef9ef8ffb631493b3a034db200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443507ef9ef8ffb631493b3a034db200">&#9670;&#160;</a></span>add_rule() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    Adds the rule with left-hand side \p lhop and right-hand side \p rhop
    to the rules.

    \param p the presentation.
    \param lhop the left-hand side of the rule.
    \param rhop the right-hand side of the rule.

    \throws LibsemigroupsException if \p lhop or \p rhop contains any
    letters not belonging to `p.alphabet()`. 
</pre> 
</div>
</div>
<a id="a78a321dd3335d2239b8e9b49efd83f18" name="a78a321dd3335d2239b8e9b49efd83f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a321dd3335d2239b8e9b49efd83f18">&#9670;&#160;</a></span>add_rule() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    Adds the rule with left-hand side \p lhop and right-hand side \p rhop
    to the rules.

    \param p the presentation.
    \param lhop the left-hand side of the rule.
    \param rhop the right-hand side of the rule.

    \throws LibsemigroupsException if \p lhop or \p rhop contains any
    letters not belonging to `p.alphabet()`. 
</pre> 
</div>
</div>
<a id="aec13b8a8bd3e87b579d949f56900f356" name="aec13b8a8bd3e87b579d949f56900f356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec13b8a8bd3e87b579d949f56900f356">&#9670;&#160;</a></span>add_rule() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Letter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt;</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt;</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Letter</td><td>the type of the values in the <code>initializer_list</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">lhop</code> or <code class="param">rhop</code> contains any letters not belonging to <code>p.alphabet()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec80128d3c2e4b7cbf276731e0edfe56" name="aec80128d3c2e4b7cbf276731e0edfe56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec80128d3c2e4b7cbf276731e0edfe56">&#9670;&#160;</a></span>add_rule() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules, after checking that <code class="param">lhop</code> and <code class="param">rhop</code> consist entirely of letters in the alphabet of <code class="param">p</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">lhop</code> or <code class="param">rhop</code> contains any letters not belonging to <code>p.alphabet()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11a95e25c9bd84f930b71a116861a8ef" name="a11a95e25c9bd84f930b71a116861a8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a95e25c9bd84f930b71a116861a8ef">&#9670;&#160;</a></span>add_rule_no_checks() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_rule_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of the presentation are performed. </dd></dl>

</div>
</div>
<a id="ac4e7525ceaf1c1f72f323716c69e405a" name="ac4e7525ceaf1c1f72f323716c69e405a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e7525ceaf1c1f72f323716c69e405a">&#9670;&#160;</a></span>add_rule_no_checks() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_rule_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    Adds the rule with left-hand side \p lhop and right-hand side \p rhop
    to the rules.

    \param p the presentation.
    \param lhop the left-hand side of the rule.
    \param rhop the right-hand side of the rule.

    \par Exceptions
    This function guarantees not to throw a \ref LibsemigroupsException.

    \warning
    No checks that the arguments describe words over the alphabet of the
    presentation are performed. 
</pre> 
</div>
</div>
<a id="a237fa07d38a2a86ee30ccb661fd29d8c" name="a237fa07d38a2a86ee30ccb661fd29d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237fa07d38a2a86ee30ccb661fd29d8c">&#9670;&#160;</a></span>add_rule_no_checks() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_rule_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    Adds the rule with left-hand side \p lhop and right-hand side \p rhop
    to the rules.

    \param p the presentation.
    \param lhop the left-hand side of the rule.
    \param rhop the right-hand side of the rule.

    \par Exceptions
    This function guarantees not to throw a \ref LibsemigroupsException.

    \warning
    No checks that the arguments describe words over the alphabet of the
    presentation are performed. 
</pre> 
</div>
</div>
<a id="a54b810cd98d27ace7d93fb9571431b5d" name="a54b810cd98d27ace7d93fb9571431b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b810cd98d27ace7d93fb9571431b5d">&#9670;&#160;</a></span>add_rule_no_checks() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Letter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rule_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt;</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; Letter &gt;</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Letter</td><td>the type of the values in the <code>initializer_list</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of the presentation are performed. </dd></dl>

</div>
</div>
<a id="a8aa8feb639d28dbe9a7af0fce7b93c43" name="a8aa8feb639d28dbe9a7af0fce7b93c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa8feb639d28dbe9a7af0fce7b93c43">&#9670;&#160;</a></span>add_rule_no_checks() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rule_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the rule with left-hand side <code class="param">lhop</code> and right-hand side <code class="param">rhop</code> to the rules.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhop</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhop</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of the presentation are performed. </dd></dl>

</div>
</div>
<a id="a6180b7c4223506b956425c494bda6b07" name="a6180b7c4223506b956425c494bda6b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6180b7c4223506b956425c494bda6b07">&#9670;&#160;</a></span>add_rules() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds the rules stored in the range <code>[first, last)</code> to <code class="param">p</code>.</p>
<p>Before it is added, each rule is validated to check it contains only letters of the alphabet of <code class="param">p</code>. If the \(n\)th rule causes this function to throw, the first \(n-1\) rules will still be added to <code class="param">p</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Iterator</td><td>the type of the second and third arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing at the first rule to add. </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing one beyond the last rule to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if any rule contains any letters not belonging to <code>p.alphabet()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8c792235574835a04dec1420123c781" name="ae8c792235574835a04dec1420123c781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c792235574835a04dec1420123c781">&#9670;&#160;</a></span>add_rules() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds all the rules of the second argument <code class="param">q</code> to the first argument <code class="param">p</code> which is modified in-place.</p>
<p>Before it is added, each rule is validated to check it contains only letters of the alphabet of <code class="param">p</code>. If the \(n\)th rule causes this function to throw, the first \(n-1\) rules will still be added to <code class="param">p</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">q</td><td>the presentation with the rules to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if any rule contains any letters not belonging to <code>p.alphabet()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a8c165b843fa198a52f7b19339debee" name="a7a8c165b843fa198a52f7b19339debee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8c165b843fa198a52f7b19339debee">&#9670;&#160;</a></span>add_rules_no_checks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds the rules stored in the range <code>[first, last)</code> to the presentation <code class="param">p</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Iterator</td><td>the type of the second and third arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing at the first rule to add. </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing one beyond the last rule to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of the presentation are performed. </dd></dl>

</div>
</div>
<a id="ace7cbdc2c5554c454d22008a531abf11" name="ace7cbdc2c5554c454d22008a531abf11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7cbdc2c5554c454d22008a531abf11">&#9670;&#160;</a></span>add_rules_no_checks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_rules_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds all the rules of the second argument <code class="param">q</code> to the first argument <code class="param">p</code> which is modified in-place.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">q</td><td>the presentation with the rules to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No checks that the arguments describe words over the alphabet of the presentation are performed. </dd></dl>

</div>
</div>
<a id="afa3c9d8cb00a2d2c2f723743e41ad4fd" name="afa3c9d8cb00a2d2c2f723743e41ad4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3c9d8cb00a2d2c2f723743e41ad4fd">&#9670;&#160;</a></span>add_zero_rules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_zero_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rules of the form \(az = za = z\) for every letter \(a\) in the alphabet of <code class="param">p</code>, and where \(z\) is the second parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to. </td></tr>
    <tr><td class="paramname">z</td><td>the zero element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">z</code> is not a letter in <code>p.alphabet()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the number of rules. </dd></dl>

</div>
</div>
<a id="a326ce3f4e0df610dd6864b08e9a596dc" name="a326ce3f4e0df610dd6864b08e9a596dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326ce3f4e0df610dd6864b08e9a596dc">&#9670;&#160;</a></span>are_rules_sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool are_rules_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the rules \(u_1 = v_1, \ldots, u_n = v_n\) satisfy \(u_1v_1 &lt; \cdots &lt; u_nv_n\) where \(&lt;\) is shortlex order.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="#ada2524c6337ced966c9b1001c768c7d5">sort_rules(Presentation&lt;Word&gt;&amp; p)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6126865fec0ff1b3e2706244a2579142" name="a6126865fec0ff1b3e2706244a2579142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6126865fec0ff1b3e2706244a2579142">&#9670;&#160;</a></span>are_rules_sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool are_rules_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>cmp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the rules \(u_1 = v_1, \ldots, u_n = v_n\) satisfy \(u_1v_1 &lt; \cdots &lt; u_nv_n\) where \(&lt;\) is the order described by <code class="param">cmp</code> .</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Compare</td><td>the type of the compare function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to check. </td></tr>
    <tr><td class="paramname">cmp</td><td>the comparison function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="#a91480c6d87296d5586c1e17df0d0d437">sort_rules(Presentation&lt;Word&gt;&amp; p, Compare cmp)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a566be91ca21e81dc521f066007f19de0" name="a566be91ca21e81dc521f066007f19de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566be91ca21e81dc521f066007f19de0">&#9670;&#160;</a></span>balance_no_checks() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void balance_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overload for <a class="el" href="#a72a284c3587eaec3aa4d51c7716f16c1">balance_no_checks(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;, Word2 const&amp;)</a> to allow, string literals to be used for the parameters <code class="param">letters</code> and <code class="param">inverses</code>. </p>

</div>
</div>
<a id="a66a71bedffcfd1cfe7fac17c2486e314" name="a66a71bedffcfd1cfe7fac17c2486e314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a71bedffcfd1cfe7fac17c2486e314">&#9670;&#160;</a></span>balance_no_checks() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void balance_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overload for <a class="el" href="#a72a284c3587eaec3aa4d51c7716f16c1">balance_no_checks(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;, Word2 const&amp;)</a> to allow, std::string_view to be used for the parameters <code class="param">letters</code> and <code class="param">inverses</code>. </p>

</div>
</div>
<a id="a6d92a4c5b3b46959e67b7fc656a6a32f" name="a6d92a4c5b3b46959e67b7fc656a6a32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d92a4c5b3b46959e67b7fc656a6a32f">&#9670;&#160;</a></span>balance_no_checks() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void balance_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overload for <a class="el" href="#a72a284c3587eaec3aa4d51c7716f16c1">balance_no_checks(Presentation&lt;Word1&gt;&amp;, Word2 const&amp;, Word2 const&amp;)</a> to allow, for example, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a> to be used for the parameters <code class="param">letters</code> and <code class="param">inverses</code>. </p>

</div>
</div>
<a id="a72a284c3587eaec3aa4d51c7716f16c1" name="a72a284c3587eaec3aa4d51c7716f16c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a284c3587eaec3aa4d51c7716f16c1">&#9670;&#160;</a></span>balance_no_checks() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word1, typename Word2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void balance_no_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word2 const &amp;</td>          <td class="paramname"><span class="paramname"><em>letters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word2 const &amp;</td>          <td class="paramname"><span class="paramname"><em>inverses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function first sorts the sides of each rules so that the larger side of the rule is on the left. Then for each rule, while the last letter of the left-hand side is in <code class="param">letters</code>, the last letter of the left-hand side is removed and the corresponding value in <code class="param">inverses</code> is appended to the end of the right-hand side. Next, while the first letter of the left-hand side is in <code class="param">letters</code>, the first letter of the left-hand side is removed and the corresponding value in <code class="param">inverses</code> is appended to the front of the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word1</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Word2</td><td>the type of the words <code class="param">letters</code> and <code class="param">inverses</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">letters</td><td>the letters that can be replaced in the left-hand side. </td></tr>
    <tr><td class="paramname">inverses</td><td>the inverses of the letters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that the semigroup defined by <code class="param">p</code> is isomorphic to a group, and that <code class="param">inverses</code> are valid. However, this function does no checks on its arguments. If the previous assumptions do not hold, there is no guarantee the the semigroup \(S\) defined by <code class="param">p</code> before this function is called will be isomorphic to the semigroup \(S&#39;\) defined by <code class="param">p</code> after this function is called. </dd></dl>

</div>
</div>
<a id="a222c4489fa22dfe970147e7e6a29fa02" name="a222c4489fa22dfe970147e7e6a29fa02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222c4489fa22dfe970147e7e6a29fa02">&#9670;&#160;</a></span>change_alphabet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void change_alphabet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>new_alphabet</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function replaces <code>p.alphabet()</code> with <code class="param">new_alphabet</code> where possible, and re-writes the rules in the presentation using the new alphabet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">new_alphabet</td><td>the replacement alphabet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the size of <code>p.alphabet()</code> and <code class="param">new_alphabet</code> do not agree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2edd3f1ec1d0724aa27a33a47f0b0e3" name="ad2edd3f1ec1d0724aa27a33a47f0b0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2edd3f1ec1d0724aa27a33a47f0b0e3">&#9670;&#160;</a></span>change_alphabet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void change_alphabet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>new_alphabet</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function replaces <code>p.alphabet()</code> with <code class="param">new_alphabet</code>, where possible, and re-writes the rules in the presentation using the new alphabet.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">new_alphabet</td><td>the replacement alphabet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the size of <code>p.alphabet()</code> and <code class="param">new_alphabet</code> do not agree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49562e8f86600c1b0fcbde6df5ebdbf5" name="a49562e8f86600c1b0fcbde6df5ebdbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49562e8f86600c1b0fcbde6df5ebdbf5">&#9670;&#160;</a></span>contains_rule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool contains_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the rule with left-hand side <code class="param">lhs</code> and right-hand side <code class="param">rhs</code> is contained in <code class="param">p</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">lhs</td><td>the left-hand side of the rule. </td></tr>
    <tr><td class="paramname">rhs</td><td>the right-hand side of the rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the number of rules. </dd></dl>

</div>
</div>
<a id="add2fb0325c17b4b25d53babe3454f9d9" name="add2fb0325c17b4b25d53babe3454f9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2fb0325c17b4b25d53babe3454f9d9">&#9670;&#160;</a></span>first_unused_letter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> first_unused_letter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns <code>letter(p, i)</code> when <code>i</code> is the least possible value such that <code>!p.in_alphabet(letter(p, i))</code> if such a letter exists.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1" title="Type for the index of a generator of a semigroup.">letter_type</a></code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">p</code> already has an alphabet of the maximum possible size supported by <code><a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1" title="Type for the index of a generator of a semigroup.">letter_type</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1bedb3cafce55ab3e5d55fd081a8849" name="ad1bedb3cafce55ab3e5d55fd081a8849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bedb3cafce55ab3e5d55fd081a8849">&#9670;&#160;</a></span>greedy_reduce_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void greedy_reduce_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function repeatedly calls <code><a class="el" href="#a57bd3357ca0f50a429df940ee4cdaa95" title="Return the longest common subword of the rules.">presentation::longest_subword_reducing_length</a></code> and <code><a class="el" href="#a92bd68d064a46c7b477e11bc4c1f8667" title="Replace non-overlapping instances of a subword by another word.">presentation::replace_subword</a></code> to introduce a new generator and reduce the length of the presentation <code class="param">p</code> until <code><a class="el" href="#a57bd3357ca0f50a429df940ee4cdaa95" title="Return the longest common subword of the rules.">presentation::longest_subword_reducing_length</a></code> returns the empty word.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code><a class="el" href="#a57bd3357ca0f50a429df940ee4cdaa95" title="Return the longest common subword of the rules.">presentation::longest_subword_reducing_length</a></code> or <code><a class="el" href="#a8a28e29e9dcad2b9d48e1558cc1bb920" title="Replace instances of a word on either side of a rule by another word.">presentation::replace_word</a></code> does. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51ab46eec3f588f8cf0df768ec71ac20" name="a51ab46eec3f588f8cf0df768ec71ac20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ab46eec3f588f8cf0df768ec71ac20">&#9670;&#160;</a></span>greedy_reduce_length_and_number_of_gens()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void greedy_reduce_length_and_number_of_gens </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function repeatedly calls <code><a class="el" href="#a57bd3357ca0f50a429df940ee4cdaa95" title="Return the longest common subword of the rules.">presentation::longest_subword_reducing_length</a></code> and <code><a class="el" href="#a92bd68d064a46c7b477e11bc4c1f8667" title="Replace non-overlapping instances of a subword by another word.">presentation::replace_subword</a></code> to introduce a new generator to try to reduce the length of the presentation <code class="param">p</code> and the number of generators. This is done until either <code><a class="el" href="#a57bd3357ca0f50a429df940ee4cdaa95" title="Return the longest common subword of the rules.">presentation::longest_subword_reducing_length</a></code> returns the empty word, or the new length and number of generators is greater than or equal to that of the presentation in the previous iteration.</p>
<p>In the latter case, the presentation <code class="param">p</code> gets restored to the state it was in after the previous iteration.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>presentations::longest_subword_reducing_length</code> or <code>presentations::replace_word</code> does. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad503a8cc1838501f3b2b26bbb3fe78ee" name="ad503a8cc1838501f3b2b26bbb3fe78ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad503a8cc1838501f3b2b26bbb3fe78ee">&#9670;&#160;</a></span>is_strongly_compressible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_strongly_compressible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A \(1\)-relation presentation is <em>strongly compressible</em> if both relation words start with the same letter and end with the same letter. In other words, if the alphabet of the presentation <code class="param">p</code> is \(A\) and the relation words are of the form \(aub = avb\) where \(a, b\in A\) (possibly \( a = b\)) and \(u, v\in A ^ *\), then <code class="param">p</code> is strongly compressible. See <a href="https://doi.org/10.1007/s00233-021-10216-8">Section 3.2</a> for details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="#aafe7deda5b5f239dfca3054c32de9da3">strongly_compress</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adc4f0c313d39e8062e1efd4c23be2c48" name="adc4f0c313d39e8062e1efd4c23be2c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4f0c313d39e8062e1efd4c23be2c48">&#9670;&#160;</a></span>length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t length </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    Return the sum of the lengths of all values in the range `[first,
</pre><p> ! last)`. </p><pre class="fragment">    \tparam Iterator the type of the first and second arguments (iterators).
    \param first iterator pointing at the first value to calculate the
    length of.
    \param last iterator pointing one beyond the last value to
    calculate the length of.

    \returns A value of type `size_t`.

    \par Exceptions
    This function guarantees not to throw a \ref LibsemigroupsException. 
</pre> 
</div>
</div>
<a id="ab497e1912b31da8d098193daff8d05c7" name="ab497e1912b31da8d098193daff8d05c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab497e1912b31da8d098193daff8d05c7">&#9670;&#160;</a></span>length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the sum of the lengths of the rules of <code class="param">p</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>size_t</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="a22d1cde375c344f2883be80622cdab80" name="a22d1cde375c344f2883be80622cdab80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d1cde375c344f2883be80622cdab80">&#9670;&#160;</a></span>longest_rule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator longest_rule </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator pointing at the left-hand side of the first rule of maximal length in the given range.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>left-hand side of the first rule. </td></tr>
    <tr><td class="paramname">last</td><td>one past the right-hand side of the last rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Iterator</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the distance between <code class="param">first</code> and <code class="param">last</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a905af2e4e6bc2d4e0d565fecb167060f" name="a905af2e4e6bc2d4e0d565fecb167060f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905af2e4e6bc2d4e0d565fecb167060f">&#9670;&#160;</a></span>longest_rule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::const_iterator longest_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator pointing at the left-hand side of the first rule in the presentation with maximal length.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;Word&gt;::const_iterator</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the length of <code class="param">p.rules</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0af54c090bb9f81f86d1e834fbdbc842" name="a0af54c090bb9f81f86d1e834fbdbc842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af54c090bb9f81f86d1e834fbdbc842">&#9670;&#160;</a></span>longest_rule_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator::value_type::size_type longest_rule_length </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum length of a rule in the given range.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>left-hand side of the first rule. </td></tr>
    <tr><td class="paramname">last</td><td>one past the right-hand side of the last rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Iterator::value_type::size_type</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the length of <code class="param">p.rules</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dd9114b812112f4ef7900267aace604" name="a7dd9114b812112f4ef7900267aace604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd9114b812112f4ef7900267aace604">&#9670;&#160;</a></span>longest_rule_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Word::size_type longest_rule_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum length of a rule in the presentation.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Word::size_type</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the length of <code class="param">p.rules</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57bd3357ca0f50a429df940ee4cdaa95" name="a57bd3357ca0f50a429df940ee4cdaa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bd3357ca0f50a429df940ee4cdaa95">&#9670;&#160;</a></span>longest_subword_reducing_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Word longest_subword_reducing_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If it is possible to find a subword \(w\) of the rules  \(u_1 = v_1,
\ldots, u_n = v_n\) such that the introduction of a new generator \(z\) and the relation \(z = w\) reduces the <code><a class="el" href="#adc4f0c313d39e8062e1efd4c23be2c48" title="Return the sum of the lengths of all values in the range [first, ! last).">presentation::length</a></code> of the presentation, then this function returns the longest such word \(w\). If no such word can be found, then a word of length \(0\) is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code class="param">Word</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="a9f71687ecca9e2782cf17f8d0dc9f439" name="a9f71687ecca9e2782cf17f8d0dc9f439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f71687ecca9e2782cf17f8d0dc9f439">&#9670;&#160;</a></span>make_semigroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> make_semigroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function modifies its argument in-place by replacing the empty word in all relations by a new generator, and the identity rules for that new generator. If <code>p.contains_empty_word()</code> is <code>false</code>, then the presentation is not modified and <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a> is returned. If a new generator is added as the identity, then this generator is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new generator added, if any, and <a class="el" href="group__constants__group.html#ga43ad6fa7b6a31a377b9b4c15219f5f37">UNDEFINED</a> if not.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>replace_word</code> or <code>add_identity_rules</code> does. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad88ee5f4b8c87466fb33283787fc98d" name="aad88ee5f4b8c87466fb33283787fc98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad88ee5f4b8c87466fb33283787fc98d">&#9670;&#160;</a></span>normalize_alphabet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void normalize_alphabet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modify the presentation in-place so that the alphabet is  \(\{0, \ldots,
n - 1\}\) (or equivalent) and rewrites the rules to use this alphabet.</p>
<p>If the alphabet is already normalized, then no changes are made to the presentation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <a class="el" href="group__transf__group.html#gaec19a0378e74f34554609c932f1ea3a9">validate</a> throws on the initial presentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f82a21af1e0e278e66fd1aea2949faf" name="a9f82a21af1e0e278e66fd1aea2949faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f82a21af1e0e278e66fd1aea2949faf">&#9670;&#160;</a></span>reduce_complements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void reduce_complements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to reduce the length of the words by finding the equivalence relation on the relation words generated by the pairs of identical relation words. If \(\{u_1, u_2, \ldots, u_n\}\) are the distinct words in an equivalence class and \(u_1\) is the short-lex minimum word in the class, then the relation words are replaced by  \(u_1 =
u_2, u_1 = u_3, \cdots, u_1 = u_n\).</p>
<p>The rules may be reordered by this function even if there are no reductions found.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to add rules to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-deterministic; different results may be obtained when compiling with clang vs gcc </dd></dl>

</div>
</div>
<a id="a12eee0cff7880777dbc3bbba74de7bdf" name="a12eee0cff7880777dbc3bbba74de7bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12eee0cff7880777dbc3bbba74de7bdf">&#9670;&#160;</a></span>reduce_to_2_generators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool reduce_to_2_generators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reduce the number of generators in a \(1\)-relation presentation to <code>2</code>.</p>
<p>Returns <code>true</code> if the \(1\)-relation presentation <code class="param">p</code> has been modified and <code>false</code> if not.</p>
<p>A \(1\)-relation presentation is <em>left cycle-free</em> if the relation words start with distinct letters. In other words, if the alphabet of the presentation <code class="param">p</code> is \(A\) and the relation words are of the form \(au = bv\) where \(a, b\in A\) with \(a \neq b\) and \(u, v \in A ^ *\), then <code class="param">p</code> is left cycle-free. The word problem for a left cycle-free \(1\)-relation monoid is solvable if the word problem for the modified version obtained from this function is solvable.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">index</td><td>determines the choice of letter to use, <code>0</code> uses <code>p.rules[0].front()</code> and <code>1</code> uses <code>p.rules[1].front()</code> (defaults to: <code>0</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">index</code> is not <code>0</code> or <code>1</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaf820f4a3a95bb86f65ad2988e4ebe3" name="adaf820f4a3a95bb86f65ad2988e4ebe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf820f4a3a95bb86f65ad2988e4ebe3">&#9670;&#160;</a></span>remove_duplicate_rules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void remove_duplicate_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all but one instance of any duplicate rules (if any). Note that rules of the form \(u = v\) and \(v = u\) (if any) are considered duplicates. Also note that the rules may be reordered by this function even if there are no duplicate rules.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the number of rules. </dd></dl>

</div>
</div>
<a id="ac0eda9b2399fafdc35cf13a8abf71c76" name="ac0eda9b2399fafdc35cf13a8abf71c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0eda9b2399fafdc35cf13a8abf71c76">&#9670;&#160;</a></span>remove_redundant_generators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void remove_redundant_generators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If one side of any of the rules in the presentation <code class="param">p</code> is a letter <code>a</code> and the other side of the rule does not contain <code>a</code>, then this function replaces every occurrence of <code>a</code> in every rule by the other side of the rule. This substitution is performed for every such rule in the presentation; and the trivial rules (with both sides being identical) are removed. If both sides of a rule are letters, then the greater letter is replaced by the lesser one.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a784fe4c484d3c4fa97d9856f4d9363ec" name="a784fe4c484d3c4fa97d9856f4d9363ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784fe4c484d3c4fa97d9856f4d9363ec">&#9670;&#160;</a></span>remove_trivial_rules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void remove_trivial_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all instance of rules (if any) where the left-hand side and the right-hand side are identical.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the number of rules. </dd></dl>

</div>
</div>
<a id="a0c9446d7e75e55059446137dc90a5d85" name="a0c9446d7e75e55059446137dc90a5d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9446d7e75e55059446137dc90a5d85">&#9670;&#160;</a></span>replace_subword() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void replace_subword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>existing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function replaces every non-overlapping instance of <code class="param">existing</code> in every rule by <code class="param">replacement</code>. The presentation <code class="param">p</code> is changed in-place.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">existing</td><td>the word to be replaced. </td></tr>
    <tr><td class="paramname">replacement</td><td>the replacement word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>existing</code> is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e339b2779d8b2d1d40fafa4428e9513" name="a5e339b2779d8b2d1d40fafa4428e9513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e339b2779d8b2d1d40fafa4428e9513">&#9670;&#160;</a></span>replace_subword() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Iterator1, typename Iterator2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void replace_subword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1</td>          <td class="paramname"><span class="paramname"><em>first_existing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1</td>          <td class="paramname"><span class="paramname"><em>last_existing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator2</td>          <td class="paramname"><span class="paramname"><em>first_replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator2</td>          <td class="paramname"><span class="paramname"><em>last_replacement</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces every non-overlapping instance of <code>[first_existing, ! last_existing)</code> in every rule by <code>[first_replacement, ! last_replacement)</code>. The presentation <code class="param">p</code> is changed in-place </p><pre class="fragment">    \tparam Iterator1 the type of the first two parameters (iterators, or
    pointers).
    \tparam Iterator2 the type of the second two parameters (iterators,
    or pointers).

    \param p the presentation.
    \param first_existing an iterator pointing to the first letter of the
    existing subword to be replaced.
    \param last_existing an iterator pointing one past the last letter of
    the existing subword to be replaced.
    \param first_replacement an iterator pointing to the first letter of
    the replacement word.
    \param last_replacement an iterator pointing one past the last letter
    of the replacement word.

    \throws LibsemigroupsException if `first_existing == last_existing`. 
</pre> 
</div>
</div>
<a id="a92bd68d064a46c7b477e11bc4c1f8667" name="a92bd68d064a46c7b477e11bc4c1f8667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bd68d064a46c7b477e11bc4c1f8667">&#9670;&#160;</a></span>replace_subword() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void replace_subword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>existing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code class="param">existing</code> and <code class="param">replacement</code> are words, then this function replaces every non-overlapping instance of <code class="param">existing</code> in every rule by <code class="param">replacement</code>. The presentation <code class="param">p</code> is changed in-place.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">existing</td><td>the word to be replaced. </td></tr>
    <tr><td class="paramname">replacement</td><td>the replacement word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>existing</code> is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a28e29e9dcad2b9d48e1558cc1bb920" name="a8a28e29e9dcad2b9d48e1558cc1bb920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a28e29e9dcad2b9d48e1558cc1bb920">&#9670;&#160;</a></span>replace_word()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void replace_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>existing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code class="param">existing</code> and <code class="param">replacement</code> are words, then this function replaces every instance of <code class="param">existing</code> in every rule of the form <code class="param">existing</code> \(= w\) or \(w = \) <code class="param">existing</code>, with the word <code class="param">replacement</code>. The presentation <code class="param">p</code> is changed in-place.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">existing</td><td>the word to be replaced. </td></tr>
    <tr><td class="paramname">replacement</td><td>the replacement word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="a265744c7f98fbbd671d496386bbc8e98" name="a265744c7f98fbbd671d496386bbc8e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265744c7f98fbbd671d496386bbc8e98">&#9670;&#160;</a></span>replace_word_with_new_generator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> replace_word_with_new_generator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If \(w=\)<code>[first, last)</code> is a word, then replaces every non-overlapping instance (from left to right) of \(w\) in every rule, adds a new generator \(z\), and the rule \(w = z\). The new generator and rule are added even if \(w\) is not a subword of any rule.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">w</td><td>the subword to replace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new generator added.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">w</code> is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ed818a30289cea069ce8196809a8675" name="a0ed818a30289cea069ce8196809a8675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed818a30289cea069ce8196809a8675">&#9670;&#160;</a></span>replace_word_with_new_generator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> replace_word_with_new_generator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If \(w=\)<code>[first, last)</code> is a word, then this function replaces every non-overlapping instance of \(w\) in every rule, adds a new generator \(z\), and the rule \(w = z\). The new generator and rule are added even if \(w\) is not a subword of any rule.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Iterator</td><td>the type of the 2nd and 3rd parameters (iterators). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">first</td><td>the start of the subword to replace. </td></tr>
    <tr><td class="paramname">last</td><td>one beyond the end of the subword to replace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>first == last</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada89238bda7b8f989fdf2fffcb86418e" name="ada89238bda7b8f989fdf2fffcb86418e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada89238bda7b8f989fdf2fffcb86418e">&#9670;&#160;</a></span>replace_word_with_new_generator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt;<a class="el" href="group__types__group.html#ga590f23f6d9ebc02389a53e56ea1a74c1">::letter_type</a> replace_word_with_new_generator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function replaces every non-overlapping instance (from left to right) of <code class="param">w</code> in every rule, adds a new generator \(z\), and the rule \(w = z\). The new generator and rule are added even if <code class="param">w</code> is not a subword of any rule.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">w</td><td>the subword to replace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new generator added.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">w</code> is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09297ced05d3a33849423c06d9285624" name="a09297ced05d3a33849423c06d9285624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09297ced05d3a33849423c06d9285624">&#9670;&#160;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;&amp; reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverse every rule.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>an rvalue reference for a presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An rvalue reference to the reversed presentation.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="a4273c14477b26904fa81aebb11f33ec9" name="a4273c14477b26904fa81aebb11f33ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4273c14477b26904fa81aebb11f33ec9">&#9670;&#160;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverse every rule.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>. </dd></dl>

</div>
</div>
<a id="a65069c045453edf6cc59c6c2fbe65343" name="a65069c045453edf6cc59c6c2fbe65343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65069c045453edf6cc59c6c2fbe65343">&#9670;&#160;</a></span>shortest_rule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator shortest_rule </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator pointing at the left-hand side of the first rule of minimal length in the given range.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>left-hand side of the first rule. </td></tr>
    <tr><td class="paramname">last</td><td>one past the right-hand side of the last rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Iterator</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the distance between <code class="param">first</code> and <code class="param">last</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0923abe23bd54ef423419b7f11933903" name="a0923abe23bd54ef423419b7f11933903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0923abe23bd54ef423419b7f11933903">&#9670;&#160;</a></span>shortest_rule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Word &gt;::const_iterator shortest_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator pointing at the left-hand side of the first rule in the presentation with minimal length.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;Word&gt;::const_iterator</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the length of <code class="param">p.rules</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74635d388ce178f7b69d5c851bc8b93f" name="a74635d388ce178f7b69d5c851bc8b93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74635d388ce178f7b69d5c851bc8b93f">&#9670;&#160;</a></span>shortest_rule_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator::value_type::size_type shortest_rule_length </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minimum length of a rule in the given range.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>the type of the parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>left-hand side of the first rule. </td></tr>
    <tr><td class="paramname">last</td><td>one past the right-hand side of the last rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Iterator::value_type::size_type</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the length of <code class="param">p.rules</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a482393ea90410b720e40969ea90f70ad" name="a482393ea90410b720e40969ea90f70ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482393ea90410b720e40969ea90f70ad">&#9670;&#160;</a></span>shortest_rule_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Word::size_type shortest_rule_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minimum length of a rule in the presentation.</p>
<p>The <em>length</em> of a rule is defined to be the sum of the lengths of its left-hand and right-hand sides.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>Word::size_type</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if the length of <code class="param">p.rules</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59966c2bf07eb98721dfe506e3c03e4e" name="a59966c2bf07eb98721dfe506e3c03e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59966c2bf07eb98721dfe506e3c03e4e">&#9670;&#160;</a></span>sort_each_rule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sort_each_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort each rule \(u = v\) so that the left-hand side is shortlex greater than the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation whose rules should be sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the number of rules. </dd></dl>

</div>
</div>
<a id="a2a74fc9f1cf7a0fbc165106c1b3931a1" name="a2a74fc9f1cf7a0fbc165106c1b3931a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a74fc9f1cf7a0fbc165106c1b3931a1">&#9670;&#160;</a></span>sort_each_rule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sort_each_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>cmp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort each rule \(u = v\) so that the left-hand side is greater than the right-hand side with respect to <code class="param">cmp</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Compare</td><td>the type of the compare function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation whose rules should be sorted. </td></tr>
    <tr><td class="paramname">cmp</td><td>the comparison function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the number of rules. </dd></dl>

</div>
</div>
<a id="ada2524c6337ced966c9b1001c768c7d5" name="ada2524c6337ced966c9b1001c768c7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2524c6337ced966c9b1001c768c7d5">&#9670;&#160;</a></span>sort_rules() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sort_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the rules \(u_1 = v_1, \ldots, u_n = v_n\) so that \(u_1v_1 &lt; \cdots &lt; u_nv_n\) where \(&lt;\) is the shortlex order.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to sort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91480c6d87296d5586c1e17df0d0d437" name="a91480c6d87296d5586c1e17df0d0d437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91480c6d87296d5586c1e17df0d0d437">&#9670;&#160;</a></span>sort_rules() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sort_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>cmp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the rules \(u_1 = v_1, \ldots, u_n = v_n\) so that \(u_1v_1 &lt; \cdots &lt; u_nv_n\) where \(&lt;\) is the order defined by <code class="param">cmp</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Compare</td><td>the type of the compare function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation to sort. </td></tr>
    <tr><td class="paramname">cmp</td><td>the comparison function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code>p.rules.size()</code> is odd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafe7deda5b5f239dfca3054c32de9da3" name="aafe7deda5b5f239dfca3054c32de9da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe7deda5b5f239dfca3054c32de9da3">&#9670;&#160;</a></span>strongly_compress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool strongly_compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Strongly compress a \(1\)-relation presentation.</p>
<p>Returns <code>true</code> if the \(1\)-relation presentation <code class="param">p</code> has been modified and <code>false</code> if not. The word problem is solvable for the input presentation if it is solvable for the modified version.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>bool</code>.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>This function guarantees not to throw a <a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html">LibsemigroupsException</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="#ad503a8cc1838501f3b2b26bbb3fe78ee">is_strongly_compressible</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1569bd727eb77cb388ea564b0da00a84" name="a1569bd727eb77cb388ea564b0da00a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1569bd727eb77cb388ea564b0da00a84">&#9670;&#160;</a></span>to_gap_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> to_gap_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>var_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the string of GAP code that could be used to create an object with the same alphabet and rules as <code class="param">p</code> in GAP. Presentations in GAP are created by taking quotients of free semigroups or monoids.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">var_name</td><td>the name of the variable to be used in GAP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">has</code> more than 49 generators. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaa78f3583eccd084393f466b5615a7e" name="afaa78f3583eccd084393f466b5615a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa78f3583eccd084393f466b5615a7e">&#9670;&#160;</a></span>to_gap_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> to_gap_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; <a class="el" href="group__types__group.html#ga4c833ae5c1a57b830205688bf18f9991">word_type</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>var_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the string of GAP code that could be used to create an object with the same alphabet and rules as <code class="param">p</code> in GAP. Presentations in GAP are created by taking quotients of free semigroups or monoids.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">var_name</td><td>the name of the variable to be used in GAP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if <code class="param">has</code> more than 49 generators. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5b4b6eb283afeb6c9d546c7c5988bd4" name="ae5b4b6eb283afeb6c9d546c7c5988bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b4b6eb283afeb6c9d546c7c5988bd4">&#9670;&#160;</a></span>validate_rules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word, typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void validate_rules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if every rule of in <code>[first, last)</code> consists of letters belonging to the alphabet of <code class="param">p</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
    <tr><td class="paramname">Iterator</td><td>the type of the second and third arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation whose alphabet is being validated against. </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing at the first rule to check. </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing one beyond the last rule to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structlibsemigroups_1_1_libsemigroups_exception.html" title="Exception class deriving from std::runtime_error.">LibsemigroupsException</a></td><td>if any word contains a letter not in <code>p.alphabet()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Worst case \(O(mnt)\) where \(m\) is the length of the longest word, \(n\) is the size of the <code class="param">p</code> 's alphabet and \(t\) is the distance between <code class="param">first</code> and <code class="param">last</code>. </dd></dl>

</div>
</div>
<a id="a756f5721e810bac90aca39df8f87c080" name="a756f5721e810bac90aca39df8f87c080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756f5721e810bac90aca39df8f87c080">&#9670;&#160;</a></span>validate_semigroup_inverses()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void validate_semigroup_inverses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_presentation.html">Presentation</a>&lt; Word &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word const &amp;</td>          <td class="paramname"><span class="paramname"><em>vals</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the values in <code class="param">vals</code> act as semigroup inverses for the letters of the alphabet of <code class="param">p</code>. Specifically, it checks that the \(i\)th value in <code class="param">vals</code> acts as an inverse for the \(i\)th value in <code>p.alphabet()</code>.</p>
<p>Let \(x_i\) be the \(i\)th letter in <code>p.alphabet()</code>, and suppose that \(x_i=v_j\) is in the \(j\)th position of <code class="param">vals</code>. This function checks that \(v_i = x_j\), and therefore that \((x_i^{-1})^{-1} = x\).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Word</td><td>the type of the words in the presentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the presentation. </td></tr>
    <tr><td class="paramname">vals</td><td>the values to check if the act as inverses.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Libsemigroups_Exception</td><td>if any of the following apply:<ul>
<li>the length of <code class="param">vals</code> is not the same as the length of <code>p.alphabet()</code></li>
<li><code>p.validate_word(vals)</code> throws</li>
<li><code class="param">vals</code> contains duplicate letters</li>
<li>the values in <code class="param">vals</code> do not serve as semigroup inverses. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelibsemigroups.html">libsemigroups</a></li><li class="navelem"><a class="el" href="namespacelibsemigroups_1_1presentation.html">presentation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
